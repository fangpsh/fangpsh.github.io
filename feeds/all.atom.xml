<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>fangpsh's blog</title><link href="https://fangpsh.github.io/" rel="alternate"></link><link href="https://fangpsh.github.io/feeds/all.atom.xml" rel="self"></link><id>https://fangpsh.github.io/</id><updated>2023-09-27T00:00:00+08:00</updated><entry><title>lvmcache性能简单测试</title><link href="https://fangpsh.github.io/posts/2023/2023-09-27.html" rel="alternate"></link><published>2023-09-27T00:00:00+08:00</published><updated>2023-09-27T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-09-27:/posts/2023/2023-09-27.html</id><summary type="html">&lt;p&gt;测试命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=fiotest --filename=testfio --bs=4k --iodepth=64 --size=8G --readwrite=randrw --rwmixread=75
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数据绝对值不具备参考价值，仅供娱乐。&lt;/p&gt;
&lt;h3&gt;HDD&lt;/h3&gt;
&lt;p&gt;3块7200转HDD组的RAID5，卡是H730。&lt;/p&gt;
&lt;p&gt;read: IOPS …&lt;/p&gt;</summary><content type="html">&lt;p&gt;测试命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=fiotest --filename=testfio --bs=4k --iodepth=64 --size=8G --readwrite=randrw --rwmixread=75
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数据绝对值不具备参考价值，仅供娱乐。&lt;/p&gt;
&lt;h3&gt;HDD&lt;/h3&gt;
&lt;p&gt;3块7200转HDD组的RAID5，卡是H730。&lt;/p&gt;
&lt;p&gt;read: IOPS=799, BW=3198KiB/s (3274kB/s)(259MiB/82977msec)&lt;br&gt;
  write: IOPS=265, BW=1061KiB/s (1087kB/s)(86.0MiB/82977msec)     &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jobs: 1 (f=1): [m(1)][3.8%][r=2598KiB/s,w=856KiB/s][r=649,w=214 IOPS][eta 31m:04s]
fiotest: Laying out IO file (1 file / 8192MiB)
^Cbs: 1 (f=1): [m(1)][4.2%][r=2660KiB/s,w=924KiB/s][r=665,w=231 IOPS][eta 31m:24s]
fio: terminating on signal 2
Jobs: 1 (f=1): [m(1)][4.2%][r=2614KiB/s,w=776KiB/s][r=653,w=194 IOPS][eta 31m:28s]
fiotest: (groupid=0, jobs=1): err= 0: pid=33271: Wed Jul 12 19:44:23 2023
   read: IOPS=799, BW=3198KiB/s (3274kB/s)(259MiB/82977msec)
   bw (  KiB/s): min= 1136, max= 5904, per=100.00%, avg=3200.67, stdev=1344.41, samples=165
   iops        : min=  284, max= 1476, avg=800.12, stdev=336.10, samples=165
  write: IOPS=265, BW=1061KiB/s (1087kB/s)(86.0MiB/82977msec)
   bw (  KiB/s): min=  296, max= 2184, per=100.00%, avg=1064.34, stdev=460.66, samples=165
   iops        : min=   74, max=  546, avg=266.03, stdev=115.20, samples=165
  cpu          : usr=1.08%, sys=3.63%, ctx=81548, majf=0, minf=471
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=99.9%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=66332,22020,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64
Run status group 0 (all jobs):
   READ: bw=3198KiB/s (3274kB/s), 3198KiB/s-3198KiB/s (3274kB/s-3274kB/s), io=259MiB (272MB), run=82977-82977msec
  WRITE: bw=1061KiB/s (1087kB/s), 1061KiB/s-1061KiB/s (1087kB/s-1087kB/s), io=86.0MiB (90.2MB), run=82977-82977msec
Disk stats (read/write):
    dm-0: ios=66332/22040, merge=0/0, ticks=5244735/48626, in_queue=5298771, util=99.95%, aggrios=66332/22039, aggrmerge=0/5, aggrticks=5251175/48560, aggrin_queue=5299680, aggrutil=99.92%
  sda: ios=66332/22039, merge=0/5, ticks=5251175/48560, in_queue=5299680, util=99.92%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;900G  三星SSD&lt;/h3&gt;
&lt;p&gt;read: IOPS=20.9k, BW=81.7MiB/s (85.6MB/s)(972MiB/11896msec)&lt;br&gt;
   write: IOPS=6988, BW=27.3MiB/s (28.6MB/s)(325MiB/11896msec)  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fiotest: (g=0): rw=randrw, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64
fio-3.7
Starting 1 process
^Cbs: 1 (f=1): [m(1)][16.0%][r=75.0MiB/s,w=24.6MiB/s][r=19.2k,w=6305 IOPS][eta 01m:03s]
fio: terminating on signal 2

fiotest: (groupid=0, jobs=1): err= 0: pid=33739: Wed Jul 12 19:54:38 2023
   read: IOPS=20.9k, BW=81.7MiB/s (85.6MB/s)(972MiB/11896msec)
   bw (  KiB/s): min=37812, max=228392, per=100.00%, avg=83671.26, stdev=37193.76, samples=23
   iops        : min= 9453, max=57098, avg=20917.78, stdev=9298.43, samples=23
  write: IOPS=6988, BW=27.3MiB/s (28.6MB/s)(325MiB/11896msec)
   bw (  KiB/s): min=12742, max=76160, per=100.00%, avg=27995.91, stdev=12419.04, samples=23
   iops        : min= 3185, max=19040, avg=6998.96, stdev=3104.79, samples=23
  cpu          : usr=9.49%, sys=43.70%, ctx=12196, majf=0, minf=621
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=248744,83135,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=81.7MiB/s (85.6MB/s), 81.7MiB/s-81.7MiB/s (85.6MB/s-85.6MB/s), io=972MiB (1019MB), run=11896-11896msec
  WRITE: bw=27.3MiB/s (28.6MB/s), 27.3MiB/s-27.3MiB/s (28.6MB/s-28.6MB/s), io=325MiB (341MB), run=11896-11896msec

Disk stats (read/write):
    dm-0: ios=248608/83097, merge=0/0, ticks=394513/131551, in_queue=526846, util=99.13%, aggrios=102971/47765, aggrmerge=0/0, aggrticks=199210/108608, aggrin_queue=308689, aggrutil=99.19%
    dm-1: ios=308914/83135, merge=0/0, ticks=597630/123595, in_queue=722465, util=99.19%, aggrios=268795/83135, aggrmerge=40117/0, aggrticks=459858/123656, aggrin_queue=583529, aggrutil=99.12%
  sdb: ios=268795/83135, merge=40117/0, ticks=459858/123656, in_queue=583529, util=99.12%
  dm-2: ios=0/0, merge=0/0, ticks=0/0, in_queue=0, util=0.00%
    dm-3: ios=0/60162, merge=0/0, ticks=0/202230, in_queue=203603, util=78.29%, aggrios=0/20043, aggrmerge=0/40108, aggrticks=0/64418, aggrin_queue=65072, aggrutil=78.16%
  sda: ios=0/20043, merge=0/40108, ticks=0/64418, in_queue=65072, util=78.16%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;240G SSD&lt;/h3&gt;
&lt;p&gt;笔记本拆机sata ssd，忘记型号了。&lt;/p&gt;
&lt;p&gt;read: IOPS=4783, BW=18.7MiB/s (19.6MB/s)(2155MiB/115315msec)&lt;br&gt;
   write: IOPS=1601, BW=6406KiB/s (6559kB/s)(721MiB/115315msec)  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fiotest: (g=0): rw=randrw, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64
fio-3.7
Starting 1 process
fiotest: Laying out IO file (1 file / 8192MiB)
^Cbs: 1 (f=1): [m(1)][35.3%][r=17.3MiB/s,w=5788KiB/s][r=4432,w=1447 IOPS][eta 03m:33s]
fio: terminating on signal 2

fiotest: (groupid=0, jobs=1): err= 0: pid=42122: Thu Jul 13 11:38:30 2023
   read: IOPS=4783, BW=18.7MiB/s (19.6MB/s)(2155MiB/115315msec)
   bw (  KiB/s): min= 1248, max=53032, per=99.99%, avg=19133.55, stdev=14855.41, samples=230
   iops        : min=  312, max=13258, avg=4783.33, stdev=3713.85, samples=230
  write: IOPS=1601, BW=6406KiB/s (6559kB/s)(721MiB/115315msec)
   bw (  KiB/s): min=  224, max=18216, per=99.98%, avg=6403.90, stdev=5020.15, samples=230
   iops        : min=   56, max= 4554, avg=1600.93, stdev=1255.04, samples=230
  cpu          : usr=2.83%, sys=11.27%, ctx=129066, majf=0, minf=767
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=551663,184667,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=18.7MiB/s (19.6MB/s), 18.7MiB/s-18.7MiB/s (19.6MB/s-19.6MB/s), io=2155MiB (2260MB), run=115315-115315msec
  WRITE: bw=6406KiB/s (6559kB/s), 6406KiB/s-6406KiB/s (6559kB/s-6559kB/s), io=721MiB (756MB), run=115315-115315msec

Disk stats (read/write):
    dm-0: ios=551623/184671, merge=0/0, ticks=5374110/1917689, in_queue=7304893, util=100.00%, aggrios=238513/116210, aggrmerge=0/0, aggrticks=3435302/2513779, aggrin_queue=5955870, aggrutil=99.65%
    dm-1: ios=659752/228622, merge=0/0, ticks=6014019/7467533, in_queue=13501921, util=99.65%, aggrios=571964/193540, aggrmerge=87781/35177, aggrticks=5206035/3300917, aggrin_queue=8507150, aggrutil=99.63%
  sdb: ios=571964/193540, merge=87781/35177, ticks=5206035/3300917, in_queue=8507150, util=99.63%
  dm-2: ios=0/97, merge=0/0, ticks=0/12583, in_queue=12583, util=3.20%
    dm-3: ios=55787/119912, merge=0/0, ticks=4291889/61221, in_queue=4353107, util=50.01%, aggrios=20645/32180, aggrmerge=35142/87732, aggrticks=1399374/15630, aggrin_queue=1414952, aggrutil=49.93%
  sda: ios=20645/32180, merge=35142/87732, ticks=1399374/15630, in_queue=1414952, util=49.93%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;128G SSD&lt;/h3&gt;
&lt;p&gt;笔记本拆机sata ssd。&lt;/p&gt;
&lt;p&gt;read: IOPS=4714, BW=18.4MiB/s (19.3MB/s)(2494MiB/135421msec)&lt;br&gt;
   write: IOPS=1579, BW=6319KiB/s (6470kB/s)(836MiB/135421msec  &lt;/p&gt;
&lt;p&gt;read: IOPS=4805, BW=18.8MiB/s (19.7MB/s)(6141MiB/327175msec&lt;br&gt;
   write: IOPS=1604, BW=6419KiB/s (6573kB/s)(2051MiB/327175msec  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fiotest: Laying out IO file (1 file / 8192MiB)
Jobs: 1 (f=1): [m(1)][100.0%][r=23.2MiB/s,w=7975KiB/s][r=5948,w=1993 IOPS][eta 00m:00s]
fiotest: (groupid=0, jobs=1): err= 0: pid=57813: Thu Jul 13 11:58:49 2023
   read: IOPS=4805, BW=18.8MiB/s (19.7MB/s)(6141MiB/327175msec)
   bw (  KiB/s): min= 6248, max=48080, per=99.93%, avg=19205.78, stdev=12598.96, samples=654
   iops        : min= 1562, max=12020, avg=4801.42, stdev=3149.73, samples=654
  write: IOPS=1604, BW=6419KiB/s (6573kB/s)(2051MiB/327175msec)
   bw (  KiB/s): min= 1976, max=16280, per=99.93%, avg=6413.59, stdev=4223.81, samples=654
   iops        : min=  494, max= 4070, avg=1603.38, stdev=1055.95, samples=654
  cpu          : usr=3.06%, sys=12.80%, ctx=661831, majf=0, minf=1063
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=1572145,525007,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=18.8MiB/s (19.7MB/s), 18.8MiB/s-18.8MiB/s (19.7MB/s-19.7MB/s), io=6141MiB (6440MB), run=327175-327175msec
  WRITE: bw=6419KiB/s (6573kB/s), 6419KiB/s-6419KiB/s (6573kB/s-6573kB/s), io=2051MiB (2150MB), run=327175-327175msec

Disk stats (read/write):
    dm-0: ios=1569860/524263, merge=0/0, ticks=15852577/4869021, in_queue=20730282, util=100.00%, aggrios=601264/252260, aggrmerge=0/0, aggrticks=7045989/1734373, aggrin_queue=8781558, aggrutil=99.39%
    dm-1: ios=1773240/544227, merge=0/0, ticks=18694929/5185817, in_queue=23884327, util=99.39%, aggrios=1664287/532332, aggrmerge=108953/11972, aggrticks=16974042/4996891, aggrin_queue=21970715, aggrutil=99.39%
  sdb: ios=1664287/532332, merge=108953/11972, ticks=16974042/4996891, in_queue=21970715, util=99.39%
  dm-2: ios=0/79, merge=0/0, ticks=0/419, in_queue=419, util=0.04%
    dm-3: ios=30553/212475, merge=0/0, ticks=2443039/16883, in_queue=2459928, util=10.99%, aggrios=19527/107630, aggrmerge=11026/104845, aggrticks=1467981/9068, aggrin_queue=1476936, aggrutil=10.87%
  sda: ios=19527/107630, merge=11026/104845, ticks=1467981/9068, in_queue=1476936, util=10.87%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;890G Intel SSD&lt;/h3&gt;
&lt;p&gt;企业级intel sata ssd&lt;/p&gt;
&lt;p&gt;read: IOPS=19.5k, BW=76.3MiB/s (80.0MB/s)(2778MiB/36395msec)&lt;br&gt;
   write: IOPS=6536, BW=25.5MiB/s (26.8MB/s)(929MiB/36395msec  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Starting 1 process
fiotest: Laying out IO file (1 file / 8192MiB)
^Cbs: 1 (f=1): [m(1)][46.2%][r=15.1MiB/s,w=5005KiB/s][r=3871,w=1251 IOPS][eta 00m:43s] 00m:47s]
fio: terminating on signal 2

fiotest: (groupid=0, jobs=1): err= 0: pid=20853: Wed Jul 19 11:42:14 2023
   read: IOPS=19.5k, BW=76.3MiB/s (80.0MB/s)(2778MiB/36395msec)
   bw (  KiB/s): min=12072, max=135128, per=100.00%, avg=78829.97, stdev=32979.49, samples=72
   iops        : min= 3018, max=33782, avg=19707.47, stdev=8244.85, samples=72
  write: IOPS=6536, BW=25.5MiB/s (26.8MB/s)(929MiB/36395msec)
   bw (  KiB/s): min= 3816, max=45560, per=100.00%, avg=26372.75, stdev=11117.47, samples=72
   iops        : min=  954, max=11390, avg=6593.17, stdev=2779.35, samples=72
  cpu          : usr=9.61%, sys=45.24%, ctx=52541, majf=0, minf=313
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=711127,237910,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=76.3MiB/s (80.0MB/s), 76.3MiB/s-76.3MiB/s (80.0MB/s-80.0MB/s), io=2778MiB (2913MB), run=36395-36395msec
  WRITE: bw=25.5MiB/s (26.8MB/s), 25.5MiB/s-25.5MiB/s (26.8MB/s-26.8MB/s), io=929MiB (974MB), run=36395-36395msec

Disk stats (read/write):
    dm-3: ios=711127/237928, merge=0/0, ticks=1039387/303713, in_queue=1343100, util=99.76%, aggrios=241532/83797, aggrmerge=0/0, aggrticks=391189/204710, aggrin_queue=595900, aggrutil=99.24%
    dm-1: ios=1/9, merge=0/0, ticks=2/9, in_queue=11, util=0.02%, aggrios=736859/238847, aggrmerge=7/6, aggrticks=1295458/300504, aggrin_queue=1361540, aggrutil=99.42%
  sda: ios=736859/238847, merge=7/6, ticks=1295458/300504, in_queue=1361540, util=99.42%
    dm-2: ios=683/13026, merge=0/0, ticks=302/313396, in_queue=313698, util=70.16%, aggrios=1171/25992, aggrmerge=0/0, aggrticks=521/598100, aggrin_queue=589389, aggrutil=71.17%
  sdb: ios=1171/25992, merge=0/0, ticks=521/598100, in_queue=589389, util=71.17%
  dm-0: ios=723914/238356, merge=0/0, ticks=1173265/300727, in_queue=1473992, util=99.24%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;M2 转SATA，LITE256G&lt;/h3&gt;
&lt;p&gt;read: IOPS=14.8k, BW=57.9MiB/s (60.7MB/s)(6141MiB/106067msec)&lt;br&gt;
   write: IOPS=4949, BW=19.3MiB/s (20.3MB/s)(2051MiB/106067msec)  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jobs: 1 (f=1): [m(1)][100.0%][r=70.9MiB/s,w=23.8MiB/s][r=18.2k,w=6088 IOPS][eta 00m:00s]
fiotest: (groupid=0, jobs=1): err= 0: pid=31276: Tue Jul 25 18:07:34 2023
   read: IOPS=14.8k, BW=57.9MiB/s (60.7MB/s)(6141MiB/106067msec)
   bw (  KiB/s): min= 3568, max=132568, per=100.00%, avg=60133.22, stdev=20903.83, samples=209
   iops        : min=  892, max=33142, avg=15033.25, stdev=5225.97, samples=209
  write: IOPS=4949, BW=19.3MiB/s (20.3MB/s)(2051MiB/106067msec)
   bw (  KiB/s): min= 1264, max=44216, per=100.00%, avg=20079.80, stdev=6936.10, samples=209
   iops        : min=  316, max=11054, avg=5019.90, stdev=1734.01, samples=209
  cpu          : usr=8.36%, sys=36.47%, ctx=268925, majf=0, minf=1319
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=1572145,525007,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=57.9MiB/s (60.7MB/s), 57.9MiB/s-57.9MiB/s (60.7MB/s-60.7MB/s), io=6141MiB (6440MB), run=106067-106067msec
  WRITE: bw=19.3MiB/s (20.3MB/s), 19.3MiB/s-19.3MiB/s (20.3MB/s-20.3MB/s), io=2051MiB (2150MB), run=106067-106067msec

Disk stats (read/write):
    dm-0: ios=1571473/524811, merge=0/0, ticks=5559849/416907, in_queue=5976756, util=99.94%, aggrios=555099/206074, aggrmerge=0/0, aggrticks=2011526/221758, aggrin_queue=2233284, aggrutil=99.44%
    dm-1: ios=1665053/525143, merge=0/0, ticks=6031197/411037, in_queue=6442234, util=99.44%, aggrios=1665050/525149, aggrmerge=3/18, aggrticks=6019563/408492, aggrin_queue=5488645, aggrutil=99.44%
  sdb: ios=1665050/525149, merge=3/18, ticks=6019563/408492, in_queue=5488645, util=99.44%
  dm-2: ios=0/24, merge=0/0, ticks=0/17, in_queue=17, util=0.01%
    dm-3: ios=244/93055, merge=0/0, ticks=3382/254221, in_queue=257603, util=70.01%, aggrios=244/93050, aggrmerge=0/0, aggrticks=3371/253941, aggrin_queue=231400, aggrutil=70.01%
  sda: ios=244/93050, merge=0/0, ticks=3371/253941, in_queue=231400, util=70.01%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;M2 转 SATA，HFS128，LITE256&lt;/h3&gt;
&lt;p&gt;HFS128&lt;br&gt;
  read: IOPS=5392, BW=21.1MiB/s (22.1MB/s)(1652MiB/78403msec)&lt;br&gt;
  write: IOPS=1807, BW=7229KiB/s (7402kB/s)(553MiB/78403msec);   &lt;/p&gt;
&lt;p&gt;LITE256&lt;br&gt;
  read: IOPS=7093, BW=27.7MiB/s (29.1MB/s)(1503MiB/54254msec)&lt;br&gt;
 write: IOPS=2376, BW=9505KiB/s (9733kB/s)(504MiB/54254msec);  &lt;/p&gt;
&lt;h3&gt;淘宝20元M2转SATA，LITE128&lt;/h3&gt;
&lt;p&gt;read: IOPS=10.2k, BW=39.0MiB/s (41.9MB/s)(6141MiB/153649msec)&lt;br&gt;
   write: IOPS=3416, BW=13.3MiB/s (13.0MB/s)(2051MiB/153649msec)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fiotest: (g=0): rw=randrw, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64
fio-3.7
Starting 1 process
fiotest: Laying out IO file (1 file / 8192MiB)
Jobs: 1 (f=1): [m(1)][99.4%][r=50.5MiB/s,w=16.0MiB/s][r=12.9k,w=4350 IOPS][eta 00m:01s]
fiotest: (groupid=0, jobs=1): err= 0: pid=9475: Mon Aug 28 18:17:58 2023
   read: IOPS=10.2k, BW=39.0MiB/s (41.9MB/s)(6141MiB/153649msec)
   bw (  KiB/s): min=   16, max=58200, per=100.00%, avg=41310.11, stdev=16748.03, samples=304
   iops        : min=    4, max=14550, avg=10327.51, stdev=4187.01, samples=304
  write: IOPS=3416, BW=13.3MiB/s (13.0MB/s)(2051MiB/153649msec)
   bw (  KiB/s): min=   40, max=19256, per=100.00%, avg=13840.74, stdev=5542.56, samples=303
   iops        : min=   10, max= 4814, avg=3460.16, stdev=1385.63, samples=303
  cpu          : usr=6.09%, sys=18.46%, ctx=204245, majf=0, minf=26
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=1572145,525007,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=39.0MiB/s (41.9MB/s), 39.0MiB/s-39.0MiB/s (41.9MB/s-41.9MB/s), io=6141MiB (6440MB), run=153649-153649msec
  WRITE: bw=13.3MiB/s (13.0MB/s), 13.3MiB/s-13.3MiB/s (13.0MB/s-13.0MB/s), io=2051MiB (2150MB), run=153649-153649msec

Disk stats (read/write):
  sdb: ios=1571481/527350, merge=0/48, ticks=8488777/1080773, in_queue=9568096, util=100.00%

fiotest: Laying out IO file (1 file / 8192MiB)
Jobs: 1 (f=1): [m(1)][99.2%][r=49.8MiB/s,w=16.6MiB/s][r=12.8k,w=4248 IOPS][eta 00m:01s]
fiotest: (groupid=0, jobs=1): err= 0: pid=9501: Mon Aug 28 18:27:02 2023
   read: IOPS=12.4k, BW=48.4MiB/s (50.8MB/s)(6141MiB/126811msec)
   bw (  KiB/s): min=11672, max=58432, per=99.96%, avg=49571.25, stdev=4673.00, samples=253
   iops        : min= 2918, max=14608, avg=12392.81, stdev=1168.25, samples=253
  write: IOPS=4140, BW=16.2MiB/s (16.0MB/s)(2051MiB/126811msec)
   bw (  KiB/s): min= 4176, max=19736, per=99.96%, avg=16553.93, stdev=1554.00, samples=253
   iops        : min= 1044, max= 4934, avg=4138.45, stdev=388.50, samples=253
  cpu          : usr=7.32%, sys=21.91%, ctx=194103, majf=0, minf=26
  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &amp;gt;=64=100.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &amp;gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &amp;gt;=64=0.0%
     issued rwts: total=1572145,525007,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=64

Run status group 0 (all jobs):
   READ: bw=48.4MiB/s (50.8MB/s), 48.4MiB/s-48.4MiB/s (50.8MB/s-50.8MB/s), io=6141MiB (6440MB), run=126811-126811msec
  WRITE: bw=16.2MiB/s (16.0MB/s), 16.2MiB/s-16.2MiB/s (16.0MB/s-16.0MB/s), io=2051MiB (2150MB), run=126811-126811msec

Disk stats (read/write):
  sdb: ios=1568831/523974, merge=0/25, ticks=6819307/982445, in_queue=7801866, util=100.00%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;简单总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;lvmcache 效果不错；&lt;/li&gt;
&lt;li&gt;intel和三星的ssd 性能不错，ssd 一分钱一分货，差距明显；&lt;/li&gt;
&lt;li&gt;m2转sata，基本无性能损失，利旧m2 ssd的话，够用；&lt;/li&gt;
&lt;li&gt;淘宝的m2转sata，相比绿联的转盒，性能没啥差别，便宜3倍+；&lt;/li&gt;
&lt;li&gt;ssd lvmcache 突发/平均性能不错，但是方差极大，可能出现毛刺阻塞、性能毛刺；&lt;/li&gt;
&lt;li&gt;为防止ssd掉盘，槽位有空间的话，建议给cache做raid1；&lt;/li&gt;
&lt;/ol&gt;</content><category term="2023"></category><category term="lvm"></category></entry><entry><title>lvmcache 缓存盘掉盘处理</title><link href="https://fangpsh.github.io/posts/2023/2023-09-26.html" rel="alternate"></link><published>2023-09-26T00:00:00+08:00</published><updated>2023-09-26T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-09-26:/posts/2023/2023-09-26.html</id><summary type="html">&lt;p&gt;一块老旧的SSD，使用lvmcache 作为读写缓存，今天掉盘了，系统hang 住，重启后一堆报错：&lt;code&gt;Warning: dracut-initqueue timeout - starting timeout scripts&lt;/code&gt;，启动失败，自动进入了救援模式 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;一块老旧的SSD，使用lvmcache 作为读写缓存，今天掉盘了，系统hang 住，重启后一堆报错：&lt;code&gt;Warning: dracut-initqueue timeout - starting timeout scripts&lt;/code&gt;，启动失败，自动进入了救援模式&lt;code&gt;dracut:/#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;救援模式中，lvm 的变更操作都会报警：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Read-only locking type set. Write locks are prohibited.
Can&amp;#39;t get lock for...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要手工编辑下&lt;code&gt;/etc/lvm/lvm.conf&lt;/code&gt; 将&lt;code&gt;locking_type=4&lt;/code&gt; 修改为&lt;code&gt;locking_type=1&lt;/code&gt;，再继续。&lt;/p&gt;
&lt;p&gt;先尝试强制移除cache，失败了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dracut:/# lucomvert -uncache centos/root --force
Couldn&amp;#39;t find device with unid Buatb2-rxoc-8B6f -cf8y-3XR3-JTer-WNS6tJ.
WARNING: Cache pool data. logical wolume centos/cache_ cdata is missing.
WARNING: Cache pool metadata logical volume centos/cache_cmeta is missing.
WARMING: Uncaching of partially missi ng writethrough cache volume centos/root might destroy your date
Do you really want to uncache centos/root with missing LUs? lym]:y
t 1366 4737991 Buffer I&amp;#39;d error on dey dm-3, logical block async page read
devmapper centos -cache_cmeta: read failed: Input / output error
Failed to active cache locally centos/root.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再试一试&lt;code&gt;lvm unreduce --removemiss centos --force&lt;/code&gt;，也失败了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Couldn&amp;#39;t find device with unid BuatbZ-rxoc-8B6r -cf8y-3XR3-JTer-uNS6tj.
WARNING:_ Removing partial LU centos/root:
1388 5592321 Buffer Iro error on dey dm-3, logical block 8, async page read
devmapper/centos-cache, cmeta: read failed: imput/output error
failed to active cache locally centosroot.
Failed to uncache centos/root.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看到有说可以再用一块盘，&lt;a href="https://unix.stackexchange.com/questions/489182/lvm-pv-missing-after-reboot"&gt;替换为相同的UUID&lt;/a&gt;，没折腾，最终用&lt;a href="https://github.com/lvmteam/lvm2/issues/35"&gt;这个issue&lt;/a&gt;的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;At this point, the only way I found this can be fixed is to take the /etc/lvm/backup/lvmgroup file, modify it to remove the cache entries, rename the disk_corig back to disk, add "VISIBLE" flag back, and then run vgcfgrestore -f on the modified file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先保存下原配置（/etc/lvm/backup/centos），例如原配置是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
centos {
        id = &amp;quot;cPeVKa-nu1q-wuPJ-bcXB-1tYT-12aG-ALYYoT&amp;quot;
        seqno = 8
        format = &amp;quot;lvm2&amp;quot;                 # informational
        status = [&amp;quot;RESIZEABLE&amp;quot;, &amp;quot;READ&amp;quot;, &amp;quot;WRITE&amp;quot;]
        flags = []
        extent_size = 8192              # 4 Megabytes
        max_lv = 0
        max_pv = 0
        metadata_copies = 0

        physical_volumes {

                pv0 {
                        id = &amp;quot;aJVnc3-w0xI-7WkX-Ejww-ROnQ-V1br-dsz6VX&amp;quot;
                        device = &amp;quot;/dev/sda2&amp;quot;    # Hint only

                        status = [&amp;quot;ALLOCATABLE&amp;quot;]
                        flags = []
                        dev_size = 3902797824   # 1.81738 Terabytes
                        pe_start = 2048
                        pe_count = 476415       # 1.81738 Terabytes
                }

                pv1 {
                        id = &amp;quot;i6BCMc-GcML-GO3g-UISN-83fg-39Cg-rTZFe8&amp;quot;
                        device = &amp;quot;/dev/sdb&amp;quot;     # Hint only

                        status = [&amp;quot;ALLOCATABLE&amp;quot;]
                        flags = []
                        dev_size = 248774656    # 118.625 Gigabytes
                        pe_start = 2048
                        pe_count = 30367        # 118.621 Gigabytes
                }
        }
        logical_volumes {

                root {
                        id = &amp;quot;rmdkDt-zyEW-i9UX-VLch-jzLr-154x-57Si74&amp;quot;
                        status = [&amp;quot;READ&amp;quot;, &amp;quot;WRITE&amp;quot;, &amp;quot;VISIBLE&amp;quot;]
                        flags = []
                        creation_time = 1693208343      # 2023-08-28 15:39:03 +0800
                        creation_host = &amp;quot;localhost.localdomain&amp;quot;
                        segment_count = 1

                        segment1 {
                                start_extent = 0
                                extent_count = 476415   # 1.81738 Terabytes

                                type = &amp;quot;cache&amp;quot;
                                cache_pool = &amp;quot;cache&amp;quot;
                                origin = &amp;quot;root_corig&amp;quot;
                        }
                }
                cache {
                ...
                }
                cache_cdata {
                ...
                }
                cache_cmeta {
                ...
                }
                lvol0_pmspare {
                ...
                }
                root_corig {
                        id = &amp;quot;12gqfI-5f9u-SRkw-yTtc-PE12-x38t-h4lYUa&amp;quot;
                        status = [&amp;quot;READ&amp;quot;, &amp;quot;WRITE&amp;quot;]
                        flags = []
                        creation_time = 1693276572      # 2023-08-29 10:36:12 +0800
                        creation_host = &amp;quot;sz-node-8-12&amp;quot;
                        segment_count = 1

                        segment1 {
                                start_extent = 0
                                extent_count = 476415   # 1.81738 Terabytes

                                type = &amp;quot;striped&amp;quot;
                                stripe_count = 1        # linear

                                stripes = [
                                        &amp;quot;pv0&amp;quot;, 0
                                ]
                        }
                }
        }

}                                                                                   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将cache 相关的lv 配置都删除，掉盘的pv1 也可以删了，更新下&lt;code&gt;lv root&lt;/code&gt; ，主要是修改segment 段配置 ，把root_corig 里面的挪过来即可，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;        logical_volumes {

                root {
                        id = &amp;quot;rmdkDt-zyEW-i9UX-VLch-jzLr-154x-57Si74&amp;quot;
                        status = [&amp;quot;READ&amp;quot;, &amp;quot;WRITE&amp;quot;, &amp;quot;VISIBLE&amp;quot;]
                        flags = []
                        creation_time = 1693208343      # 2023-08-28 15:39:03 +0800
                        creation_host = &amp;quot;localhost.localdomain&amp;quot;
                        segment_count = 1

                        segment1 {
                                start_extent = 0
                                extent_count = 476415   # 1.81738 Terabytes

                                type = &amp;quot;striped&amp;quot;
                                stripe_count = 1        # linear

                                stripes = [
                                        &amp;quot;pv0&amp;quot;, 0
                                ]
                        }
                }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后执行 &lt;code&gt;lvs vgcfgrestore -f 配置文件 vg名称&lt;/code&gt; 生效。&lt;/p&gt;</content><category term="2023"></category><category term="lvm"></category></entry><entry><title>DNS Cache投毒事件处理</title><link href="https://fangpsh.github.io/posts/2023/2023-09-05.html" rel="alternate"></link><published>2023-09-05T00:00:00+08:00</published><updated>2023-09-05T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-09-05:/posts/2023/2023-09-05.html</id><summary type="html">&lt;p&gt;最近同事在办公网登录 aws 控制台（ap-southeast-1.console.aws.amazon.com），浏览器提示证书异常，怀疑IT做了劫持（我们做过一些网站的劫持，劫持到sniproxy，进行透明 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近同事在办公网登录 aws 控制台（ap-southeast-1.console.aws.amazon.com），浏览器提示证书异常，怀疑IT做了劫持（我们做过一些网站的劫持，劫持到sniproxy，进行透明代理）：
&lt;img alt="aws 被劫持" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230905171716.jpg"&gt;&lt;/p&gt;
&lt;p&gt;里面的域名是 djfidicjmwos.com，
搜索这个域名，有一个类似的帖子：&lt;a href="http://www.0818tuan.com/xbhd/1733117.html"&gt;部分网站登录时不时提示“你的连接不是专用连接”，然后进不去后，等会又可以进&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;查看办公网的localdns，上游是深圳电信返回：&lt;/p&gt;
&lt;p&gt;&lt;img alt="localdns-log" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230905172052.png"&gt;&lt;/p&gt;
&lt;p&gt;可疑IP：156.234.127.142&lt;/p&gt;
&lt;p&gt;直接访问这个IP 的https端口，返回证书和劫持一致：
&lt;img alt="证书报警" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230905171559.jpeg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;序列号 9F87F0D7AA5DAD293B3FAB5ADAE9606
根证书 否
算法  SHA384WithRSA
证书类型    DV
证书品牌    Comodo
私钥长度    2048 Bits
SHA1指纹  6BB71F0A72CD9DC0E51117373957DB4036B475F5
SHA256指纹    F3B1564D750EFE874AC166D427BC5ACF7E4554BEFCF3988B7F0EE069905A0B02
公钥PIN-SHA256    aSE+RSj9ELhDFz+sK8mVtlJQ0gUX2j0sTRHQa69sjco=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按这个IP查询ti.360.net ，看起来和博彩相关：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ip 信息" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230905172306.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;直接对202.96.128.166 发起请求，会间歇性返回这个IP，可能只是集群中某台服务器异常 ，
这条记录的TTL特别长。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dig  @202.96.128.166 ap-southeast-1.console.aws.amazon.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @202.96.128.166 ap-southeast-1.console.aws.amazon.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 42939
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 4, ADDITIONAL: 8

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;ap-southeast-1.console.aws.amazon.com. IN A

;; ANSWER SECTION:
ap-southeast-1.console.aws.amazon.com. 600 IN CNAME gr.console-geo.ap-southeast-1.amazonaws.com.
gr.console-geo.ap-southeast-1.amazonaws.com. 600 IN CNAME a299197c08ba4f000.awsglobalaccelerator.com.
a299197c08ba4f000.awsglobalaccelerator.com. 2206 IN A 156.234.127.142

;; AUTHORITY SECTION:
awsglobalaccelerator.com. 46274 IN      NS      ns-1484.awsdns-57.org.
awsglobalaccelerator.com. 46274 IN      NS      ns-409.awsdns-51.com.
awsglobalaccelerator.com. 46274 IN      NS      ns-609.awsdns-12.net.
awsglobalaccelerator.com. 46274 IN      NS      ns-1949.awsdns-51.co.uk.

;; ADDITIONAL SECTION:
ns-1949.awsdns-51.co.uk. 2130   IN      A       205.251.199.157
ns-409.awsdns-51.com.   42961   IN      A       205.251.193.153
ns-609.awsdns-12.net.   67319   IN      A       205.251.194.97
ns-1484.awsdns-57.org.  85695   IN      AAAA    2600:9000:5305:cc00::1
ns-1949.awsdns-51.co.uk. 2130   IN      AAAA    2600:9000:5307:9d00::1
ns-409.awsdns-51.com.   42961   IN      AAAA    2600:9000:5301:9900::1
ns-609.awsdns-12.net.   47034   IN      AAAA    2600:9000:5302:6100::1

;; Query time: 1113 msec
;; SERVER: 202.96.128.166#53(202.96.128.166)
;; WHEN: Mon Sep 04 17:09:16 CST 2023
;; MSG SIZE  rcvd: 486
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;请求114.114.114.114 ，返回的是：156.234.127.138，一个C段，直接返回https 443端口，返回一样的证书。阿里的223.5.5.5，还有一个C段IP：156.234.127.27。&lt;/p&gt;
&lt;p&gt;DNSPod 的119.29.29.29 多次测试，没发现异常。
1.1.1.1 和 8.8.8.8多次测试，也无异常。&lt;/p&gt;
&lt;p&gt;正常响应是3.3.15.1 和3.3.14.1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ap-southeast-1.console.aws.amazon.com. 126 IN CNAME gr.console-geo.ap-southeast-1.amazonaws.com.
gr.console-geo.ap-southeast-1.amazonaws.com. 126 IN CNAME a299197c08ba4f000.awsglobalaccelerator.com.
a299197c08ba4f000.awsglobalaccelerator.com. 186 IN A 3.3.15.1
a299197c08ba4f000.awsglobalaccelerator.com. 186 IN A 3.3.14.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="fofa一下" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230905174026.png"&gt;&lt;/p&gt;
&lt;p&gt;同事说可能aws 的系统出问题了，我觉得可能性不大。猜测几个可能的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;电信某一组服务器被入侵？不太可能，114 也出现了类似情况；&lt;/li&gt;
&lt;li&gt;跨境的中间链路上有dns 抢答，注入了恶意地址？好像可能性也不大；&lt;/li&gt;
&lt;li&gt;权威服务器的某个IP在某个域内BGP Leak 了？ 牵引了部分权威服务器的流量，然后进行抢答；&lt;/li&gt;
&lt;li&gt;DNS 缓存投毒（DNS cache poisoning）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人觉得可能性比较大的是 dns 缓存投毒了 ，有人猜测了dns查询事务id，进行了抢答。&lt;/p&gt;
&lt;p&gt;什么是DNS 缓存投毒，可参考：&lt;a href="https://www.cloudflare.com/learning/dns/dns-cache-poisoning/"&gt;cloudflare: What is DNS cache poisoning? | DNS spoofing &lt;/a&gt;，这个幻灯片讲解的比较详细 &lt;a href="https://owasp.org/www-pdf-archive/DNS_Cache_Poisoning(OWASP_GHANA).pdf"&gt;Anatomy  of a DNS Cache Poisoning Attack&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;规避方法，使用DNSSEC，或者不使用固定的源地址，随机源地址+随机事务ID，让攻击者更难猜测：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- UDP Source Port Randomization (UDP SPR): What this does is setting the UDP
source port randomly, so an attacker would have to guess both the transaction ID
and the source port in a short time window - which is usually not feasible (since they
would need to make 232 combinations).
- DNS Security Extensions (DNSSEC): It is a protocol designed to create a unique
cryptographic signature and store it alongside other DNS records. Thus, DNSSEC
provides DNS with an additional methods of verification by digitally signing the DNS
information. This is done on all levels of the DNS Resolution process. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从&lt;a href="https://www.163.com/dy/article/GQ3FFVMO0552KI0B.html"&gt;这篇文章&lt;/a&gt;看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;该变种攻击漏洞影响 Linux 内核以及流行的 DNS 软件，包括在 Linux 上运行的 BIND、Unbound 和 dnsmasq，但在其他操作系统如 FreeBSD 或 Windows 上运行的这些DNS软件则不会。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;难道是因为DNSPod 是自研，所以没受影响？&lt;/p&gt;
&lt;p&gt;最后：
深圳电信有3组内部DNS服务器，另外2组没受影响，注释掉有问题的这个地址临时规避了。&lt;/p&gt;
&lt;p&gt;IOCs：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;156.234.127.142&lt;/li&gt;
&lt;li&gt;156.234.127.138&lt;/li&gt;
&lt;li&gt;156.234.127.27&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他参考链接：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.secrss.com/articles/18219"&gt;关于国内部分地区一些网站https证书出现问题的情况分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://v2ex.com/t/656367?p=2"&gt;Github pages 的 HTTPS 是不是出问题了？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://arthurchiao.art/blog/bgp-leaks-and-crypto-currencies-zh/"&gt;[译] BGP 泄露和加密货币（2018）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2023"></category><category term="dns"></category><category term="hack"></category></entry><entry><title>再次遇到OCSP引发的卡顿超时问题</title><link href="https://fangpsh.github.io/posts/2023/2023-08-18.html" rel="alternate"></link><published>2023-08-18T00:00:00+08:00</published><updated>2023-08-18T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-08-18:/posts/2023/2023-08-18.html</id><summary type="html">&lt;p&gt;好几年前在iOS 上遇到过，最近又遇到了。之前BigSur 更新，好像也有过一次OCSP 超时的问题，参考 &lt;a href="https://sspai.com/post/63649"&gt;OCSP，伴随苹果隐私收集与泄漏的小 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;好几年前在iOS 上遇到过，最近又遇到了。之前BigSur 更新，好像也有过一次OCSP 超时的问题，参考 &lt;a href="https://sspai.com/post/63649"&gt;OCSP，伴随苹果隐私收集与泄漏的小小争议
&lt;/a&gt;。
这一次遇到是在QWebengineView 下加载超时，
由于Godaddy  OCSP 使用的akamai cdn，由于众所周知的原因，在大陆访问异常概率非常高：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dig ocsp.godaddy.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; ocsp.godaddy.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 33808
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 8, ADDITIONAL: 14

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;ocsp.godaddy.com.              IN      A

;; ANSWER SECTION:
ocsp.godaddy.com.       600     IN      A       31.13.95.17

;; AUTHORITY SECTION:
godaddy.com.            2884    IN      NS      cns2.godaddy.com.
godaddy.com.            2884    IN      NS      a11-64.akam.net.
godaddy.com.            2884    IN      NS      a6-66.akam.net.
godaddy.com.            2884    IN      NS      a9-67.akam.net.
godaddy.com.            2884    IN      NS      a1-245.akam.net.
godaddy.com.            2884    IN      NS      cns1.godaddy.com.
godaddy.com.            2884    IN      NS      a20-65.akam.net.
godaddy.com.            2884    IN      NS      a8-67.akam.net.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解决办法是要么换一个大陆的CA，要么开OCSP Stapling。开OCSP Stapling 的话，可以自己在Nginx 上折腾，或者打开CDN 的OCSP Stapling 开关。&lt;/p&gt;
&lt;p&gt;在Nginx 上折腾的话，由于Nginx 在大陆，Nginx 所在机器访问ocsp.godaddy.com 也受干扰，2个解决办法，一个是使用网友制作的&lt;a href="https://jhuo.ca/post/ocsp-stapling-letsencrypt/"&gt;ocsp-proxy&lt;/a&gt;一个是周期性从外部获取ocsp 信息，使用ngx_ssl_stapling_file 指定。&lt;/p&gt;
&lt;p&gt;无论是哪种办法，都得搞一个代理。&lt;/p&gt;
&lt;p&gt;如果要使用后者，需要将证书处理一下：
将域名证书、中间证书、根证书按照从上到下的顺序保存为fullchains.pem ，中间证书单独保存为intermediate.pem，子证书保存为 site.pem，使用&lt;code&gt;openssl ocsp&lt;/code&gt;，命令前可能需要使用&lt;code&gt;proxychains&lt;/code&gt;之类走下代理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;openssl ocsp -no_nonce -text \
-issuer intermediate.pem \  # 中间证书
-cert site.pem \            # 域名证书
-CAfile fullchains.pem \    # 完整证书链
-url http://ocsp.godaddy.com \
-header &amp;quot;HOST&amp;quot; &amp;quot;ocsp.godaddy.com&amp;quot; \
-respout ocsp.resp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从哪里取中间证书和根证书？大多数时候从CA 处下载的时候，会带一个CA Bundle文件，里面包含根证书和中间证书，拆分一下。或者可以直接从CA官网，或者用网上的证书链修复工具来获取。&lt;/p&gt;
&lt;p&gt;检查是否成功开启，外网的话也可以直接使用myssl.com 、ssllabs.com 检测：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;openssl s_client -connect 目标地址:443 -servername  目标域名  -status -tlsextdebug &amp;lt; /dev/null 2&amp;gt;&amp;amp;1 |grep OCSP -B 3 -A 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://jhuo.ca/post/ocsp-stapling-letsencrypt/"&gt;Ocsp Stapling 和iOS界面卡顿问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://c4ys.com/archives/2148"&gt;letsencrypt https证书增加OCSP Stapling解决iOS公众号H5首次打开慢问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://holmesian.org/OCSP-Stapling"&gt;记录OCSP Stapling的两个问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html"&gt;从无法开启 OCSP Stapling 说起&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2023"></category><category term="https"></category><category term="tls"></category></entry><entry><title>无法添加cloudpods 计算节点的问题排查</title><link href="https://fangpsh.github.io/posts/2023/2023-07-24.html" rel="alternate"></link><published>2023-07-24T00:00:00+08:00</published><updated>2023-07-24T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-07-24:/posts/2023/2023-07-24.html</id><summary type="html">&lt;p&gt;给cloudpods 添加一个计算节点，出错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TASK [worker-node : Use &amp;#39;ocadm join 192.168.x.x:6443 --token howsjs.XXX --discovery-token-unsafe-skip-ca-verification --enable-host-agent --node-ip 192.168.x.x --enable-hugepage &amp;#39;] ***
fatal: [192.168.x.x]: FAILED! =&amp;gt;
 {&amp;quot;changed&amp;quot;: true, &amp;quot;cmd&amp;quot;: [&amp;quot;/opt/yunion/bin/ocadm&amp;quot;, &amp;quot;join&amp;quot;, &amp;quot;192.168.x …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;给cloudpods 添加一个计算节点，出错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TASK [worker-node : Use &amp;#39;ocadm join 192.168.x.x:6443 --token howsjs.XXX --discovery-token-unsafe-skip-ca-verification --enable-host-agent --node-ip 192.168.x.x --enable-hugepage &amp;#39;] ***
fatal: [192.168.x.x]: FAILED! =&amp;gt;
 {&amp;quot;changed&amp;quot;: true, &amp;quot;cmd&amp;quot;: [&amp;quot;/opt/yunion/bin/ocadm&amp;quot;, &amp;quot;join&amp;quot;, &amp;quot;192.168.x.x:6443&amp;quot;, &amp;quot;--token&amp;quot;, &amp;quot;howsjs.XXXXXXX&amp;quot;, &amp;quot;--discovery-token-unsafe-skip-ca-verification&amp;quot;, &amp;quot;--enable-host-agent&amp;quot;, &amp;quot;--node-ip&amp;quot;, &amp;quot;192.168.8.6&amp;quot;, &amp;quot;--enable-hugepage&amp;quot;], &amp;quot;delta&amp;quot;: &amp;quot;0:05:00.667016&amp;quot;, &amp;quot;end&amp;quot;: &amp;quot;2023-07-21 15:08:32.106642&amp;quot;, &amp;quot;msg&amp;quot;: &amp;quot;non-zero return code&amp;quot;, &amp;quot;rc&amp;quot;: 1, &amp;quot;start&amp;quot;: &amp;quot;2023-07-21 15:03:31.439626&amp;quot;, &amp;quot;stderr&amp;quot;: &amp;quot;\t[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.5. Latest validated version: 18.09\nerror execution phase preflight: couldn&amp;#39;t validate the identity of the API Server: abort connecting to API servers after timeout of 5m0s&amp;quot;, &amp;quot;stderr_lines&amp;quot;: [&amp;quot;\t[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.5. Latest validated version: 18.09&amp;quot;, &amp;quot;error execution phase preflight: couldn&amp;#39;t validate the identity of the API Server: abort connecting to API servers after timeout of 5m0s&amp;quot;], &amp;quot;stdout&amp;quot;: &amp;quot;[preflight] Running pre-flight checks&amp;quot;, &amp;quot;stdout_lines&amp;quot;: [&amp;quot;[preflight] Running pre-flight checks&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;和那个Docker version 异常没啥关系，但是这段错误也让人看不懂，API Server 是正常的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;error execution phase preflight: couldn't validate the identity of the API Server: abort connecting to API servers after timeout of 5m0s&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;在ocboot 找到对应的role，将&lt;a href="https://github.com/yunionio/ocboot/blob/master/onecloud/roles/worker-node/tasks/main.yml#L106"&gt;join&lt;/a&gt; 命令日志等级提升：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-command: &amp;quot;/opt/yunion/bin/ocadm {{ join_args }}&amp;quot;
+command: &amp;quot;/opt/yunion/bin/ocadm {{ join_args }} -v 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再执行&lt;code&gt;add-node&lt;/code&gt;，输出多一些了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.... [discovery] Failed to connect to API Server \&amp;quot;192.168.x.x:6443\&amp;quot;: token id \&amp;quot;qqrnpr\&amp;quot; is invalid for this cluster or it has expired. Use \&amp;quot;kubeadm token create\&amp;quot; on the control-plane node to create a new valid token&amp;quot;, &amp;quot;I0721 17:02:24.772935   37384 token.go:199] [discovery] Trying to connect to API Server \&amp;quot;192.168.x.x:6443\&amp;quot;&amp;quot;, &amp;quot;I0721 17:02:24.773719   37384 token.go:74] [discovery] Created cluster-info discovery client, requesting info from \&amp;quot;https://192.168.8.8:6443\&amp;quot;&amp;quot;, &amp;quot;I0721 17:02:24.776478   37384 token.go:202] [discovery] Failed to connect to API Server \&amp;quot;192.168.x.x:6443\&amp;quot;: token id \&amp;quot;xxxx\&amp;quot; is invalid for this cluster or it has expired. Use \&amp;quot;kubeadm token create\&amp;quot; on the control-plane node to create a new valid token&amp;quot;, &amp;quot;I0721 17:02:29.502523   37384 token.go:219] [discovery] abort connecting to API servers after timeout of 5m0s&amp;quot;, &amp;quot;error execution phase preflight: couldn&amp;#39;t validate the identity of the API Server: abort connecting to API servers after timeout of 5m0s&amp;quot;], &amp;quot;stdout&amp;quot;: &amp;quot;[preflight] Running pre-flight checks&amp;quot;, &amp;quot;stdout_lines&amp;quot;: [&amp;quot;[preflight] Running pre-flight checks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上计算节点看看kublet 服务状态&lt;code&gt;systemctl status kubelet&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.285975   44259 reflector.go:125] k8s.io/kubernetes/pkg/kubelet/kubelet.go:445: Failed to list *v1.Service: Unauthorized
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.289409   44259 kubelet.go:2252] node &amp;quot;sz-node-8-6&amp;quot; not found
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.389659   44259 kubelet.go:2252] node &amp;quot;sz-node-8-6&amp;quot; not found
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.460715   44259 file_linux.go:61] Unable to read config path &amp;quot;/etc/kubernetes/manifests&amp;quot;: path does not exist, ignoring
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.486273   44259 reflector.go:125] k8s.io/kubernetes/pkg/kubelet/kubelet.go:454: Failed to list *v1.Node: Unauthorized
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.489897   44259 kubelet.go:2252] node &amp;quot;sz-node-8-6&amp;quot; not found
Jul 21 17:11:12 localhost kubelet: E0721 17:11:12.590123   44259 kubelet.go:2252] node &amp;quot;sz-node-8-6&amp;quot; not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Node 无法注册成功，看下kublet 的配置在哪里：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=kubelet: The Kubernetes Node Agent
Documentation=https://kubernetes.io/docs/

[Service]
ExecStart=/usr/bin/kubelet
Restart=always
StartLimitInterval=0
RestartSec=10

[Install]
WantedBy=multi-user.target

# /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf
# Note: This dropin only works with kubeadm and kubelet v1.11+
[Service]
Environment=&amp;quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&amp;quot;
Environment=&amp;quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&amp;quot;
# This is a file that &amp;quot;kubeadm init&amp;quot; and &amp;quot;kubeadm join&amp;quot; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically
EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env
# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use
# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.
EnvironmentFile=-/etc/sysconfig/kubelet
ExecStart=
ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对比了几个配置，和其他计算节点没啥差别，都是重装过的机器部署的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/kubernetes/kubelet.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
preferences: {}
users:
- name: default-auth
  user:
    client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem
    client-key: /var/lib/kubelet/pki/kubelet-client-current.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;检查下证书：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;openssl x509 -in /var/lib/kubelet/pki/kubelet-client-current.pem  -noout -text
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            6f:58:0f:41:fb:....
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=kubernetes
        Validity
            Not Before: Jul 21 10:47:00 2023 GMT
            Not After : Jul 20 10:47:00 2024 GMT
        Subject: O=system:nodes, CN=system:node:sz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;🤔发现Not  Before 怎么是50分钟之后（GMT+8），检查所有master，发现有一台master 时间异常，修正这台master 时间。重新join，终于成功了。&lt;/p&gt;
&lt;p&gt;奇怪的ntpd 进程怎么挂了，建议cloudpods 主机监控项里面增加一个时间监控？&lt;/p&gt;</content><category term="2023"></category><category term="kubernetes"></category></entry><entry><title>威联通RAID1 磁盘数据导出</title><link href="https://fangpsh.github.io/posts/2023/2023-06-12.html" rel="alternate"></link><published>2023-06-12T00:00:00+08:00</published><updated>2023-06-12T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-06-12:/posts/2023/2023-06-12.html</id><summary type="html">&lt;p&gt;公司用了多年的&lt;a href="https://www.qnap.com/en/product/ts-651"&gt;TS-651&lt;/a&gt; 坏了，修了没跑几天又坏（深圳市南山赛格新联创电脑经营部 👎 ），
最开始搜索&lt;code&gt;qnap 硬盘导出&lt;/code&gt;，首先看到&lt;a href="https://post.smzdm.com/p/301806/"&gt;smzdm&lt;/a&gt;的帖 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;公司用了多年的&lt;a href="https://www.qnap.com/en/product/ts-651"&gt;TS-651&lt;/a&gt; 坏了，修了没跑几天又坏（深圳市南山赛格新联创电脑经营部 👎 ），
最开始搜索&lt;code&gt;qnap 硬盘导出&lt;/code&gt;，首先看到&lt;a href="https://post.smzdm.com/p/301806/"&gt;smzdm&lt;/a&gt;的帖子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Qnap的磁盘分区采用的是md RAID+LVM2的两层组织结构，即使我使用的是Single模式分区也是一样的结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来有戏，尝试一下数据导出，主要参考这篇文章&lt;a href="https://ripcaster.co.uk/Data_Recovery_from_Failed_QNAP_RAID_1"&gt;Data Recovery from Failed QNAP RAID 1 on a PC using Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：在QNAP 官网&lt;a href="https://www.qnap.com.cn/zh-cn/nas-migration"&gt;数据迁移兼容性检查&lt;/a&gt;工具中，ARM 和x86 的系统是不能互相迁移的，那可能意味着ARM 的磁盘，在x86 的服务器上是不是也不能导出 🤔？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;风险提示：硬盘有价，数据无价，以下仅代表个人情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公司的磁盘是2块盘，做了RAID1，那么单独一块盘完全是镜像，先拿一块盘做下实验，搞坏的话，还剩余一个再搞个QNAP（QuTScloud） 也能读出来。&lt;/p&gt;
&lt;p&gt;同事帮忙弄了一台Dell R430，装了个CentOS7，带的阵列卡是&lt;code&gt;PERC H730 Mini&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统盘在Slot0，Qnap 拆下的磁盘在Slot1，先安装&lt;a href="https://docs.broadcom.com/docs-and-downloads/raid-controllers/raid-controllers-common-files/8-07-14_MegaCLI.zip"&gt;megacli&lt;/a&gt;。题外话，上次帮同学折腾才发现新的卡已经要用&lt;code&gt;storcli64&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;环境准备：安装&lt;code&gt;lvm2&lt;/code&gt;，&lt;code&gt;mdadm&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;插入磁盘，再将对应slot 磁盘设置为&lt;code&gt;JBOD&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./MegaCli64 -PDMakeJBOD -PhysDrv[32:1] -a0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;fdisk 能看到设备了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Disk /dev/sdb: 8001.6 GB, 8001563222016 bytes, 15628053168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk label type: gpt
Disk identifier: FDF2182D-83DC-47B6-8B39-01ECAF78BCEC


#         Start          End    Size  Type            Name
 1           40      1060289  517.7M  Microsoft basic primary
 2      1060296      2120579  517.7M  Microsoft basic primary
 3      2120584  15610264109    7.3T  Microsoft basic primary
 4  15610264112  15611324399  517.7M  Microsoft basic primary
 5  15611324408  15628031999      8G  Microsoft basic primary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;扫描一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mdadm --examine --scan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;cat /proc/mdstat&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;md123 : inactive sdb4[27](S)
      530128 blocks super 1.0

md124 : inactive sdb5[0](S)
      8353780 blocks super 1.0

md125 : inactive sdb3[0]
      7804071616 blocks super 1.0

md126 : inactive sdb1[27](S)
      530108 blocks super 1.0

md127 : inactive sdb2[2](S)
      530124 blocks super 1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数据在sdb3/md125。参考smzdm那个教程，执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mdadm -A --verbose --run ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;记得有个error，提示设备在使用中，还是什么错误（后台在自动挂载了？），手工stop 一下，再挂载就好了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mdadm --stop /dev/md125
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mdadm --run /dev/md125
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候再&lt;code&gt;cat /proc/mdstat&lt;/code&gt; 能看到&lt;code&gt;active&lt;/code&gt; 了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Personalities : [raid1]
md125 : active raid1 sdb3[0]
      7804071616 blocks super 1.0 [2/1] [U_]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着执行&lt;code&gt;pvdisplay&lt;/code&gt;，但是我并未看到&lt;code&gt;/dev/md125&lt;/code&gt; 这个PV，&lt;/p&gt;
&lt;p&gt;搜了下，需要执行&lt;code&gt;pvscan --cache&lt;/code&gt; (Updates the runtime state for all lvm devices)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  --- Physical volume ---
  PV Name               /dev/md125
  VG Name               vg289
  PV Size               &amp;lt;7.27 TiB / not usable 1.65 MiB
  Allocatable           yes (but full)
  PE Size               4.00 MiB
  Total PE              1905290
  Free PE               0
  Allocated PE          1905290
  PV UUID               hkvib9-WQfS-iyOu-b2U9-1LNa-5I2e-O2Vjwb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;lvscan 看下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  inactive          &amp;#39;/dev/vg289/lv546&amp;#39; [74.42 GiB] inherit
  inactive            &amp;#39;/dev/vg289/lv3&amp;#39; [&amp;lt;7.20 TiB] inherit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候尝试去挂载&lt;code&gt;/dev/vg289/lv3&lt;/code&gt; 发现设备不存在，需要再执行下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lvchange -ay /dev/vg289/lv3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再&lt;code&gt;mount&lt;/code&gt; 就可以了，备份完数据后，卸载的话按 ripcaster 教程文末脚本。&lt;/p&gt;
&lt;p&gt;LUKS 加密盘的挂载前面步骤一样，增加一个解密过程：
参考 &lt;a href="https://www.linux-howto.info/mount-qnap-encrypted-volume/"&gt;mount-qnap-encrypted-volume&lt;/a&gt;，
文中  storage_util 那个工具是qnap 专有的，可以用openssl 代替：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;openssl passwd -1 -salt YCCaQNAP &amp;#39;密码&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2023"></category><category term="nas"></category><category term="qnap"></category><category term="raid"></category></entry><entry><title>请给域名解析GEO线路配置兜底线路</title><link href="https://fangpsh.github.io/posts/2023/2023-06-09.html" rel="alternate"></link><published>2023-06-09T00:00:00+08:00</published><updated>2023-06-09T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-06-09:/posts/2023/2023-06-09.html</id><summary type="html">&lt;p&gt;阿里云云解析、腾讯DNSPod、AWS Route53 等均支持GEO线路解析，可以看阿里这个&lt;a href="https://help.aliyun.com/document_detail/29730.html"&gt;文档&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现原理&lt;br&gt;
云解析是通过识别LocalDNS的出口IP，来判断访问者来源。&lt;br&gt;
如果LocalDNS支持EDNS  &lt;br&gt;
因 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;阿里云云解析、腾讯DNSPod、AWS Route53 等均支持GEO线路解析，可以看阿里这个&lt;a href="https://help.aliyun.com/document_detail/29730.html"&gt;文档&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现原理&lt;br&gt;
云解析是通过识别LocalDNS的出口IP，来判断访问者来源。&lt;br&gt;
如果LocalDNS支持EDNS  &lt;br&gt;
因为云解析DNS支持 edns-client-subnet，所以在获取访问者来源IP时，优先获取 edns-client-subnet 扩展里携带的IP，如果edns-client-subnet 扩展里存在IP，云解析DNS会以该IP来判断访问者的地理位置 ；如果不存在，则以LocalDNS出口IP来判断访问者的地理位置。&lt;br&gt;
如果LocalDNS不支持EDNS    &lt;br&gt;
LocalDNS会迭代请求至云解析DNS，云解析DNS根据访问者LocalDNS出口IP来判断访问者的地址位置，实现智能解析。  &lt;br&gt;
如果LocalDNS变相支持EDNS    &lt;br&gt;
用户发起DNS请求，递归到LocalDNS，则LocalDNS将本次请求发送到二级节点，通过二级节点向云解析DNS发起请求，此时云解析DNS会根据LocalDNS二级节点的地域位置返回具体
的细分线路解析结果。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这上面调度靠的就是IP库，调度的准确性完全依赖这个库。
能不能准确的将你想要的用户调度到对应的节点，这里面会有2个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;厂商的IP库准不准；&lt;/li&gt;
&lt;li&gt;厂商的研发怎么处理IP库字段和GEO 匹配逻辑；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IPIP.NET创始人高春晖写过一个系列：&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NDMzODY1MQ==&amp;amp;action=getalbum&amp;amp;album_id=2292580962339192832&amp;amp;scene=173&amp;amp;from_msgid=2247484081&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect"&gt;DNS智能解析功能评测&lt;/a&gt;，读完这个系列文档，我们就能发现，除了使用了IPIP 的的DNSPod和DNS.COM，其他厂商都一塌糊涂。&lt;/p&gt;
&lt;p&gt;如果你认为高春晖是自卖自夸，那大可实际测试一下。从我的体验来看，他说的没错。&lt;/p&gt;
&lt;p&gt;这里的本质问题就是IPIP的数据和准确性好了一大截。印象阿里是有采购IPIP，但是似乎是只给了CDN 业务用，阿里云解析还自己搞了一个IP库，和IPIP.NET 闹了一段官司后道歉下线了。&lt;/p&gt;
&lt;p&gt;你可能会问AWS 是不是好一点，头部大厂，做国外业务的，对国外分国家地区解析用Route53更好一点？ 实际的情况是Route53 用的是Maxmind，而Maxmind 的数据从我过往的经验来看，及时性和准确比IPIP 差很多，有时候甚至比IP2Location 还差。（至于Route53 权威节点的网络性能，暂不讨论，只讨论线路的准确性的。对了，Route53 按解析次数收费，也太贵了。。别上贼船）&lt;/p&gt;
&lt;p&gt;总之，我个人感觉如果IPIP.NET 打90分，那Maxmind 和IP2Location 就大概60~70分，基于他们做出来的产品也就差不多。&lt;/p&gt;
&lt;p&gt;回到DNS解析这个兜底线路问题，如果DNS 的IP库不准，特别是对一些localdns 的出口ip（回看下上面阿里云的的原理）识别不准，&lt;/p&gt;
&lt;h4&gt;例1&lt;/h4&gt;
&lt;p&gt;例如一个广东 联通的出口IP，IP库识别出来可能是 &lt;code&gt;中国 联通&lt;/code&gt;，或者只有&lt;code&gt;联通&lt;/code&gt;，这个时候如果你的线路是这么配置的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认 -&amp;gt; x.y.z.0&lt;/li&gt;
&lt;li&gt;华北 电信 -&amp;gt; x.y.z.1&lt;/li&gt;
&lt;li&gt;华南 联通 -&amp;gt; x.y.z.2&lt;/li&gt;
&lt;li&gt;华北 移动 -&amp;gt; x.y.z.3&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么就会匹配到 &lt;code&gt;默认 x.y.z.0&lt;/code&gt;，如果这个IP 不是BGP 线路，就跨网绕了一圈。
加一个&lt;code&gt;联通 -&amp;gt; x.y.z.4&lt;/code&gt; 可以防止这种情况。&lt;/p&gt;
&lt;h4&gt;例2&lt;/h4&gt;
&lt;p&gt;如果你的解析线路是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电信 -&amp;gt; x.y.z.0&lt;/li&gt;
&lt;li&gt;联通 -&amp;gt; x.y.z.1&lt;/li&gt;
&lt;li&gt;移动 -&amp;gt; x.y.z.2&lt;/li&gt;
&lt;li&gt;广电 -&amp;gt; x.y.z.3&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;境外 -&amp;gt; x.y.z.101&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是的，你是把厂商支持的分运营商线路都加上了，但是就没加&lt;code&gt;默认&lt;/code&gt;线路，&lt;strong&gt;但是也会有少数国内用户的IP，IP库读出来不带ISP 信息&lt;/strong&gt;，那这部分用户这个时候会拿不到解析结果。&lt;/p&gt;
&lt;h4&gt;例3&lt;/h4&gt;
&lt;p&gt;按洲配置了解析线路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认-&amp;gt; 腾讯北京IP&lt;/li&gt;
&lt;li&gt;亚洲-&amp;gt; 阿里香港IP&lt;/li&gt;
&lt;li&gt;欧洲-&amp;gt; AWS 德国IP&lt;/li&gt;
&lt;li&gt;大洋洲..&lt;/li&gt;
&lt;li&gt;北美洲..&lt;/li&gt;
&lt;li&gt;..洲&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个境外IP 识别出来是空，会直接走到&lt;code&gt;默认 腾讯北京&lt;/code&gt;，这个时候保险一点加上&lt;code&gt;境外线路&lt;/code&gt;。我们并不知道DNS的研发会如何处理这种情况，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;境外线路，是匹配明确了境外地区国家的？对于无国家的，走默认线路；&lt;/li&gt;
&lt;li&gt;境外线路，是匹配所有除了中国大陆意外的IP？对于无国家的，如果有境外线路，走境外线路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BTW. 如果上面这种情况，你怕自己一不小心没有把&lt;code&gt;洲&lt;/code&gt;线路加全，那更应该加一个&lt;code&gt;境外&lt;/code&gt;线路兜底。&lt;/p&gt;
&lt;p&gt;BTW2. Route53 没有境外线路，他的默认是全球，你需要单独添加中国线路，逻辑和国内厂商相反。&lt;/p&gt;
&lt;h4&gt;例4&lt;/h4&gt;
&lt;p&gt;你写了一堆脚本，按每个国家分线路配置了，但是哪天脚本出错，少添加了一个国家或者运维误删了一个国家，这个国家直接走到默认线路，默认线路指向的可能是北京。 （如果没有默认线路，就更惨了）&lt;/p&gt;
&lt;p&gt;你写了一堆脚本，按每个国家分线路配置了，但是IP库的对于一些小国家和争议地区的代码和DNS调度系统不一致，DNS 研发没处理或者不想处理这个问题，这个国家也会走到默认线路。&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;这是小概率事件，出错影响的势必是小部分用户，又极难发现。&lt;br&gt;
啰唆了这么多，很简单的一件事，时刻牢记配上默认线路兜底。&lt;br&gt;
当添加了按国家，按地区+运营商分线路解析，记得按情况配置大洲线路，运营商线路，境外线路兜底。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;IP 库厂商在做IP  定位时，理想的也应该是准确度优先，而不是覆盖度优先。
什么是准确度优先呢? 即如果你吃不准一个IP是不是广东的，就不要瞎标，只标到中国就好了。我记得IPIP.NET 是这么做，很早之前跑过一个测试，当时看到对于教育网的IP，IPIP.NET标的都是准确度优先，不会瞎标。&lt;/p&gt;
&lt;p&gt;但是国内有一些IP库厂商，选择覆盖度优先，他一定要标到城市或者一级行政区，即使他吃不准后面是不是对的。标上再说，然后吹嘘自己覆盖度99.999%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设DNS 厂商用的是准确度优先的，那我们就更应该设置兜底策略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是覆盖度优先的的呢？只能说少用，能用尽量只加默认线路、大运营线路，业务上少依赖DNS 调度的准确性。&lt;/p&gt;
&lt;p&gt;🐴后🧨&lt;/p&gt;
&lt;p&gt;现在公司部分业务部门使用了大量分线路解析的情况，分国家、地区，将用户引导到不同节点上。去年提醒了业务部门和总监，添加和检查加洲线路、默认线路兜底被无视，今年就漏了个国家线路被客户投诉 🤦‍♂️。&lt;/p&gt;</content><category term="2023"></category><category term="dns"></category></entry><entry><title>轻量级办公室无感知跨境加速方案</title><link href="https://fangpsh.github.io/posts/2023/2023-04-23.html" rel="alternate"></link><published>2023-04-23T00:00:00+08:00</published><updated>2023-04-23T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-04-23:/posts/2023/2023-04-23.html</id><summary type="html">&lt;p&gt;之前逛V2EX 看到一个网友的帖子：“&lt;a href="https://www.v2ex.com/t/928907"&gt;请教公司内部如何实现无感知跨境加速&lt;/a&gt;”，把海外IP 全部走到代理网关，维护成本比较高。如 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前逛V2EX 看到一个网友的帖子：“&lt;a href="https://www.v2ex.com/t/928907"&gt;请教公司内部如何实现无感知跨境加速&lt;/a&gt;”，把海外IP 全部走到代理网关，维护成本比较高。如果只是简单的Web 加速，DNS 劫持+SNIProxy 是更轻量的方法。&lt;/p&gt;
&lt;p&gt;~~有&lt;a href="https://docs.fortinet.com/document/fortigate/6.2.14/cookbook/80739/dynamic-application-steering-with-lowest-cost-and-best-quality-strategies"&gt;Fortinet&lt;/a&gt;、&lt;a href="https://bbs.panabit.com/thread-12376-1-1.html"&gt;Panabit&lt;/a&gt;的土豪无须接着看 🤑~~&lt;/p&gt;
&lt;p&gt;这个方案的局限：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能加速http、https 流量；&lt;/li&gt;
&lt;li&gt;github.com（http2）似乎有异常，见下文解决方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按网友说的联通/电信的MPLS，1000元/M/(月?)，如果是我的话，就会搞几个机场账号，一个月成本百来块解决。  &lt;/p&gt;
&lt;p&gt;当然我牢记前辈们的血泪教训：在工作场合中，能用钱解决的，尽量用钱（乙方）解决，要不然就是给自己找事了🐕。  &lt;/p&gt;
&lt;p&gt;说回正事，画个草图：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;             ┌──────────┐   query:www.google.com ┌───────────┐
             │          ├────────────────────────►           │
             │  client  │                        │ local dns │
             │          ◄────────────────────────┤           │
             └───┬───▲──┘    A:192.168.11.11     └───────────┘
                 │   │
                 │   │
                 │   │
         http req│   │ http rsp
                 │   │                      ┼
                 │   │
                 │   │
             ┌───▼───┴──────────┐
             │                  │
             │    proxy         │
             │  192.168.11.11   │
             └───────────────┬──┘
                             │
                             │internal
                             │
       ┌─────────────────────┴────────────────────┐
       │                                          │
       │ ┌───────────┐         ┌────────────┐     │
       │ │ SNIPROXY  │  OUTPUT │            │     │
       │ │ http:80   ├────────►│   CLASH    │     │
       │ │ https:443 │ IPTABLES│   TPROXY   │     │
       │ └───────────┘         └────────────┘     │
       │                                          │
       │                                          │
       └──────────────────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;找一台机器装上clash/v2ray/sing-box 等，下面以clash为例。&lt;/p&gt;
&lt;p&gt;local dns 用adguard-home、bind、dnsmasq、pdns-recursor都可，把要加速的子域名劫持解析到代理机IP。&lt;/p&gt;
&lt;h2&gt;SNIProxy 配置&lt;/h2&gt;
&lt;p&gt;从&lt;a href="https://github.com/dlundquist/sniproxy"&gt;官方仓库&lt;/a&gt;拉代码编译安装，或者发行版仓库内找找。配置就一句话，没什么好说的，如果不想有人随意本地host 下域名就能走这个代理传透出去，就写下具体域名，语法官方手册。当然也可以在clash 那里控制。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;table http_hosts {
    .* *:80
}

table https_hosts {
    .* *:443
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Clash 配置&lt;/h2&gt;
&lt;p&gt;就一句话，其他和日常配置没差别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tproxy-port: 7891
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;若用非特权用户起，clash.service记得设置Capability。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_SYS_PTRACE CAP_DAC_READ_SEARCH
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_SYS_PTRACE CAP_DAC_READ_SEARCH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外在部署此类代理时，建议拒绝掉内网域名（内网地址），以免增加追踪审计复杂度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- GEOIP,LAN,REJECT
- DOMAIN-SUFFIX,oa.com,REJECT
- ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;主机配置&lt;/h2&gt;
&lt;p&gt;主要涉及策略路由和iptables，正常只需要设置OUTPUT chain 即可，但是为了解决下文github的问题，也配置下FORWARD。&lt;/p&gt;
&lt;p&gt;让特殊标记的包流向本机：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 记得配置开启启动生效
ip route flush table 100
ip route add local default dev lo table 100
ip rule add fwmark 1 table 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;iptables，抄网友的，记得做持久化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;iptables -F
iptables -X
iptables -t nat -F
iptables -t mangle -F
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT

iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

iptables -A INPUT -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -s 192.168.0.0/16 -p tcp  -j ACCEPT

# RETURN LOCAL AND LANS
iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN
iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN
iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN
iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN
iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN
iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN
iptables -t mangle -A clash -d 192.0.0.0/24 -j RETURN
iptables -t mangle -A clash -d 192.0.2.0/24 -j RETURN
iptables -t mangle -A clash -d 198.18.0.0/15 -j RETURN
iptables -t mangle -A clash -d 198.51.100.0/24 -j RETURN
iptables -t mangle -A clash -d 203.0.113.0/24 -j RETURN
iptables -t mangle -A clash -d 255.255.255.255/32 -j RETURN
iptables -t mangle -A clash -d 100.64.0.0/10 -j RETURN
iptables -t mangle -A clash -d 224.0.0.0/4 -j DROP
iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN
# FORWARD ALL
iptables -t mangle -A clash -p udp -j TPROXY --on-port 7891 --tproxy-mark 1
iptables -t mangle -A clash -p tcp -j TPROXY --on-port 7891 --tproxy-mark 1

#iptables -t mangle -A OUTPUT -j clash
iptables -t mangle -A PREROUTING -j clash


iptables -t mangle -N LOCAL_DIVERT
iptables -t mangle -A LOCAL_DIVERT -d 192.168.0.0/16 -j RETURN
iptables -t mangle -A LOCAL_DIVERT -p tcp -j MARK --set-mark 1
iptables -t mangle -A LOCAL_DIVERT -p udp -j MARK --set-mark 1

iptables -t mangle -A OUTPUT -m owner ! --gid-owner { 运行clash 程序的GID}  -j LOCAL_DIVERT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果尝试写：&lt;code&gt;iptables -t mangle -A OUTPUT -j clash&lt;/code&gt; 会出现错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;iptables v1.8.7 (nf_tables):  RULE_APPEND failed (Invalid argument): rule in chain OUTPUT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;网友解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 tproxy 只能工作在 PREROUTING 链，从本机发出去的数据包会直接通过 OUTPUT 链出去了，本机数据包没有机会走一下 PREROUTING 链。 作者：靛青K https://www.bilibili.com/read/cv14088928/ 出处：bilibili&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sysctl 开启ipv4包转发：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward
#建议配置/etc/sysctl.conf中，开机生效。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;github.com 的问题&lt;/h2&gt;
&lt;p&gt;如果把github.com 劫持到sniproxy，不久浏览器就会出现以下错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Fastly error: unknown domain: github.com. Please check that this domain has been added to a service.
Details: cache-hkg17926-HKG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;搜到的一些issue：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dlundquist/sniproxy/issues/178"&gt;http2 clients being proxied to wrong host. #178&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/snail007/goproxy/issues/422"&gt;HTTP代理访问Github会经常出现 Fastly error: unknown domain: github.com. #422
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dlundquist/sniproxy/issues/242#issuecomment-302831849"&gt;NIproxy doesn't support http2 or SPDY explicitly,&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来和http2 长连接有关，暂时没精力（能力）细究，看到有一个&lt;a href="https://github.com/dlundquist/sniproxy/pull/98"&gt;PR&lt;/a&gt;是能针对特定域名指定一些，但是没合。&lt;/p&gt;
&lt;p&gt;那就只能倒回去用网关的模式解决了。&lt;/p&gt;
&lt;p&gt;dig 了下github.com 的域名，集中在这2个段，添加策略路由，把下一条指到代理机。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;140.82.112.0/22
20.205.192.0/18
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;内网搭建一个uptime kuma 或者megaease/easeprobe，对github.com 进行curl 探测，发现异常再加新的IP。&lt;/p&gt;
&lt;h2&gt;sniproxy+v2ray+redirect&lt;/h2&gt;
&lt;p&gt;v2ray（dokodemo-door）+ redirect 也行，简单贴下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
    &amp;quot;log&amp;quot;: {
        &amp;quot;loglevel&amp;quot;: &amp;quot;warning&amp;quot;,
        &amp;quot;access&amp;quot;: &amp;quot;/var/log/v2ray/access.log&amp;quot;,
        &amp;quot;error&amp;quot;: &amp;quot;/var/log/v2ray/error.log&amp;quot;
    },
    &amp;quot;inbounds&amp;quot;: [
        {
            &amp;quot;tag&amp;quot;:&amp;quot;transparent&amp;quot;,
            &amp;quot;port&amp;quot;: 12345,
            &amp;quot;protocol&amp;quot;: &amp;quot;dokodemo-door&amp;quot;,
            &amp;quot;settings&amp;quot;: {
                &amp;quot;network&amp;quot;: &amp;quot;tcp,udp&amp;quot;,
                &amp;quot;followRedirect&amp;quot;: true
            },
            &amp;quot;sniffing&amp;quot;: {
                &amp;quot;enabled&amp;quot;: true,
                &amp;quot;destOverride&amp;quot;: [
                    &amp;quot;http&amp;quot;,
                    &amp;quot;tls&amp;quot;
                ]
            },
            &amp;quot;streamSettings&amp;quot;: {
                &amp;quot;sockopt&amp;quot;: {
                  &amp;quot;tproxy&amp;quot;: &amp;quot;redirect&amp;quot;
                }
            }
        }
    ],
    &amp;quot;outbounds&amp;quot;: [
        {
            &amp;quot;protocol&amp;quot;: &amp;quot;vmess&amp;quot;,
            &amp;quot;settings&amp;quot;: {
                ...
            },
            &amp;quot;streamSettings&amp;quot;: {
                &amp;quot;sockopt&amp;quot;: {
                    &amp;quot;mark&amp;quot;: 255
                }
            },
            &amp;quot;tag&amp;quot;: &amp;quot;proxy&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/bin/bash

iptables -F
iptables -t nat -F
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT


iptables -t nat -N V2RAY
iptables -t nat -A OUTPUT -p tcp -j V2RAY

iptables -t nat -A V2RAY -d 192.168.0.0/16 -j RETURN
iptables -t nat -A V2RAY -d 10.0.0.0/8 -j RETURN
iptables -t nat -A V2RAY -p tcp -j RETURN -m mark --mark 0xff
iptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports 12345

iptables -t nat -A PREROUTING -p tcp -j V2RAY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;容灾&lt;/h2&gt;
&lt;p&gt;这些网站本来就不存在，容什么灾？😂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.linuxvirtualserver.org/"&gt;LVS&lt;/a&gt; 传统做法&lt;ul&gt;
&lt;li&gt;或者土豪有F5之类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置多个代理机，local dns 那里返回多个A记录，Chrome 自己会重试；&lt;ul&gt;
&lt;li&gt;我选这个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://guide.v2fly.org/app/tproxy.html#%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%85%B3"&gt;透明代理(TPROXY)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bilibili.com/read/cv14088928/"&gt;使用 iptables 的 tproxy 完成本机访问家里内网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://moecm.com/something-about-v2ray-with-tproxy/"&gt;第一篇万字长文：围绕透明代理的又一次探究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.mmf.moe/post/tproxy-investigation/"&gt;TProxy 探秘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kernel.org/doc/Documentation/networking/tproxy.txt"&gt;tproxy.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2023"></category><category term="proxy"></category><category term="iptables"></category></entry><entry><title>逆向办公大楼门禁APK，成功生成通行二维码</title><link href="https://fangpsh.github.io/posts/2023/2023-04-20.html" rel="alternate"></link><published>2023-04-20T00:00:00+08:00</published><updated>2023-04-20T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-04-20:/posts/2023/2023-04-20.html</id><summary type="html">&lt;p&gt;脱壳逆向，不必硬碰硬。大多数业务，迭代更新只是更新业务，但是加密的逻辑并无变化。&lt;/p&gt;
&lt;p&gt;对于攻击方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不少业务不会在一开始 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;脱壳逆向，不必硬碰硬。大多数业务，迭代更新只是更新业务，但是加密的逻辑并无变化。&lt;/p&gt;
&lt;p&gt;对于攻击方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不少业务不会在一开始就加固：
可以直接找到历史包，最近一次未加固版本。
类似业务不会一开始套CDN，可以通过查询域名解析历史找到可能的源站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找加固后较旧的版本：
各类加固不断更新，逆向思路/工具也不断升级。如果持有的工具能应对老版本的加固，何不找老版本的软件包？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于业务方：&lt;br&gt;
除了要保持更新加固软件，还需要按版本不断更换关键业务的AES  KEY。&lt;/p&gt;
&lt;p&gt;下面是逆向过程。&lt;/p&gt;
&lt;h2&gt;找历史包&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;apkpure、apkimirror 之类&lt;/li&gt;
&lt;li&gt;官方软件下载链接：可猜测历史版本号的链接，或把URL 前半部分丢搜索引擎里面&lt;/li&gt;
&lt;li&gt;豌豆荚：国内软件，豌豆荚的历史包非常全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在豌豆荚找到该软件历史包，2分法下载apk改zip，解压查看assets和lib等内容判断是否进行加固和采用的加固厂商：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;6.5.0: 最后一个未加固的版本；&lt;/li&gt;
&lt;li&gt;7.0.0: 第一个使用360 加固的版本；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;脱壳&lt;/h2&gt;
&lt;p&gt;安装7.0 版本，生成二维码，可正常通行，表明7.0 版逻辑正常。&lt;/p&gt;
&lt;p&gt;先试一试用&lt;a href="https://github.com/CodingGay/BlackDex/"&gt;BlackDex&lt;/a&gt; 脱壳，一次性成功。&lt;/p&gt;
&lt;p&gt;注意：如果安装BlackDex 之后未看到APP，表明选择的版本错了，换另外一个版本，BlackDex32或者64。&lt;/p&gt;
&lt;p&gt;脱壳拿到的dex 文件，使用d2j-dex2jar 转为jar。&lt;/p&gt;
&lt;p&gt;apktool、dex2jar、jd-gui 的安装，各位师傅写的都非常多了，没啥好说的。&lt;/p&gt;
&lt;p&gt;注意：macOS 如果打开jd-gui 提示JAVA版本问题，Google 搜索“Java反编译利器JD-GUI(解决报错This program requires Java 1.8+)”，也可以找到很多师傅写的文章。&lt;/p&gt;
&lt;h2&gt;收集必要信息&lt;/h2&gt;
&lt;p&gt;开始逆向看代码之前，用proxyman 或者charles，走一遍完整的业务流程，抓取到所需的信息，同时也看一遍客户端和服务端交互的信息，会有个思路，特别是对一些关键参数名、接口名，方便我们后遍走读代码。&lt;/p&gt;
&lt;p&gt;proxyman 的使用，也有非常多师傅的文章，Google 即可。&lt;/p&gt;
&lt;p&gt;例如获取到的登录后的个人信息，留作备用，后续肯定会用到。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
  &amp;quot;code&amp;quot;: &amp;quot;000&amp;quot;,
  &amp;quot;describe&amp;quot;: &amp;quot;Operation succeed!&amp;quot;,
  &amp;quot;data&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;A5D00B33819E458B8XXXXXXXX&amp;quot;,
    &amp;quot;account&amp;quot;: &amp;quot;1091XXXX&amp;quot;,
    &amp;quot;nickName&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;userName&amp;quot;: &amp;quot;陈XX&amp;quot;,
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意这个ID：A5D00B33819E458B8XXXXXXXX，后文会出现。&lt;/p&gt;
&lt;h2&gt;逆向代码&lt;/h2&gt;
&lt;p&gt;dex 拖入jd-gui 之后，从哪里开始看呢？&lt;/p&gt;
&lt;p&gt;用apktool 直接逆向到apk 包虽然没有关键代码，但是会包含一些变量名，可以作为线索。
例如APP 上显示“扫码通行，点击刷新”，我们直接grep：&lt;/p&gt;
&lt;p&gt;&lt;img alt="grep" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143707.png"&gt;&lt;/p&gt;
&lt;p&gt;关键词 &lt;code&gt;passcode&lt;/code&gt;，另外这是个二维码，也可以从先找&lt;code&gt;qrcode&lt;/code&gt; 相关函数，然后看看那些地方调用了它，倒着看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="createQRCode" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143726.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="QrCodeFragment" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143814.png"&gt;&lt;/p&gt;
&lt;p&gt;看到关键行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;param1String = EncodeUtil.encodeKey(CacheUtils.getUserId(), QrCodeFragment.this.mPassCode, &amp;quot;A&amp;quot;, CacheUtils.getAppVersion());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="encodeKey" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143840.png"&gt;&lt;/p&gt;
&lt;p&gt;出现一个关键信息：qrCodeKey，
最后进行了AES 加密：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;return AESUtil.Encrypt(stringBuilder3.toString(), qrCodeKey, qrCodeKey);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先看一下AES 的加密模式和填充算法等，再回过来看这个str生成逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="AESUtil" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143904.png"&gt;&lt;/p&gt;
&lt;p&gt;ok，我们得到了，&lt;code&gt;AES/CBC/PKCS5Padding&lt;/code&gt;，也有密钥（qrCodeKey）了。&lt;/p&gt;
&lt;p&gt;打开安装的APP，连续生成2，3张通行二维码，解析出二维码表示的字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;l/YKQnk8F/JcCXI3k4uvf05a1hcpnZSmdgBV...ak9A/xPh7KsgPhUffKRjajLi/2u5IIOA==
l/YKQnk8F/JcCXI3k4uvf3Ekfg1dzyTiTp+D...AhSGF3bqW2OjWiaCZDU/IbFQ9di9af3wUew==
l/YKQnk8F/JcCXI3k4uvf1VsKs6lu...3AtHsxb9I16t2vXJ0qpK+7DmEgADVBdw==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;找一个&lt;a href="https://tool.lmeee.com/jiami/aes"&gt;AES 在线加解密&lt;/a&gt;的网站，试一试：&lt;/p&gt;
&lt;p&gt;&lt;img alt="aes-decrypt" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420143926.png"&gt;&lt;/p&gt;
&lt;p&gt;ok，搞定了sign_str，有了这个sign_str 能方便我们后续校对sign_str 生成逻辑和编写poc。&lt;/p&gt;
&lt;p&gt;同时在这一步，可以发现前半部分字符串和上文出现UserID 有类似的地方。接下来就是读懂前面encodeKey 函数的逻辑，以及传入mCode 的生成落。&lt;/p&gt;
&lt;p&gt;UserID+mPassCode+md5_16(mPassCode)+"B"+版本号。
UserID和mPassCode 不是直接拼凑，而是间隔交叉拼在一起。&lt;/p&gt;
&lt;p&gt;再看下mPassCode的生成逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mPassCode" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420144057.png"&gt;&lt;/p&gt;
&lt;p&gt;从代码来看，只是简单的递增。这个时候，再去生成几个实际的二维码，用AES在线解密出，拿到mPassCode 的md5_16，丢到cmd5.com 里面看看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="cmd5" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230420144121.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;e6e61673edb05342 -&amp;gt; 00000171
7a56b435986b1611 -&amp;gt;  00000172
651bac14cc8b1285 -&amp;gt;  00000173
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;确定只是简单递增，那么这个code 不是基于时间的OTP算法，猜测服务端会记录当前用到最大的code，以使之前的code 失效（后续实际验证也是如此）。&lt;/p&gt;
&lt;p&gt;到这里，基本就清晰了：
mPassCode 单调递增，UserID 按4个分隔，，mPassCode按2个分发，两者交叉拼在一起，再加上mPassCode 的MD5-16，加字符“B”，再加版本号。&lt;/p&gt;
&lt;p&gt;举例：
UserID 为：&lt;code&gt;A12345678910ABCEED6A474E79AA4FF6&lt;/code&gt;
当前mPassCode为：&lt;code&gt;00000123&lt;/code&gt;，md5_16值为&lt;code&gt;c9b62e572837d1b9&lt;/code&gt;
版本号为：&lt;code&gt;7.1.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;拼凑字符串为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;A123    4567  8910   ABCE  ED6A   474E79AA4FF6
     00     00     00    01     23             c9b62e572837d1b9  B7.1.2
结果为：
A12300456700891001ABCE23ED6A474E79AA4FF6c9b62e572837d1b9B7.1.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;PoC&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;import hashlib
import random
import string

from Crypto.Cipher import AES  
from base64 import b64decode, b64encode

BLOCK_SIZE = AES.block_size
pad = lambda s: s + (BLOCK_SIZE - len(s.encode()) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s.encode()) % BLOCK_SIZE)
unpad = lambda s: s[:-ord(s[len(s) - 1:])]


class AESCipher:
    def __init__(self, secretkey: str):
        self.key = secretkey
        self.iv = secretkey[0:16]  # 偏移量

    def encrypt(self, text):
        &amp;quot;&amp;quot;&amp;quot;
        加密 ：先补位，再AES加密，后base64编码
        :param text: 需加密的明文
        :return:
        &amp;quot;&amp;quot;&amp;quot;
        # text = pad(text) 包pycrypto的写法，加密函数可以接受str也可以接受bytess
        text = pad(text).encode()  # 包pycryptodome 的加密函数不接受str
        cipher = AES.new(key=self.key.encode(), mode=AES.MODE_CBC, IV=self.iv.encode())
        encrypted_text = cipher.encrypt(text)
        # 进行64位的编码,返回得到加密后的bytes，decode成字符串
        return b64encode(encrypted_text).decode(&amp;#39;utf-8&amp;#39;)

    def decrypt(self, encrypted_text):
        &amp;quot;&amp;quot;&amp;quot;
        解密 ：偏移量为key[0:16]；先base64解，再AES解密，后取消补位
        :param encrypted_text : 已经加密的密文
        :return:
        &amp;quot;&amp;quot;&amp;quot;
        encrypted_text = b64decode(encrypted_text)
        cipher = AES.new(key=self.key.encode(), mode=AES.MODE_CBC, IV=self.iv.encode())
        decrypted_text = cipher.decrypt(encrypted_text)
        return unpad(decrypted_text).decode(&amp;#39;utf-8&amp;#39;)


code=&amp;#39;00000123&amp;#39;
c1=code[0:2]
c2=code[2:4]
c3=code[4:6]
c4=code[6:8]

md5_16=hashlib.md5(code.encode(&amp;#39;utf-8&amp;#39;)).hexdigest()[8:-8]

uid=&amp;#39;A12345678910ABCEED6A474E79AA4FF6&amp;#39;

u1=uid[0:4]
u2=uid[4:8]
u3=uid[8:12]
u4=uid[12:16]
u5=uid[16:]
sign_str=f&amp;quot;{u1}{c1}{u2}{c2}{u3}{c3}{u4}{c4}{u5}{md5_16}B7.1.2&amp;quot;
print(sign_str)

encrypted_text = AESCipher(&amp;quot;略&amp;quot;).encrypt(sign_str)
print(encrypted_text)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再将encrypted_text 生成二维码即可。&lt;/p&gt;
&lt;p&gt;如果我是业务方，可以怎么改进？&lt;/p&gt;
&lt;p&gt;我的思路是：&lt;/p&gt;
&lt;p&gt;每个新版，采用最新的加密固件，同时更换AES Key。
生成的二维码包含当前版本的明文信息和加密串，在服务端先按明文反查对于AES Key，再解密验证加密串。
这样既能保持向后兼容，必要时候强制用户升级，逐步吊销不安全版本的AES Key。&lt;/p&gt;
&lt;p&gt;感谢各位师傅观看，献丑了，预祝大家五一快乐。&lt;/p&gt;</content><category term="2023"></category><category term="hack"></category></entry><entry><title>阿里云共享流量包单价对比</title><link href="https://fangpsh.github.io/posts/2023/2023-03-17.html" rel="alternate"></link><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-03-17:/posts/2023/2023-03-17.html</id><summary type="html">&lt;p&gt;阿里云的共享流量包定价，不完全符合流量包越大单价越低，有效期越长单价越低的思维定式，阿里云产品经理是故意的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;阿里云的共享流量包定价，不完全符合流量包越大单价越低，有效期越长单价越低的思维定式，阿里云产品经理是故意的还是不小心的呢？&lt;/p&gt;
&lt;p&gt;之前几年负责云资源采购时，算过阿里云&lt;code&gt;300TB-6月&lt;/code&gt;的包单价是最低的，所以都选择采购这个规格。今天再算一遍，发现又有一些新的变化。&lt;/p&gt;
&lt;p&gt;声明：以下数据2023-03-17采集，个人帐号登录&lt;a href="https://www.aliyun.com/price/product?#/flowbag/detail/flowbag"&gt;云商控制台&lt;/a&gt;获取。厂商可能随时调整，请根据自身情况再次核对。&lt;/p&gt;
&lt;p&gt;先列结论： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;12月以上的大包没必要购买，单价无优势；&lt;/li&gt;
&lt;li&gt;同一类型、有效期下的流量包，并不是规格越大越便宜：&lt;ol&gt;
&lt;li&gt;亚太全时，128G-1月异常，比50G-1月还高&lt;/li&gt;
&lt;li&gt;亚太全时，10T-1月异常，比5T-1月还高&lt;/li&gt;
&lt;li&gt;亚太全时，600G-6月异常，比300GB-6月还高&lt;/li&gt;
&lt;li&gt;亚太闲时，10T-1月异常，比5T-1月还高&lt;/li&gt;
&lt;li&gt;亚太闲时，60T-6月异常，比30T-6月还高&lt;/li&gt;
&lt;li&gt;欧美全时，10T-1月异常，比5T-1月还高&lt;/li&gt;
&lt;li&gt;欧美全时，60T-6月异常，比30T-6月还高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;以亚太全时为例，按流量情况，建议在三类包里面选：&lt;ol&gt;
&lt;li&gt;50G-1月&lt;/li&gt;
&lt;li&gt;5T-1月&lt;/li&gt;
&lt;li&gt;30T-6月（单价和5T-6月一样，但是有效期更长，适合不均衡的情况）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;亚太闲时和欧美全时，可以参考以下表格自行抉择。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设亚太全时 月平均流量消耗是300T，那最佳做法是写一个脚本，监控余量，自动补30T-6月包，而不是直接搞一个300T-6月包。&lt;/p&gt;
&lt;p&gt;&lt;img alt="亚太全时" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230317142005.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="亚太闲时" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230317142040.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="欧美全时" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230317142125.png"&gt;&lt;/p&gt;
&lt;p&gt;顺便看了下，腾讯上海全时的流量包情况，比较符合思维定式，时间越长，包越大，单价越低：
&lt;img alt="腾讯上海全时" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230317142156.png"&gt;&lt;/p&gt;
&lt;p&gt;如果需要获取这个表格，请点击 &lt;a href="https://docs.google.com/spreadsheets/d/1U4cff_GZILOqMl9ApcdmLjzQYIr_wWoY/edit?usp=sharing&amp;amp;ouid=118315519688232626252&amp;amp;rtpof=true&amp;amp;sd=true"&gt;阿里云流量&lt;/a&gt;。&lt;/p&gt;</content><category term="2023"></category><category term="cloud"></category><category term="aliyun"></category></entry><entry><title>MTR UDP模式固定丢包率的问题</title><link href="https://fangpsh.github.io/posts/2023/2023-03-15.html" rel="alternate"></link><published>2023-03-15T00:00:00+08:00</published><updated>2023-03-15T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-03-15:/posts/2023/2023-03-15.html</id><summary type="html">&lt;p&gt;不愿意透露姓名的同事反馈，在任何一台A 服务器上，mtr 另外一台B 服务器，UDP 模式，发包频率只要大于 &lt;code&gt;1s/次&lt;/code&gt;，会出现固定丢 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;不愿意透露姓名的同事反馈，在任何一台A 服务器上，mtr 另外一台B 服务器，UDP 模式，发包频率只要大于 &lt;code&gt;1s/次&lt;/code&gt;，会出现固定丢包，并且丢包总是在最后一跳：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mtr -u {ip} -nz --interval 0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是使用mtr 默认的模式，icmp不会丢包。同事反馈不同厂商的机器，行为一致，那应该就系统内做的限制，所以怀疑我在机器上针对UDP 做了限速。&lt;/p&gt;
&lt;p&gt;交叉测试了下，
1. 选择2台同机房的A，B ，A mtr B（公网IP），和反馈现象一致
2. A mtr B （内网IP），和反馈现象一致&lt;/p&gt;
&lt;p&gt;当interval 是0.5 的时候，丢包率恰好是50%，在B 上抓包：
&lt;img alt="udp-loss" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230315173621.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;B 的回ICMP: Destination Unreachable 是间隔性的。
按照icmp ratelist 搜到了，找到了&lt;a href="https://man7.org/linux/man-pages/man7/icmp.7.html"&gt;答案&lt;/a&gt;。
系统默认的&lt;code&gt;icmp_ratelimit&lt;/code&gt;是&lt;code&gt;1000&lt;/code&gt;，恰好是1s，那为何mtr ICMP 模式不会丢呢？
因为还有一个参数&lt;code&gt;icmp_ratemask&lt;/code&gt; ，默认为以下几类包被限制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;       icmp_ratemask (integer; default: see below; since Linux 2.4.10)
              Mask made of ICMP types for which rates are being limited.

              Significant bits: IHGFEDCBA9876543210
              Default mask:     0000001100000011000 (0x1818)

              Bit definitions (see the Linux kernel source file
              include/linux/icmp.h):

                   0 Echo Reply
                   3 Destination Unreachable *
                   4 Source Quench *
                   5 Redirect
                   8 Echo Request
                   B Time Exceeded *
                   C Parameter Problem *
                   D Timestamp Request
                   E Timestamp Reply
                   F Info Request
                   G Info Reply
                   H Address Mask Request
                   I Address Mask Reply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IMCP 模式下回的包是&lt;code&gt;G Info Reply&lt;/code&gt;，未在&lt;code&gt;icmp_ratemask&lt;/code&gt; 标记范围内。
&lt;img alt="icmp-reply" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230315174413.png"&gt;&lt;/p&gt;
&lt;p&gt;感谢细心的同事，又学习到了。&lt;/p&gt;</content><category term="2023"></category><category term="linux"></category><category term="network"></category></entry><entry><title>避免innerHTML 自动渲染特殊字符</title><link href="https://fangpsh.github.io/posts/2023/2023-03-06.html" rel="alternate"></link><published>2023-03-06T00:00:00+08:00</published><updated>2023-03-06T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2023-03-06:/posts/2023/2023-03-06.html</id><summary type="html">&lt;p&gt;我在内网部署了一个 &lt;a href="http://json.parser.online.fr/beta"&gt;json.parser.online.fr&lt;/a&gt; 的破解版：&lt;a href="https://github.com/hklcf/Json-Parser-Online-Nulled"&gt;Json-Parser-Online-Nulled&lt;/a&gt;，今天有同事反馈，格式化后的文本发生了变化，发现是将&lt;code&gt;&amp;amp;region&lt;/code&gt; 变成了&lt;code&gt;®ion&lt;/code&gt;
复现一下 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我在内网部署了一个 &lt;a href="http://json.parser.online.fr/beta"&gt;json.parser.online.fr&lt;/a&gt; 的破解版：&lt;a href="https://github.com/hklcf/Json-Parser-Online-Nulled"&gt;Json-Parser-Online-Nulled&lt;/a&gt;，今天有同事反馈，格式化后的文本发生了变化，发现是将&lt;code&gt;&amp;amp;region&lt;/code&gt; 变成了&lt;code&gt;®ion&lt;/code&gt;
复现一下：
&lt;img alt="reg" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306184830.png"&gt;&lt;/p&gt;
&lt;p&gt;看起来是一个特殊字符：&lt;a href="https://toolstud.io/web/charmap.php?encoded=reg"&gt;HTML character: ® = &amp;reg;&lt;/a&gt;，那是哪里引入的呢？&lt;/p&gt;
&lt;p&gt;走读了一遍代码，外加&lt;code&gt;console.log&lt;/code&gt; 大法，&lt;code&gt;parse()&lt;/code&gt;函数最后返回的地方：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;parseObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;snatch&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="nx"&gt;valid&lt;/span&gt;&lt;span class="o"&gt;:!&lt;/span&gt;&lt;span class="nx"&gt;hasError&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打印&lt;code&gt;result&lt;/code&gt;一切正常，
接着是&lt;a href="https://github.com/hklcf/Json-Parser-Online-Nulled/blob/master/script.js#L493,L494"&gt;$result.innerHTML&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;setTimeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/&amp;lt;/g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/&amp;gt;/g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;$result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;innerHTML&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nx"&gt;changeFavicon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;valid&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题就出在这里，innerHTML 赋值的时候，自动对&lt;a href="https://toolstud.io/web/charmap.php?filter=*"&gt;特殊字符&lt;/a&gt;进行了渲染：&lt;/p&gt;
&lt;p&gt;这个机制似乎无法绕过，我的解决办法是对在最后&lt;code&gt;&amp;amp;&lt;/code&gt; 字符进行提前替换，将&lt;code&gt;&amp;amp;&lt;/code&gt;字符替换为&lt;code&gt;&amp;amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;html: parseObject(snatch).toString().replaceAll(&amp;#39;&amp;amp;&amp;#39;,&amp;#39;&amp;amp;amp;&amp;#39;), valid: !hasError
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果如下
&lt;img alt="reg01" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306190041.png"&gt;&lt;/p&gt;
&lt;p&gt;另外发现如果输入&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt; 也会被转换为&lt;code&gt;&amp;amp;lt;&lt;/code&gt; 和&lt;code&gt;&amp;amp;gt;&lt;/code&gt;，是由于作者的&lt;a href="https://github.com/hklcf/Json-Parser-Online-Nulled/blob/master/script.js#L491,L492"&gt;转换&lt;/a&gt;，不过我不太理解这个目的，注释掉这2行也一切正常。&lt;/p&gt;
&lt;p&gt;提个&lt;a href="https://github.com/hklcf/Json-Parser-Online-Nulled/pull/1"&gt;PR&lt;/a&gt;，下班回家。&lt;/p&gt;</content><category term="2023"></category><category term="html"></category></entry><entry><title>顺着网线找供应商</title><link href="https://fangpsh.github.io/posts/2022/2022-10-14.html" rel="alternate"></link><published>2022-10-14T00:00:00+08:00</published><updated>2022-10-14T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2022-10-14:/posts/2022/2022-10-14.html</id><summary type="html">&lt;p&gt;公司在逐渐开展国际业务，某些国家覆盖需要补点，涉及到找供应商。
国际供应商在交流和商务方式和和国内供应商都有 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;公司在逐渐开展国际业务，某些国家覆盖需要补点，涉及到找供应商。
国际供应商在交流和商务方式和和国内供应商都有比较大的区别，比较理想的是能找到国内去国外做出海的供应商。&lt;/p&gt;
&lt;p&gt;我常用的一种方式是通过网线找，咱们拿埃及举例。&lt;/p&gt;
&lt;h2&gt;第一步：目标国家的主流运营商&lt;/h2&gt;
&lt;p&gt;埃及：TE（埃及电信），沃达丰vodafone等。&lt;br&gt;
主流运营商，你可以Google，或者看国家的AS ，然后按网段排序，IP 约多一般市场份额越大：
http://whois.ipip.net/countries/EG&lt;/p&gt;
&lt;p&gt;&lt;img alt="埃及IP地址" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230305202935.png"&gt;&lt;/p&gt;
&lt;p&gt;埃及电信No.1
 &lt;/p&gt;
&lt;h2&gt;第二步：以某个主流运营商找到关键AS 号&lt;/h2&gt;
&lt;p&gt;例如埃及电信是AS8452 ，点进去：&lt;br&gt;
http://whois.ipip.net/AS8452&lt;br&gt;
我一般更喜欢看cidr-report&lt;br&gt;
https://www.cidr-report.org/cgi-bin/as-report?as=AS8452&amp;amp;view=2.0&lt;br&gt;
&lt;/p&gt;
&lt;h2&gt;第三步：按AS 查询 Downstream，一般以.HK .US 结尾的国别&lt;/h2&gt;
&lt;p&gt;downstream 就是得买transit，在一个国家正常开展业务，一般也绕不开topN 的运营商。
不过一些情况是发现不了的，例如只能用运营商的IP ，像中国三大运营商的情况，那就通过其他路子了。&lt;/p&gt;
&lt;p&gt;国内出海的公司，一般都有个美国、香港、新加坡之类的主体，所以重点看downstream 里面是这类国别的AS。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="downstream " src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230305203530.png"&gt;
以TE AS8452 为例，眼熟的老朋友有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AS138915 KAOPU-HK Kaopu Cloud HK Limited, HK：靠谱云&lt;/li&gt;
&lt;li&gt;AS54994 QUANTILNETWORKS, US：网宿海外&lt;/li&gt;
&lt;li&gt;AS21859  ZEN-ECN, US：层峰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四步：顺藤摸瓜&lt;/h2&gt;
&lt;p&gt;按照第三步的AS 线索，浏览下AS 的注册domain，Google 名称，企查查，找找联系方式、官网等，一般都能找到了。&lt;/p&gt;</content><category term="2022"></category><category term="BGP"></category><category term="IDC"></category></entry><entry><title>Python requests 高级用法：timeouts、retries、hooks</title><link href="https://fangpsh.github.io/posts/2020/2020-10-04.html" rel="alternate"></link><published>2020-10-04T00:00:00+08:00</published><updated>2020-10-04T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-10-04:/posts/2020/2020-10-04.html</id><summary type="html">&lt;p&gt;&lt;img alt="python-requests" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185617.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href="https://findwork.dev/blog/advanced-usage-python-requests-timeouts-retries-hooks/"&gt;findwork.dev&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Dani Hodovic&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我使用的所有编程语言中，Python 的HTTP 库 &lt;a href="https://requests.readthedocs.io/en/master/"&gt;requests&lt;/a&gt; 是我最喜欢的HTTP 工具。它简单，直观，在Python 社区中无处不在 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="python-requests" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185617.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href="https://findwork.dev/blog/advanced-usage-python-requests-timeouts-retries-hooks/"&gt;findwork.dev&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Dani Hodovic&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我使用的所有编程语言中，Python 的HTTP 库 &lt;a href="https://requests.readthedocs.io/en/master/"&gt;requests&lt;/a&gt; 是我最喜欢的HTTP 工具。它简单，直观，在Python 社区中无处不在。大多数与HTTP 交互的程序要么使用它，要么使用标准库的urllib3。&lt;/p&gt;
&lt;p&gt;由于简单的API ，requests 非常容易上手，不仅如此，在高级使用场景，它也有非常强的可扩展性。如果你在编写一个频繁调用API的客户端，或者一个网络爬虫，你需要能容忍网络异常，需要有效的debug 跟踪信息，还需要一些语法糖。&lt;/p&gt;
&lt;p&gt;以下是我在编写大量调用JSON API 的网络爬虫或者程序时，从requests 中发掘出的一些有用的功能特性汇总。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#请求钩子"&gt;请求钩子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#设置baseurl"&gt;设置BaseUrl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#设置默认超时"&gt;设置默认超时&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#失败时重试"&gt;失败时重试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#结合超时和重试"&gt;结合超时和重试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#调试-http-请求"&gt;调试 HTTP 请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#打印http-header"&gt;打印HTTP Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#打印所有信息"&gt;打印所有信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#测试和伪装请求"&gt;测试和伪装请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#模仿浏览器行为"&gt;模仿浏览器行为&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;请求钩子&lt;/h2&gt;
&lt;p&gt;在使用第三方API接口的时候，你通常都想要验证返回响应是否有效。Requests 提供了一个快捷的方法 &lt;code&gt;raise_for_status()&lt;/code&gt;，它确保响应的HTTP 状态码不是4xx 或者5xx，即请求未触发客户端或服务器错误。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://api.github.com/user/repos?page=1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 确保此处无错误&lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raise_for_status&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次请求都需要调用&lt;code&gt;raise_for_status()&lt;/code&gt;，太繁复了。幸运的是，requests 库提供了一个类似“钩子”的接口，你可以在请求的各个阶段添加回调。&lt;/p&gt;
&lt;p&gt;我们可以用钩子来确保每个响应对象都调用&lt;code&gt;raise_for_status()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 创建一个自定义的requests 对象，修改全局模块抛出异常&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;assert_status_hook&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raise_for_status&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;response&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;assert_status_hook&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.github.com/user/repos?page=1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;HTTPError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;401&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt; &lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Unauthorized&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;repos&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;设置BaseUrl&lt;/h2&gt;
&lt;p&gt;假设你仅使用api.org 上的API。每次http 调用，你都需要重复写协议和域名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://api.org/list/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://api.org/list/3/item&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以通过使用&lt;a href="https://toolbelt.readthedocs.io/en/latest/sessions.html#baseurlsession"&gt;BaseUrlSession&lt;/a&gt; 少打一些字。它允许你为HTTP 客户端指定基础的url，这样每次请求时候只需要指定资源路径。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;requests_toolbelt&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sessions&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BaseUrlSession&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.org&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/list&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/list/item&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意默认安装的requests 不包含&lt;a href="https://github.com/requests/toolbelt"&gt;requests toolbelt&lt;/a&gt;，你需要单独安装它。&lt;/p&gt;
&lt;h2&gt;设置默认超时&lt;/h2&gt;
&lt;p&gt;requests 文档&lt;a href="https://requests.readthedocs.io/en/master/user/quickstart/#timeouts"&gt;建议&lt;/a&gt; 你在所有生产环境的代码中都设置超时。如果忘记设置超时，异常的外部服务会导致你的应用hang 住，尤其大多数的Python 代码是同步的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://github.com/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是这样做非常重复，容易遗漏。未来某一天当你发现是由于某人忘记设置超时导致生产环境的程序停止时，你会大发雷霆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="giphy" src="https://media.giphy.com/media/6IZzimIQN8guI/giphy.gif"&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;a href="https://requests.readthedocs.io/en/master/user/advanced/#transport-adapters"&gt;Transport Adapters&lt;/a&gt; 为每个HTTP 请求设置默认超时时间。
它可以确保即使开发人员忘记在他的调用中设置 timeout=1 参数，也设置了一个合理的超时时间，并且每次调用都可以覆盖它。&lt;/p&gt;
&lt;p&gt;下文是一个配置了默认超时的自定义 Transport Adapter  例子，灵感来自&lt;a href="https://github.com/kennethreitz/requests/issues/3070#issuecomment-205070203"&gt;这条Github 评论&lt;/a&gt;。在构建http 客户端和send() 方法时，我们重写了构造函数，提供了一个默认的超时时间，以确保当未传递timeout 参数时 会使用默认的超时时。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;requests.adapters&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;HTTPAdapter&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_TIMEOUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;# seconds&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TimeoutHTTPAdapter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HTTPAdapter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEFAULT_TIMEOUT&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;timeout&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;timeout&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;timeout&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;timeout&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;timeout&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以这样使用它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 挂载到 http、https &lt;/span&gt;
&lt;span class="n"&gt;adapter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TimeoutHTTPAdapter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;2.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adapter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adapter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 使用默认超时： 2.5s &lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.twilio.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 为特定请求覆盖超时时间&lt;/span&gt;
&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.twilio.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;失败时重试&lt;/h2&gt;
&lt;p&gt;我们常常会遇到网络连接中断，拥塞，或者服务器故障。如果想编写一个强大的软件，我们必须考虑到失败的情况，并指定重试策略。&lt;/p&gt;
&lt;p&gt;给HTTP 客户端添加重试策略非常简单。我们可以创建一个 HTTPAdapter，传入我们的重试策略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;requests.packages.urllib3.util.retry&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Retry&lt;/span&gt;

&lt;span class="n"&gt;retry_strategy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Retry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;status_forcelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;502&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;504&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="n"&gt;method_whitelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;HEAD&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;OPTIONS&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;adapter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HTTPAdapter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_retries&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;retry_strategy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adapter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;adapter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://en.wikipedia.org/w/api.php&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认的Retry 类已经有合理的默认值，不过它是&lt;strong&gt;深度&lt;/strong&gt;可定制化的，以下是一些我常用到的参数。&lt;/p&gt;
&lt;p&gt;以下参数也包含requests 库的默认参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重试总次数。如果失败的请求数或重定向次数达到该值，客户端会抛出&lt;code&gt;urllib3.exceptions.MaxRetryError&lt;/code&gt; 异常。我会根据我调用的API 来调整这个参数，不过我通常将其设置为小于10，一般3次重试就足够了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;status_forcelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;413&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重试的HTTP 响应状态码。你可能想对&lt;strong&gt;常见的服务器错误（500，502，503，504）&lt;/strong&gt; 都进行重试，因为服务器或者反向代理不遵循HTTP 规范。429 超出频率限制时总重试的原因是，urllib 库对于失败请求会有渐进性的退避策略，所以无碍。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;method_whitelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;HEAD&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;PUT&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;DELETE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;OPTIONS&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;TRACE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重试的HTTP 方法。默认情况下，该参数包含除了POST 之外的所有HTTP 方法，因为POST 会导致新增。&lt;strong&gt;修改该参数增加POST&lt;/strong&gt; 是因为大多数我接触过的API 都都不会返回错误码，并且不会在相同的调用中执行新增。如果不是这样，你最好给他们提个bug。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;backoff_factor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个参数很有趣。它允许你修改进程在失败请求之间的休眠时间。算法是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{backoff factor} * (2 ** ({number of total retries} - 1))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举个例子，如果退避因子设置为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1秒，休眠时间依次为&lt;code&gt;0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2秒 - &lt;code&gt;1, 2, 4, 8, 16, 32, 64, 128, 256, 512&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;10秒 - &lt;code&gt;5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值呈指数增长，是&lt;a href="https://stackoverflow.com/a/28732630/2966951"&gt;重试策略&lt;/a&gt; 的合理实现。&lt;/p&gt;
&lt;p&gt;这个参数默认是0，意味着不会设置指数退避，重试会立即执行。&lt;strong&gt;确保它被设置为1，以免击垮你的服务器！&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重试模块的完整文档在&lt;a href="https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html#module-urllib3.util.retry"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;结合超时和重试&lt;/h3&gt;
&lt;p&gt;因为HTTPAdapter 是一样的，我们可以把重试和超时像下面这样结合起来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;retries&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Retry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backoff_factor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;status_forcelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;502&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;504&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TimeoutHTTPAdapter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_retries&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;retries&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;调试 HTTP 请求&lt;/h2&gt;
&lt;p&gt;有时请求失败，但是你无法找出原因。记录请求和响应或许能帮助你查明失败原因。有两种方法可以做到，使用内置的debug 日志配置，或者使用请求钩子。&lt;/p&gt;
&lt;h3&gt;打印HTTP Header&lt;/h3&gt;
&lt;p&gt;将日志调试等级调整到大于0，就会记录响应的HTTP Header。这是最简单的选项，但是它没法让你看到HTTP 请求和响应的包体。如果你调用的API会返回超大的包体或不合适打印出来，例如包含二进制内容，这个选项很有用。&lt;/p&gt;
&lt;p&gt;任何大于0 的日志等级，都会开启调制日志。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;http&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HTTPConnection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debuglevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://www.google.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 输出&lt;/span&gt;
&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="sa"&gt;b&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;GET / HTTP/1.1&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;Host: www.google.com&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;User-Agent: python-requests/2.22.0&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;Accept-Encoding: gzip, deflate&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;Accept: */*&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;Connection: keep-alive&lt;/span&gt;&lt;span class="se"&gt;\r\n\r\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;reply&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;HTTP/1.1 200 OK&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Fri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt; &lt;span class="n"&gt;Feb&lt;/span&gt; &lt;span class="mi"&gt;2020&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt; &lt;span class="n"&gt;GMT&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Expires&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cache&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Control&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;private&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;打印所有信息&lt;/h3&gt;
&lt;p&gt;如果你想打印整个HTTP 生命周期，包括请求和响应内容的文本内容，你可以使用请求钩子和requests_toolbelt 中的dump 工具。&lt;/p&gt;
&lt;p&gt;当我调用不会返回很多的响应内容的REST API 时，我更喜欢用这个选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;requests_toolbelt.utils&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;dump&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;logging_hook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;response&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;logging_hook&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.openaq.org/v1/cities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;country&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;BA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="c1"&gt;# 参考&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;country&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;BA&lt;/span&gt; &lt;span class="n"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;openaq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="n"&gt;OK&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Content&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Transfer&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;chunked&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Connection&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;keep&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;alive&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="s2"&gt;&amp;quot;meta&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;openaq-api&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;license&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;CC BY 4.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;website&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://docs.openaq.org/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;page&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;limit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;found&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
   &lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="s2"&gt;&amp;quot;results&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="s2"&gt;&amp;quot;country&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;BA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Goražde&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="s2"&gt;&amp;quot;city&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Goražde&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="s2"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;70797&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="s2"&gt;&amp;quot;locations&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考 https://toolbelt.readthedocs.io/en/latest/dumputils.html&lt;/p&gt;
&lt;h2&gt;测试和伪装请求&lt;/h2&gt;
&lt;p&gt;使用第三方API 会给开发人员带来一个痛点，它们很难进行单元测试。&lt;a href="https://sentry.io/"&gt;Sentry&lt;/a&gt; 的工程师通过写了一个库来伪装请求，减轻了开发过程中的痛苦。&lt;/p&gt;
&lt;p&gt;无需发送请求到服务器，&lt;a href="https://github.com/getsentry/responses"&gt;getsentry/responses&lt;/a&gt; 截获了HTTP 请求并返回一个你的测试过程中添加的预先定义好的内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;unittest&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;responses&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TestAPI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;activate&lt;/span&gt;  &lt;span class="c1"&gt;# intercept HTTP calls within this method&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_simple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;response_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="s2"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ch_1GH8so2eZvKYlo2CSMeAfRqt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="s2"&gt;&amp;quot;object&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;charge&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="s2"&gt;&amp;quot;customer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;cu_1GGwoc2eZvKYlo2CL2m31GRn&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;object&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;customer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;# mock the Stripe API&lt;/span&gt;
        &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;https://api.stripe.com/v1/charges&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://api.stripe.com/v1/charges&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果发出一个和伪装的响应不一致的请求，则会引发 ConnectionError。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TestAPI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;activate&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_simple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;https://api.stripe.com/v1/charges&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://invalid-request.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;requests.exceptions.ConnectionError: Connection refused by Responses - the call doesn&amp;#39;t match any registered mock.

Request:
- GET https://invalid-request.com/

Available matches:
- GET https://api.stripe.com/v1/charges
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;模仿浏览器行为&lt;/h2&gt;
&lt;p&gt;如果你编写过足够多的web 爬虫代码，你会注意到某些网站会针对你是通过浏览器还是代码访问会返回不同的HTML。有时这是一种防爬虫的策略，但是通常是由于服务器会居于User-Agent 嗅探，找出最适合访问设备的内容（例如桌面端或移动端）。&lt;/p&gt;
&lt;p&gt;如果你想要服务器返回浏览器一样的内容，你可以重写请求的 User-Agent 头信息为FIrefox或Chrome。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2020"></category><category term="Python"></category><category term="Requests"></category></entry><entry><title>一个双向MTR仅单向丢包的问题</title><link href="https://fangpsh.github.io/posts/2020/2020-09-09.html" rel="alternate"></link><published>2020-09-09T00:00:00+08:00</published><updated>2020-09-09T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-09-09:/posts/2020/2020-09-09.html</id><summary type="html">&lt;p&gt;现象:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 机器ping B 机器丢包，触发A MTR B，最后一跳丢包；&lt;/li&gt;
&lt;li&gt;B 机器ping A 机器丢包，触发B MTR A，最后一跳不丢包；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="mtr-a2b" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185207.png"&gt;
&lt;img alt="mtr-b2a" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185227.png"&gt;&lt;/p&gt;
&lt;p&gt;按照之前的理解 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;现象:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 机器ping B 机器丢包，触发A MTR B，最后一跳丢包；&lt;/li&gt;
&lt;li&gt;B 机器ping A 机器丢包，触发B MTR A，最后一跳不丢包；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="mtr-a2b" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185207.png"&gt;
&lt;img alt="mtr-b2a" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185227.png"&gt;&lt;/p&gt;
&lt;p&gt;按照之前的理解，A MTR B 和 B MTR ，最后一跳应该是镜像对等的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;A  MTR B :

A                   B
|---------&amp;gt;---------|  &amp;lt; icmp request  package1
|--------&amp;lt;----------|  &amp;lt; icmp reply    package2

B MTR A:

B                   A
|---------&amp;gt;---------|  &amp;lt; icmp request  package3
|--------&amp;lt;----------|  &amp;lt; icmp reply    package4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果A MTR B出现丢包，那么可能出现在 去程，也可能是回程，所以才需要B MTR A 来判断断点。
可以认为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;package1 走的路径 == package4 走的路径
package2 走的路径 == package3 走的路径
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A MTR B 丢包，意味着package1 或者package2 出现了丢，那么B MTR A 也应该会影响才对。
既然事实不符合这个假设，那么说明这个假设是错的。那么是什么影响到了？&lt;/p&gt;
&lt;p&gt;猜想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交换机会针对五元组负载均衡导致？，可是ICMP不带端口，MTR 默认是ICMP；  &lt;/li&gt;
&lt;li&gt;交换机对icmp request 和reply 包的策略不同？B Ping A 也是丢包，排除这个猜想；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然B ping A 和 B MTR A 表现不一样，那么Ping 和MTR 有什么差异？&lt;/p&gt;
&lt;p&gt;包大小？mtr 看了下icmp 包大小，ping 指定了下，B ping A，还是丢包。&lt;br&gt;
TTL？ping 默认ttl = 64，mtr 的ttl 是从1 开始逐渐探测，拿到对端地址回包为止，在这个场景里，B MTR A ，最后一跳ttl = 15。&lt;/p&gt;
&lt;p&gt;ping -t 指定ttl = 15，果然不丢，ttl &amp;gt; 15，即丢包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;package1 的ttl = 去程最大，package4 的ttl = 64；
package2 的ttl = 64，package3 的ttl = 回程最大。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;怀疑是ICMP 包的TTL  影响到了QoS 策略。用关键词搜索了下，发现了好像可以基于TTL 设置：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst9400/software/release/16-8/configuration_guide/qos/b_168_qos_9400_cg/b_168_qos_9400_cg_chapter_01.html"&gt;cisco:QoS&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Time-to-Live Classification
You can classify packets based on the ACL map. You can set Time-to_live (TTL) as a criterion in the ACL list and perform a TTL check on the incoming packet. The access control entry is used to check the IPv4 TTL to match the value on the incoming packet. The classified packet is either marked or policed based on the policy-map action. Queueing cannot be configured on this classification.

The following is an example of TTL classification:

policy-map TTL_MATCH
    class IPV4_TTL
        police rate 6000000000
        set dscp af23

ip access-list extended IPV4_TTL
    permit ip any any ttl eq 100
    permit tcp any any ttl ne 150
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不了解路由器和交换机的配置，咨询下两个云/IDC 厂商的网工，没有得到很多信息，姑且这么怀疑吧。&lt;/p&gt;</content><category term="2020"></category><category term="MTR"></category><category term="Network"></category></entry><entry><title>Azure 上Salt Minion异常断线的问题</title><link href="https://fangpsh.github.io/posts/2020/2020-04-25.html" rel="alternate"></link><published>2020-04-25T00:00:00+08:00</published><updated>2020-04-25T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-04-25:/posts/2020/2020-04-25.html</id><summary type="html">&lt;p&gt;在几台Azure 的机器上发现salt minion一直在切换节点，以为是到阿里云香港的抖动问题，加了一个阿里云硅谷节点，把Azure 美国境内的节点都分配过 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在几台Azure 的机器上发现salt minion一直在切换节点，以为是到阿里云香港的抖动问题，加了一个阿里云硅谷节点，把Azure 美国境内的节点都分配过去，还是异常。&lt;/p&gt;
&lt;p&gt;这个时候监控也发现几次Azure 到阿里云境内Ping 异常丢失，以为是网络问题，抓MTR报障处理中。。。&lt;/p&gt;
&lt;p&gt;网络恢复之后，还是常常切换master，切就切吧，问题是切换之后，似乎进入了一种异常状态，只能重启salt minion 才能解决。&lt;/p&gt;
&lt;p&gt;好像翻到一个issue 说是master list 的问题，切换成单master，观察一晚上，还是异常。&lt;/p&gt;
&lt;p&gt;又怀疑是zeromq 的问题，换到tcp transport，还是有问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Feb 27 14:51:07 ... salt-minion[18665]: AttributeError: &amp;#39;NoneType&amp;#39; object has no attribute &amp;#39;add_callback&amp;#39;
Feb 27 15:07:35 ... salt-minion[18665]: [WARNING ] Master ip address changed from 47.8 to 18.1
Feb 27 15:07:35 ... salt-minion[18665]: [WARNING ] Master ip address changed from 47.8 to 18.1
Feb 27 15:07:36 ... salt-minion[18665]: [WARNING ] Master ip address changed from 47.8 to 18.1
Feb 27 15:07:36 ... salt-minion[18665]: [ERROR   ] Exception in callback &amp;lt;function SaltMessageClient.connect.&amp;lt;locals&amp;gt;.handle_future at 0x7f6283dac1e0&amp;gt; for &amp;lt;salt.ext.
Feb 27 15:07:36 ... salt-minion[18665]: Traceback (most recent call last):
Feb 27 15:07:36 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/ext/tornado/concurrent.py&amp;quot;, line 326, in _set_done
Feb 27 15:07:36 ... salt-minion[18665]: cb(self)
Feb 27 15:07:36 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/transport/tcp.py&amp;quot;, line 1043, in handle_future
Feb 27 15:07:36 ... salt-minion[18665]: self.io_loop.add_callback(self.connect_callback, response)
Feb 27 15:07:36 ... salt-minion[18665]: AttributeError: &amp;#39;NoneType&amp;#39; object has no attribute &amp;#39;add_callback&amp;#39;
Feb 27 15:23:55 ... salt-minion[18665]: [WARNING ] Master ip address changed from 18.1 to 47.8
Feb 27 15:23:56 ... salt-minion[18665]: [ERROR   ] Exception in callback &amp;lt;function SaltMessageClient.connect.&amp;lt;locals&amp;gt;.handle_future at 0x7f6284bf1b70&amp;gt; for &amp;lt;salt.ext.
Feb 27 15:23:56 ... salt-minion[18665]: Traceback (most recent call last):
Feb 27 15:23:56 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/ext/tornado/concurrent.py&amp;quot;, line 326, in _set_done
Feb 27 15:23:56 ... salt-minion[18665]: cb(self)
Feb 27 15:23:56 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/transport/tcp.py&amp;quot;, line 1043, in handle_future
Feb 27 15:23:56 ... salt-minion[18665]: self.io_loop.add_callback(self.connect_callback, response)
Feb 27 15:23:56 ... salt-minion[18665]: AttributeError: &amp;#39;NoneType&amp;#39; object has no attribute &amp;#39;add_callback&amp;#39;
Feb 27 15:40:15 ... salt-minion[18665]: [WARNING ] Master ip address changed from ... to ...
Feb 27 15:40:16 ... salt-minion[18665]: [WARNING ] Master ip address changed from ... to ...
Feb 27 15:40:16 ... salt-minion[18665]: [ERROR   ] Exception in callback &amp;lt;function SaltMessageClient.connect.&amp;lt;locals&amp;gt;.handle_future at 0x7f6280447e18&amp;gt; for &amp;lt;salt.ext.
Feb 27 15:40:16 ... salt-minion[18665]: Traceback (most recent call last):
Feb 27 15:40:16 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/ext/tornado/concurrent.py&amp;quot;, line 326, in _set_done
Feb 27 15:40:16 ... salt-minion[18665]: cb(self)
Feb 27 15:40:16 ... salt-minion[18665]: File &amp;quot;/usr/lib/python3.6/site-packages/salt/transport/tcp.py&amp;quot;, line 1043, in handle_future
Feb 27 15:40:16 ... salt-minion[18665]: self.io_loop.add_callback(self.connect_callback, response)
Feb 27 15:40:16 ... salt-minion[18665]: AttributeError: &amp;#39;NoneType&amp;#39; object has no attribute &amp;#39;add_callback&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;又翻了几个issue：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt/issues/26888"&gt;salt-minion error on unstable tcp connection #26888&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt/issues/20240"&gt;Minion did not return #20240&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt/issues/6231"&gt;Minion losing connection and not returning without a restart of service #6231&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/saltstack/salt/issues/40794"&gt;Master (EC2) connectivity issues with Minion (Azure) with tcp transport #40794&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/43343245/online-saltstack-minions-on-azure-losses-connection-with-master-on-digitalocean"&gt;Online Saltstack Minions on Azure losses connection with Master on DigitalOcean&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If Azure isn't respecting keepalive, that could definitely be causing your problems. As of right now, the minions will not attempt to reconnect outside of the ZMQ keepalive routines. (We recognize that this is a problem -- the biggest blocker is the fact that ZMQ is not very good at reporting that connections are dead. We've been trying to find a good way around this problem)
basepi commented on Dec 6, 2013&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来Azure 有个默认的网络链接超时时间，&lt;a href="https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-outbound-connections#idletimeout"&gt;Use keepalives to reset the outbound idle timeout&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Outbound connections have a 4-minute idle timeout. This timeout is adjustable via Outbound rules. You can also use transport (for example, TCP keepalives) or application-layer keepalives to refresh an idle flow and reset this idle timeout if necessary.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Azure 默认是240s，小于Salt minion 默认的300s，相当于长连接会被Azure 从中间断开。
猜测salt 对这种closed 情况代码上可能处理的不够好。&lt;/p&gt;
&lt;p&gt;指定下&lt;a href="https://docs.saltstack.com/en/latest/ref/configuration/minion.html#tcp-keepalive-idle"&gt;tcp_keepalive_idle&lt;/a&gt;，默认是300s：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tcp_keepalive_idle: 60
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重启，终于解决了。&lt;/p&gt;</content><category term="2020"></category><category term="azure"></category><category term="saltstack"></category></entry><entry><title>搭建IPv6 Only 测试环境</title><link href="https://fangpsh.github.io/posts/2020/2020-03-12.html" rel="alternate"></link><published>2020-03-12T00:00:00+08:00</published><updated>2020-03-12T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-03-12:/posts/2020/2020-03-12.html</id><summary type="html">&lt;p&gt;&lt;img alt="baidu.com" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228184346.png"&gt;&lt;/p&gt;
&lt;p&gt;macOS 可以开启&lt;a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html"&gt;DNS64/NAT64&lt;/a&gt;，
简单快捷。但是mac mini 信号不太好，开发同学抱怨常常连不上，而且有多个组的同学要测试，再买几台mac mini 好 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="baidu.com" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228184346.png"&gt;&lt;/p&gt;
&lt;p&gt;macOS 可以开启&lt;a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html"&gt;DNS64/NAT64&lt;/a&gt;，
简单快捷。但是mac mini 信号不太好，开发同学抱怨常常连不上，而且有多个组的同学要测试，再买几台mac mini 好像有点费钱。&lt;/p&gt;
&lt;p&gt;所以接了个活，用&lt;a href="https://openwrt.org/"&gt;OpenWrt&lt;/a&gt; 搭建几个IPv6 Only 测试环境。&lt;/p&gt;
&lt;h2&gt;选路由&lt;/h2&gt;
&lt;p&gt;看了下，Newifi  D2、斐讯K2P 、极路由以及小米部分版本均可以刷OpenWrt。先是在京东下单了一个小米R3G，到手后发现是R3G V2，其实是4A，坑爹，刷机还得接TTL。
转去咸鱼，挑了一个二手的&lt;a href="https://openwrt.org/toh/xiaomi/mir3g"&gt;小米R3G&lt;/a&gt;（V1，带USB）和 &lt;a href="https://openwrt.org/toh/hwdata/d-team/d-team_newifi_d2"&gt;Newifi D2&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;刷机&lt;/h2&gt;
&lt;p&gt;小米R3G到手需要先刷&lt;a href="https://breed.hackpascal.net/"&gt;Breed&lt;/a&gt;，再刷OpenWrt，基本按照网上的教程没啥问题，参考&lt;a href="https://blog.csdn.net/dvd_sun/article/details/89737513"&gt;小米路由器3G刷入OpenWrt&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;刷完breed遇到一个问题，无法启动，电脑线连WAN口，只能进入breed，搜来搜去，看到两个帖子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.right.com.cn/forum/thread-255438-2-1.html"&gt;我已经解决小米路由器3G刷breed后无法刷固件的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bilibili.com/read/cv796610/"&gt;小米路由器3G（R3G）刷入BREED无法刷固件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在breed环境设置界面删除normal_firmware_md5，保存重启，果然好了。&lt;/p&gt;
&lt;p&gt;Newifi D2 到手，卖家已经刷好breed 和定制版本的OpenWrt，不太喜欢，从openwrt.org 下载了一个升级包，覆盖即可。&lt;/p&gt;
&lt;h2&gt;DNS64/NAT64&lt;/h2&gt;
&lt;p&gt;基本是参考这篇帖子：&lt;a href="https://blog.csdn.net/dengxinfa/article/details/104218997"&gt;openwrt使用tayga/totd实现NAT64/DNS64&lt;/a&gt;，NAT64 安装tayga 照着配置没啥问题。除了tayga，还有一个新的项目&lt;a href="https://www.jool.mx/en/openwrt.html"&gt;Jool&lt;/a&gt;也可以实现NAT64。&lt;/p&gt;
&lt;p&gt;换源&lt;code&gt;/etc/opkg/distfeeds.conf&lt;/code&gt;，中科大源最近好像有点问题，换成清华：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;src/gz openwrt_core http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/targets/ramips/mt7621/packages
src/gz openwrt_kmods http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/targets/ramips/mt7621/kmods/4.14.171-1-2e88863ccdd594fb8e842df3c25842ee
src/gz openwrt_base http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/packages/mipsel_24kc/base
src/gz openwrt_luci http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/packages/mipsel_24kc/luci
src/gz openwrt_packages http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/packages/mipsel_24kc/packages
src/gz openwrt_routing http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/packages/mipsel_24kc/routing
src/gz openwrt_telephony http://mirrors.tuna.tsinghua.edu.cn/openwrt/releases/19.07.2/packages/mipsel_24kc/telephony
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考前面教程设置完成后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tayga-nat64 Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet6 addr: fe80::xxx:xxx:xxx:1fea/64 Scope:Link
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:36077 errors:0 dropped:0 overruns:0 frame:0
          TX packets:36793 errors:0 dropped:3 overruns:0 carrier:0
          collisions:0 txqueuelen:500
          RX bytes:15494186 (14.7 MiB)  TX bytes:15679087 (14.9 MiB)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;root@OpenWrt:~# ping6  qq.com
PING qq.com (fd2e:f49a:9639:1111::7b97:8912): 56 data bytes
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=0 ttl=50 time=37.958 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=1 ttl=50 time=37.962 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=2 ttl=50 time=38.267 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=3 ttl=50 time=37.821 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=4 ttl=50 time=37.260 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=5 ttl=50 time=37.530 ms
64 bytes from fd2e:f49a:9639:1111::7b97:8912: seq=6 ttl=50 time=37.828 ms
^C
--- qq.com ping statistics ---
7 packets transmitted, 7 packets received, 0% packet loss
round-trip min/avg/max = 37.260/37.803/38.267 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DNS64 需要totd，不过这软件在仓库中没了，需要交叉编译，有点麻烦。后来看到&lt;a href="https://microcai.org/2019/02/13/nat64.html"&gt;unbound&lt;/a&gt;，仓库里面也没有。那只能用&lt;a href="https://openwrt.org/docs/guide-user/services/dns/bind"&gt;bind&lt;/a&gt; 了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;opkg install bind-server
/etc/init.d/named enable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改配置&lt;code&gt;/etc/bind/named.conf&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;options {
        directory &amp;quot;/tmp&amp;quot;;
        listen-on port 53  { any; };
        listen-on-v6 port 53 { any; };

        recursion yes;
        allow-recursion { any; };
        allow-query { any; };
        allow-query-cache { any; };


        forwarders {
                202.96.134.133;
                223.5.5.5;
                114.114.114.114;
        };

        auth-nxdomain no;
        dns64 fd2e:f49a:9639:1111::/96 {}; #参考tayga 中配额的前缀
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;openwrt 本身跑着一个dnsmasq，用作DNS 和DHCP 等服务，本来想通过&lt;a href="https://openwrt.org/docs/guide-user/base-system/dhcp"&gt;server=&lt;/a&gt; 配置，把请求转给bind，bind设置一个非53端口，
不过尝试了下好像有点问题，那就直接关掉dnsmasq 的dns 服务好了(设置port为0)：
&lt;code&gt;/etc/config/dhcp&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;config dnsmasq
        option port &amp;#39;0&amp;#39;
        option domainneeded &amp;#39;1&amp;#39;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重启网络和named后，dig(&lt;code&gt;opkg install bind-tools&lt;/code&gt;)测试一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;root@OpenWrt:~# dig qq.com AAAA +short
fd2e:f49a:9639:1111::b703:e223
fd2e:f49a:9639:1111::3d81:72f
fd2e:f49a:9639:1111::7b97:8912
root@OpenWrt:~#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完美。&lt;/p&gt;
&lt;p&gt;再关闭下Lan口的DHCP 即可，可以在网页上点点点，或者修改下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
config dhcp &amp;#39;lan&amp;#39;
        option interface &amp;#39;lan&amp;#39;
        option dhcpv6 &amp;#39;server&amp;#39;
        option ra &amp;#39;server&amp;#39;
        option ra_management &amp;#39;1&amp;#39;
        option ignore &amp;#39;1&amp;#39;
        option ra_default &amp;#39;1&amp;#39;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置项解释，可参考&lt;a href="https://www.douban.com/note/618429634/"&gt;DHCPv6 over PPPoE on OpenWrt / LEDE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后，感谢各位网友的教程:) 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2023年-06-27 更新：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果ULA 是内网段（fd,fc ）又关闭了dhcpv4，安卓设备会无法连接，将ULA替换为公网段即可解决。  &lt;/li&gt;
&lt;li&gt;现在，使用Jool 是最佳选择：https://openwrt.org/docs/guide-user/network/ipv6/nat64&lt;/li&gt;
&lt;/ol&gt;</content><category term="2020"></category><category term="OpenWrt"></category><category term="IPv6"></category><category term="DNS64"></category><category term="NAT64"></category></entry><entry><title>关于OpenSSH AuthorizedKeysCommand 的几个小问题</title><link href="https://fangpsh.github.io/posts/2020/2020-03-03.html" rel="alternate"></link><published>2020-03-03T00:00:00+08:00</published><updated>2020-03-03T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-03-03:/posts/2020/2020-03-03.html</id><summary type="html">&lt;p&gt;分享几个使用AuthorizedKeysCommand 遇到的问题。&lt;/p&gt;
&lt;h1&gt;关闭SELinux&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;... error: AuthorizedKeysCommand ...  returned status 126
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果没有关闭，可能会遇到奇怪的问题，手动调用脚本能成功，实际sshd 日志 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;分享几个使用AuthorizedKeysCommand 遇到的问题。&lt;/p&gt;
&lt;h1&gt;关闭SELinux&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;... error: AuthorizedKeysCommand ...  returned status 126
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果没有关闭，可能会遇到奇怪的问题，手动调用脚本能成功，实际sshd 日志报error status 126。
如果安装了&lt;a href="https://docs.pagure.org/setroubleshoot/SETroubleShootOverview.html"&gt;setroubleshoot&lt;/a&gt;，可以看到详细的信息。&lt;/p&gt;
&lt;h1&gt;公钥列表似乎有大小限制？&lt;/h1&gt;
&lt;p&gt;应该是四五年前了，在之前公司一开始脚本里面通过&lt;code&gt;curl&lt;/code&gt; 拿到结果直接输出到标准输出。有一天某些同学反应登录不上某台机器，登录其他机器正常。
开始了漫长的排查过程，后来搜索到一封邮件&lt;a href="https://groups.google.com/forum/#!topic/mailing.unix.openssh-dev/0kYCFOyla3w"&gt;AuthorizedKeysCommand size issue?&lt;/a&gt;，上异常机器执行了下脚本，输出的公钥列表确实很长。
改下脚本，下把curl 拿到的公钥列表先存到临时文件中(mktemp)，再cat，果然好了。。。&lt;/p&gt;
&lt;h1&gt;status 141&lt;/h1&gt;
&lt;p&gt;写shell 脚本，开头我一般都会加&lt;code&gt;set -e&lt;/code&gt;，这个脚本也不例外。发现一个诧异的问题，在某云商某可用区，某些同学登录机器会间歇性失败。
日志显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...error: AuthorizedKeysCommand ... failed, status 141
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;141 的意思是：&lt;code&gt;141 is SIGPIPE (128 indicating signal + SIGPIPE)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;搜到一个相关的链接:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://lists.pld-linux.org/mailman/pipermail/pld-cvs-commit/Week-of-Mon-20131028/380095.html"&gt;packages/openssh  ignore SIGPIPE from ldap-helper. ssh server does not read whole input if matching key is found&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"ignore SIGPIPE from ldap-helper. ssh server does not read whole input if matching key is found"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;客户端和服务端都开启debug 模式，发现OpenSSH 在匹配AuthorizedKeysCommand 返回的公钥列表时，只要一读到匹配的公钥，就不会继续读了，应该是这个时候发送了一个信号，导致脚本退出状态异常。
注释掉&lt;code&gt;set -e&lt;/code&gt;就正常了。&lt;/p&gt;
&lt;p&gt;至于为什么就这个区域的机器部分机器有问题，能力和精力都不足，搞不清楚了:(&lt;/p&gt;</content><category term="2020"></category><category term="OpenSSH"></category></entry><entry><title>监控角度</title><link href="https://fangpsh.github.io/posts/2020/2020-02-22.html" rel="alternate"></link><published>2020-02-22T00:00:00+08:00</published><updated>2020-02-22T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2020-02-22:/posts/2020/2020-02-22.html</id><summary type="html">&lt;p&gt;监控哪些指标，一般是研发拍脑袋决定，要么是指标太多抓不住重点，给监控系统和运维人员带来很大压力。
要么是遗漏关 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;监控哪些指标，一般是研发拍脑袋决定，要么是指标太多抓不住重点，给监控系统和运维人员带来很大压力。
要么是遗漏关键指标，不能提前感知异常，或在故障出现时提供线索。&lt;/p&gt;
&lt;p&gt;面试时偶尔会问的一道题，候选人对某服务进行监控的话要考虑哪些指标。希望听到的回答，不仅全面，而且有体系，但是答案通常都杂乱无章、想一个是一个。&lt;/p&gt;
&lt;p&gt;分享下个人的总结。&lt;/p&gt;
&lt;h2&gt;对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;系统监控&lt;/li&gt;
&lt;li&gt;Linux 系统状态，包括软件、硬件，例如CPU、内存、Raid卡、温度等&lt;/li&gt;
&lt;li&gt;进程监控&lt;/li&gt;
&lt;li&gt;进程状态，例如进程状态，进程Crash事件、JVM FULL GC次数和耗时，JVM 各类堆栈大小等。&lt;/li&gt;
&lt;li&gt;这里的进程，不一定绝对是进程，而是进程脱离具体业务的指标，例如nginx 丢弃连接数，框架例如tomcat会暴露出与业务无关的指标。&lt;/li&gt;
&lt;li&gt;业务监控&lt;/li&gt;
&lt;li&gt;和具体业务相关&lt;/li&gt;
&lt;li&gt;例如 各类http 请求占比、耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统监控，一般系统运维会做好。不过在云上，这块细节变少，至少没有那么多硬件要监控。
业务监控的角度一般不会漏，但是进程监控角度常常被忽略，或者也是因为两者界限不是很强。
是“进程”还是“业务”，具体情况具体分析，例如一个基础服务，那么它的一些基础指标就是业务，例如Redis集群。&lt;/p&gt;
&lt;h2&gt;黄金指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;延迟（请求处理时间、响应时间）&lt;ul&gt;
&lt;li&gt;服务器处理某个请求所需要的时间&lt;/li&gt;
&lt;li&gt;剔除非正常请求（限流、错误请求）以免误导，既然要剔除，那就也需要监控&lt;/li&gt;
&lt;li&gt;例如 http 请求时间99值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流量（请求qps、带宽速率、io速率、iops）&lt;/li&gt;
&lt;li&gt;针对系统负载锁所进行度量的指标&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;li&gt;单位时间内的失败量。&lt;/li&gt;
&lt;li&gt;不仅包含协议层面的，例如http 500，也包含业务层面的，例如登录失败。&lt;/li&gt;
&lt;li&gt;饱和度&lt;/li&gt;
&lt;li&gt;针对系统内~~最为~~受限资源的度量指标&lt;/li&gt;
&lt;li&gt;可以是系统层面的，例如磁盘容量、带宽容量，也可以是业务层面的，例如并发拉流数，并发在线人数。&lt;/li&gt;
&lt;li&gt;书里面针对饱和度有“最为”2个字，但是我认为“最为”是比较难以衡量的，对于一个负载的系统来说，受限的资源方方面面，不同场景下触发的上限可能不同。这里的指标，我认为其实只是一种角度，我们要做的只是需要针对饱和度进行设置监控指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;延迟这个指标非常有用，除了发现异常，还可用于预报异常（饱含度），，当延迟变高，往往以为接近性能拐点，饱含度异常。
延迟指标还可用于性能监控，例如更新版本之后，延迟（http 响应时间99值）的变化。
所以，不要忘记针对延迟设计监控。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href="https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/"&gt;《Google SRE 第六章》&lt;/a&gt;#The Four Golden Signals&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;某Nginx 静态文件服务，按以上角度，设置的部分指标。&lt;/p&gt;
&lt;h4&gt;对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统监控&lt;/li&gt;
&lt;li&gt;CPU 利用率、磁盘占有率、带宽、全连接队列、半连接队列等&lt;/li&gt;
&lt;li&gt;进程监控&lt;/li&gt;
&lt;li&gt;Nginx status模块暴露的指标：丢弃连接数、并发连接数&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Active connections: 291
server accepts handled requests
16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;nginx error.log &lt;/li&gt;
&lt;li&gt;业务监控&lt;/li&gt;
&lt;li&gt;访问日志分析，状态码、响应时间等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;黄金指标&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;延迟&lt;/li&gt;
&lt;li&gt;2xx 请求响应时间99值&lt;/li&gt;
&lt;li&gt;流量&lt;/li&gt;
&lt;li&gt;当前活跃连接数，http 请求qps&lt;/li&gt;
&lt;li&gt;当前机器带宽&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;li&gt;5xx 请求qps，该服务下一般不会出现&lt;/li&gt;
&lt;li&gt;404 请求qps，可能意味着文件同步失败&lt;/li&gt;
&lt;li&gt;nginx 拒绝连接数&lt;/li&gt;
&lt;li&gt;周期检测error.log 新日志&lt;/li&gt;
&lt;li&gt;饱和度&lt;/li&gt;
&lt;li&gt;磁盘容量，静态文件较多&lt;/li&gt;
&lt;li&gt;当前活跃连接数，距离nginx 设置的最大连接数&lt;/li&gt;
&lt;/ul&gt;</content><category term="2020"></category><category term="monitor"></category></entry><entry><title>第二届中国SD-WAN 广告峰会参会感想</title><link href="https://fangpsh.github.io/posts/2019/2019-11-16.html" rel="alternate"></link><published>2019-11-16T00:00:00+08:00</published><updated>2019-11-16T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-11-16:/posts/2019/2019-11-16.html</id><summary type="html">&lt;p&gt;&lt;img alt="sd-wan-define" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162425.png"&gt;&lt;/p&gt;
&lt;p&gt;从&lt;a href="https://www.sdnlab.com/"&gt;SDNLAB&lt;/a&gt; 知道&lt;a href="https://www.bagevent.com/event/5443171/p/314542"&gt;第二届 2019 中国SD-WAN峰会&lt;/a&gt;，报名了会前的培训。&lt;/p&gt;
&lt;p&gt;因为从事运维工作，一直和网络打交道，对BGP、骨干网、PoP、PE、SDN、SD-WAN等名称知道一些，但是终究因为 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="sd-wan-define" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162425.png"&gt;&lt;/p&gt;
&lt;p&gt;从&lt;a href="https://www.sdnlab.com/"&gt;SDNLAB&lt;/a&gt; 知道&lt;a href="https://www.bagevent.com/event/5443171/p/314542"&gt;第二届 2019 中国SD-WAN峰会&lt;/a&gt;，报名了会前的培训。&lt;/p&gt;
&lt;p&gt;因为从事运维工作，一直和网络打交道，对BGP、骨干网、PoP、PE、SDN、SD-WAN等名称知道一些，但是终究因为没有实操过，不太了解。
底层网络应该属于通信，和计算机隔着一道门，借这次大会看看另外一个行业的人都在玩什么。&lt;/p&gt;
&lt;p&gt;分享下培训幻灯片：&lt;a href="https://drive.google.com/file/d/1SjBeD5gkb6rfpFwAFK-7nTxWzKM7F2Uh/view?usp=share_link"&gt;2019 SD WAN技术与应用培训课件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;来自未来网络创新研究院的张晨讲的确实不错，实实在在的干货，他的分享内容对我来说有深有浅，浅是因为熟悉，总的来说，听完能知道SD-WAN 的概念、现状、缺点、优势、应用场景等。
其他两位，可忽略，纯粹的来打广告的。主办方太不要脸，1200元/天的培训，还插半天的广告。&lt;/p&gt;
&lt;p&gt;SD-WAN 是一个容器，塞进了太多的东西。网络虚拟化，还是最后一个公里IPSec，有点新瓶旧酒的意思？。当然也不是没新的东西，只是在我一个外人看来，似乎没那么惊艳，也可能我理解不到。&lt;/p&gt;
&lt;p&gt;非常期待的最后一公里解决方案，看起来也只不过是IPSec+白盒的玩法，如果是这样，为什么我们软件工程师不自己做呢？反而要在中间加一个“overlay”的运营商，把网络根基建在这群中小型的初创公司上。&lt;/p&gt;
&lt;p&gt;非常认可SD-WAN 中大量的“软件化”、“虚拟化”，也非常认可讲师说的未来将“以云为中心”进行组网。&lt;/p&gt;
&lt;p&gt;第二天的会场，有卖设备，有卖软件的，也有卖服务的，“甚至”有卖流量的。对于某些公司来说，网络可用性是根基，讲师也提到，上SD-WAN要非常谨慎，因为上车容易下车难，需评估的东西方方面面，涉及太多。
然而现场的中国本土公司，规模似乎都不大（成立时间&amp;lt;=5年，员工&amp;lt;500人）。国外的那几个巨头，现场只有Versa 和Aryaka，售后服务服务不太好的样子。。。&lt;/p&gt;
&lt;p&gt;最近两年做会议解决方案的厂商越来越多，在线会议需要解决实时性和可用性，如果一家这样的互联网公司是建立在外部的SD-WAN方案上，那么未来可能被掣肘，因为它对你来说是“underlay”。&lt;/p&gt;
&lt;p&gt;当然，SD-WAN里面不仅仅只是组网和通信选路的事，还有大量底层的工作，而通信/网络这个行业是有比较高的壁垒，这可能是这些SD-WAN公司的大佬大都是来自这2个行业的原因，这些行业经验也是它们的价值之一。&lt;/p&gt;
&lt;p&gt;我想要的其实是一个更强的&lt;a href="https://github.com/slackhq/nebula"&gt;slack/nebula&lt;/a&gt;、&lt;a href="https://www.tinc-vpn.org/"&gt;tinc&lt;/a&gt;、&lt;a href="https://github.com/zerotier"&gt;ZeroTier&lt;/a&gt;，
除了组网，同时还能智能选路、线路容灾等高级功能，选路起码得如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transport" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162504.png"&gt;&lt;/p&gt;
&lt;p&gt;总结感受：广告真多，隔行如隔山，雾霾还是很厉害 😂&lt;/p&gt;</content><category term="2019"></category><category term="SD-WAN"></category></entry><entry><title>第一台NAS</title><link href="https://fangpsh.github.io/posts/2019/di-yi-tai-nas.html" rel="alternate"></link><published>2019-09-22T00:00:00+08:00</published><updated>2019-09-22T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-09-22:/posts/2019/di-yi-tai-nas.html</id><summary type="html">&lt;p&gt;&lt;img alt="qnap" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162325.jpg"&gt;&lt;/p&gt;
&lt;p&gt;两年前在腾讯的时候，内部福利领取了一年的微云会员，就将女友旧电脑的一百多G的资源全部上传备份，然后处理掉了旧电脑。
虽然当时知道 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="qnap" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162325.jpg"&gt;&lt;/p&gt;
&lt;p&gt;两年前在腾讯的时候，内部福利领取了一年的微云会员，就将女友旧电脑的一百多G的资源全部上传备份，然后处理掉了旧电脑。
虽然当时知道日后会离职会员会过期，不过看了产品协议记得是会员过期存储空间不回收，只是无法再上传罢了，类似Dropbox。&lt;/p&gt;
&lt;p&gt;月初却收到了如下&lt;a href="https://www.weiyun.com/2019-announcement.html"&gt;通知&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自2019年10月24日零时起，微云将上线超额存储管理规则。已用容量超出可用额度的用户，需要在180天内升级存储空间或对容量超额部分进行清理。若超期未作处理，帐号将被冻结，冻结期间微云保留清理超额空间的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，没法“白嫖”了，也长个记性，国内这些云存储的厂商，大多数不靠谱，还是买台NAS吧，也长草很久了。&lt;/p&gt;
&lt;h2&gt;自己组还是买成品？&lt;/h2&gt;
&lt;p&gt;买万由或者蜗牛星际，或者自己买机箱、配件组装，刷FreeNAS 或黑群晖，如果是五年前我估计还是会自己折腾，现在直接考虑买成品了，少了折腾的热情，数据重要，选专业的方案吧。&lt;/p&gt;
&lt;h2&gt;群晖还是威联通？&lt;/h2&gt;
&lt;p&gt;&lt;img alt="qnap-web" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162404.jpg"&gt;&lt;/p&gt;
&lt;p&gt;公司在用威联通，登录后台体验过，UI感觉是有点挫。在群晖官网体验了群晖的控制台，看起来确实高大上一些。可是相同配置，群晖价格是威联通的两倍左右，
两家充分竞争，在存储的功能上差别不会太大。威联通带有HDMI 输出，可以充当HTPC 的角色，这个功能我非常需要，不考虑了，选威联通，以后第二台再买群晖玩。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="QNAP-HybridDesk" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162425.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;TS-453Bmini 还是 TS-551？&lt;/h2&gt;
&lt;p&gt;威联通的型号，对于普通玩家，TS-453Bmini 是性价比最高的选择，在官方旗舰店，这款的销量也甩其他型号几条街。
不过我感觉TS-453Bmini 有点丑，所以一直在找相近的型号，看到了TS-551。
官方可以快捷&lt;a href="https://www.qnap.com/zh-cn/product/compare?products=ts-453bmini,ts-551&amp;amp;ref=product_overview"&gt;对比&lt;/a&gt;，最显著的差别是CPU：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel® Celeron® J3455 四核心 1.5 GHz 处理器 (可高达 2.3 GHz)&lt;/li&gt;
&lt;li&gt;Intel® Celeron® J3355 双核心 2.0 GHz 处理器 (可高达 2.5 GHz)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外TS-551的售价比TS-453Bmini 大概低400元。板载CPU没法更换，因为我有HTPC 的功能需求，并且这台NAS 预计使用3年+，551 的5盘位有点鸡肋，选择了453Bmini。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TS-453Bmini 参考价格：1999&lt;/li&gt;
&lt;li&gt;TS-551 参考价格：1599&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高于这个价格，都不算好价，淘宝购买JD E卡，外加Plus 优惠券，可以做到1900，如果遇上双11 之类活动应该能更低。&lt;/p&gt;
&lt;p&gt;不过购买之后一段时间，出了新闻：&lt;a href="https://news.mydrivers.com/1/645/645646.htm"&gt;Intel低功耗奔腾/赛扬“变砖”：紧急退市、升级&lt;/a&gt;，QNAP和群晖都有五年售后质保，我认为够用了，
真出事了，再找售后。&lt;/p&gt;
&lt;h2&gt;酷狼还是红盘？&lt;/h2&gt;
&lt;p&gt;买好了NAS，接下来就是买盘了。淘宝上买NAS 的商家标配都是希捷酷狼4T盘，逛了一圈，发现还是这款合适，西数的NAS专用红盘口碑非常糟糕，还不如酷鹰。
单盘4T 是比较合适的规格。&lt;/p&gt;
&lt;h2&gt;内存16G 还是10G？&lt;/h2&gt;
&lt;p&gt;453Bmini 出厂2G*2，双通道。实际最大支持8G*2，不过感觉日常10G 应该够用了，所以买了一条8G，2G+8G，应该是比较高性价比的方案，换下的2G还能出掉。
内存条的选择上，考虑性价比可以选十铨和光威，或者可以选英睿达，协德还是别买了，最后为了稳定和稳定性（心安），买了条金士顿骇客神条，289元。&lt;/p&gt;
&lt;h2&gt;Raid 还是RTRR？&lt;/h2&gt;
&lt;p&gt;本来想买2*4T酷狼，做Raid1，然后再加一个便宜的4T酷鹰做仓库盘。后来看到QNAP 有RTRR功能，而且Raid 1 单盘损坏之后的重建也有风险，这么大容量。
2个4T盘直接独立使用，通过RTRR 功能实时备份重要文件夹，对于家庭用户来说，是更具性价比和可靠的方案。
又再买了一块便宜的闪迪SSD 240GB，230元，用来做系统盘。&lt;/p&gt;
&lt;p&gt;最后的方案是，盘1 240GB SSD，盘2 4T酷狼，盘3 4T酷狼，盘4 空余机动。盘1 和盘2，Qtier。&lt;/p&gt;
&lt;p&gt;&lt;img alt="qnap-disk" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162511.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Transmission 还是Rtorrent？&lt;/h2&gt;
&lt;p&gt;有一个很重要的需求，就是挂PT。之前看帖子发现QTS 4.3 移除了Trasnmission，虽然在qnapclub.eu 可以下到，不过使用体验上真是十分糟糕。
相比rtorrent 强大很多，毕竟收费。
&lt;img alt="qnap-rtorrent" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306162540.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外还可以在Container Station 里安装&lt;a href="https://hub.docker.com/r/oldiy/rrshare64"&gt;人人影视客户端&lt;/a&gt;，非常赞。
依靠Docker，有非常多的玩法，参考&lt;a href="https://odcn.top/2019/02/13/2509/%E6%95%B4%E7%90%86%E6%B1%87%E6%80%BB%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E6%9B%B4%E6%96%B0%E7%9A%84%E4%B8%80%E4%BA%9Bdocker%E9%95%9C%E5%83%8F/"&gt;这位网友的分享&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;END&lt;/h2&gt;
&lt;p&gt;花了挺大的功夫从微云上下载了曾经“备份”上去的文件，导入NAS。配置好手机客户端，配置好Plex，配置好PhotoStation。目前来说还挺满意，也挺安静。
偶尔CPU 会吃紧，看来我的使用场景下买4核心是对的，至于硬盘不能休眠的问题，无所谓了，开了HybridDesk 和一堆功能，想休眠都难。&lt;br&gt;
最近推了4.4 系统，再观望一下，新系统最好别第一时间升。&lt;/p&gt;</content><category term="[Life]"></category><category term="nas"></category><category term="qnap"></category></entry><entry><title>夺回resolv.conf 的控制权</title><link href="https://fangpsh.github.io/posts/2019/2019-06-23.html" rel="alternate"></link><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-06-23:/posts/2019/2019-06-23.html</id><summary type="html">&lt;p&gt;上周在线上修改了一批机器的hostname：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hostnamectl set-hostname xxx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来有同学反馈2台机器的/etc/resolv.conf 被清空了，resolv.conf 的内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Generated by NetworkManager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完了，第一感觉是这两 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上周在线上修改了一批机器的hostname：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hostnamectl set-hostname xxx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来有同学反馈2台机器的/etc/resolv.conf 被清空了，resolv.conf 的内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Generated by NetworkManager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完了，第一感觉是这两个事情一定有相关，我存在知识盲区，简单搜索，果然发现：  &lt;/p&gt;
&lt;p&gt;&lt;a href="Bug 1344303 - hostnamectl set-hostname over-writes existing resolv.conf entries"&gt;Bug 1344303 - hostnamectl set-hostname over-writes existing resolv.conf entries&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;查看出问题的这2台机器的&lt;code&gt;/var/log/message&lt;/code&gt; 也存在上述连接类似的日志：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jun 22 13:48:46 test NetworkManager[605]: &amp;lt;info&amp;gt;  Setting system hostname to &amp;#39;test&amp;#39; (from system configuration)
Jun 22 13:48:46 test dbus[610]: [system] Activating via systemd: service name=&amp;#39;org.freedesktop.nm_dispatcher&amp;#39; unit=&amp;#39;dbus-org.freedesktop.nm-dispatcher.service&amp;#39;
Jun 22 13:48:46 test dbus-daemon[610]: dbus[610]: [system] Activating via systemd: service name=&amp;#39;org.freedesktop.nm_dispatcher&amp;#39; unit=&amp;#39;dbus-org.freedesktop.nm-dispatcher.service&amp;#39;
Jun 22 13:48:46 test systemd[1]: Starting Network Manager Script Dispatcher Service...
Jun 22 13:48:46 test dbus[610]: [system] Successfully activated service &amp;#39;org.freedesktop.nm_dispatcher&amp;#39;
Jun 22 13:48:46 test dbus-daemon[610]: dbus[610]: [system] Successfully activated service &amp;#39;org.freedesktop.nm_dispatcher&amp;#39;
Jun 22 13:48:46 test systemd[1]: Started Network Manager Script Dispatcher Service.
Jun 22 13:48:46 test nm-dispatcher[3006]: Dispatching action &amp;#39;hostname&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Networkmanager 服务也确实在运行之中，存在相关日志：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;settings: hostname changed from &amp;quot;&amp;quot; to &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不过很奇怪，当时总共修改了有几十台服务器，NetworkManager 在运行的也有几十台，其他的好像都没问题，后来为了复现，在这2台机器上再次手动修改hostname，复现不了。。orz，猜测可能和resolv.conf 原来的内容有关，细节可能需要读源码才知道。&lt;/p&gt;
&lt;h2&gt;Bug 1344303&lt;/h2&gt;
&lt;p&gt;话说回来，除了感觉自己存在知识盲区，“想当然”之外，这个Bug 实在是有点莫名其妙，就如同这个Bug 中的网友说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My point is still, that hostnamectl does not look like you are editing resolv.conf. but I'm with you that there is a relation of the domain name and the FQDN. &lt;/p&gt;
&lt;p&gt;I'll update NetworkManager.conf with main/dns=none - no problem. I just wished I knew earlier howto disable the management of resolv.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而作者的态度也是非常坚持，读起来有点爱用用，不用滚的味道。只能说我作为运维，对交付出来的机器，初始化不够统一，才会遇到这种坑。ok，在初始化脚本中增加（针对CentOS 7.x）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- name: Disable NetworkManager
  systemd:
    name: NetworkManager
    state: stopped
    enabled: false
  ignore_errors: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;网友指出:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 RHEL8 中，已经取消了 network.service，所有的网络配置都归属于 NetworkManager，这里可能不是很适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体可参考：&lt;a href="https://zhuanlan.zhihu.com/p/56892392"&gt;基于RHEL8/CentOS8的网络IP配置详解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;似乎Linux 的世界就是有这么多轮子，曾经想，Systemd 能一统天下，带来的却是更多轮子，23333。&lt;/p&gt;
&lt;h2&gt;夺回控制权&lt;/h2&gt;
&lt;p&gt;读到一篇文章：&lt;a href="https://www.ctrl.blog/entry/resolvconf-tutorial.html"&gt;How to take back control of /etc/resolv.conf on Linux&lt;/a&gt;，如何夺回Linux 上/etc/resolv.conf 的控制权！
原来还有这么多玩意，详情参考文章链接，作者一直在更新，很用心。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NetworkManager&lt;/li&gt;
&lt;li&gt;/etc/sysconfig/network/config: NETCONFIG_DNS_POLICY&lt;/li&gt;
&lt;li&gt;resolvconf, rdnssd&lt;/li&gt;
&lt;li&gt;systemd-resolved&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对了，&lt;a href="https://www.cyberciti.biz/faq/dhclient-etcresolvconf-hooks/"&gt;DHCP 也可能会碰你的resolv.conf 哦&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;学无止境，坑外有坑。&lt;/p&gt;</content><category term="2019"></category><category term="linux"></category><category term="resolv.conf"></category></entry><entry><title>解决Mac OS 下Alt-f、Alt-b 失效的问题</title><link href="https://fangpsh.github.io/posts/2019/2019-04-14.html" rel="alternate"></link><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-04-14:/posts/2019/2019-04-14.html</id><summary type="html">&lt;p&gt;我算是半个Emacs 用户，Mac OS 吸引我的一个地方是它几乎所有输入框都能使用基本的Emacs 行操作快捷键，因为GNU Redline。&lt;/p&gt;
&lt;p&gt;最近看到&lt;a href="https://twitter.com/linuxtoy/status/957225197928525824"&gt;Linuxtoy …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;我算是半个Emacs 用户，Mac OS 吸引我的一个地方是它几乎所有输入框都能使用基本的Emacs 行操作快捷键，因为GNU Redline。&lt;/p&gt;
&lt;p&gt;最近看到&lt;a href="https://twitter.com/linuxtoy/status/957225197928525824"&gt;Linuxtoy 推文&lt;/a&gt;里面的这张图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="moving_cli" src="https://clementc.github.io/figures/moving_cli.png"&gt;&lt;/p&gt;
&lt;p&gt;想起自从形成肌肉记忆之后，在浏览器地址栏等地方常常打&lt;code&gt;Alt-f&lt;/code&gt;,&lt;code&gt;Alt-b&lt;/code&gt; 这几个快捷键，会发现打出来的是奇怪的字符：&lt;code&gt;ƒ&lt;/code&gt;,&lt;code&gt;∫&lt;/code&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ffffff" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162114.png"&gt;&lt;/p&gt;
&lt;p&gt;以为是系统限制，忍受了很久。今天搜索下，翻到一篇文章：&lt;a href="https://blog.sensible.io/2012/10/19/mac-os-x-emacs-style-keybindings-everywhere.html"&gt;Mac OS X: Emacs-like keybindings everywhere&lt;/a&gt;， 找到解决方法。&lt;/p&gt;
&lt;p&gt;创建配置文件：&lt;code&gt;~/Library/KeyBindings/DefaultKeyBinding.dict&lt;/code&gt; （如果不存在这个&lt;code&gt;KeyBindings&lt;/code&gt; 目录，就新建一个）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
    &amp;quot;~d&amp;quot; = &amp;quot;deleteWordForward:&amp;quot;;
    &amp;quot;~f&amp;quot; = &amp;quot;moveWordForward:&amp;quot;;
    &amp;quot;~b&amp;quot; = &amp;quot;moveWordBackward:&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重启下相关App ，例如Chrome 浏览器，再试一试，发现OK了，居然这么简单！&lt;/p&gt;
&lt;p&gt;随后在GitHub 发现一个很强大的项目&lt;a href="https://github.com/ttscoff/KeyBindings"&gt;ttscoff/KeyBindings&lt;/a&gt;，有空再折腾，其他键用的不多。&lt;/p&gt;</content><category term="2019"></category><category term="效率"></category><category term="MacOS"></category></entry><entry><title>糟糕的斑马旅游</title><link href="https://fangpsh.github.io/posts/2019/horrible-bmtrip.html" rel="alternate"></link><published>2019-03-10T00:00:00+08:00</published><updated>2019-03-10T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-03-10:/posts/2019/horrible-bmtrip.html</id><summary type="html">&lt;p&gt;2018 年的元旦和女友又去了一次泰国，这次由于我工作比较忙，没精力做攻略，逛了一圈携程、飞猪，选了&lt;a href="https://bmtrip.com/"&gt;斑马旅游&lt;/a&gt;（上海歌晨信 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2018 年的元旦和女友又去了一次泰国，这次由于我工作比较忙，没精力做攻略，逛了一圈携程、飞猪，选了&lt;a href="https://bmtrip.com/"&gt;斑马旅游&lt;/a&gt;（上海歌晨信息技术有限公司）的产品。&lt;/p&gt;
&lt;p&gt;携程上一片五星好评，官网和产品介绍上“高品质”、“轻奢品质”、“精品”、“管家服务”等字眼，促使让我快速下单，继续埋头工作，坐等出发，相信斑马旅游会对本次服务提供一个高品质，和我们付出价格相符的服务，没想到入了个大坑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmstrip-1" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307111242.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;不违法的斑马旅游&lt;/h2&gt;
&lt;p&gt;由于泰国免签，导致落地签人数暴增，排队等了快2个小时，所谓的管家服务，其实就是按照事先准备好的材料，实时在群里播报而已，微信客服人员，说的难听一些，就是个廉价机器人，并不会从具体行程的角度，为游客考虑一些细节。&lt;/p&gt;
&lt;p&gt;终于排完队，出关了，斑马旅游采购的接机服务，让我们在语言不通的情况，在机场等了半小时，来回徘徊，找不到接机人。
好不容易到达 入住的酒店：曼谷贝素坤逸12精品酒店(12th Avenue Hotel Bangkok)，该酒店在巷子深处，巷子四处一堆垃圾，出行非常不方便。&lt;/p&gt;
&lt;p&gt;12月31日，夜间11点，房间正对泳池，泳池在放激烈的音乐，联系产品中提到的“24小时管家”，反应情况，斑马侧服务人员表示无法解决，严重影响休息。&lt;/p&gt;
&lt;p&gt;1月1日，前往第二个酒店，芭堤雅莫杜斯海滨度假村(Pattaya Modus Beachfront Resort) ，才发现酒店处于荒野之中，步行10分钟之内都是一片荒地，垃圾成堆，野狗出没。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmstrip-03" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307120254.jpg"&gt;&lt;/p&gt;
&lt;p&gt;之前承诺的酒店免费班车，斑马没有事先提供相关详情。索要班车单之后，后续乘坐所谓的酒店免费班车，酒店人员依然对我们进行了收费，平均都在150泰铢+，和斑马客服人员联系，请求帮忙和酒店沟通，无果。
&lt;strong&gt;斑马旅游并未对该酒店进行细致的考察&lt;/strong&gt;，酒店的早餐楼层都能弄错，和宣传的高品质服务差距太大。后续2天，每次午餐，晚餐，由于酒店附近一片荒地，外加野狗成群，不安全，都需要打车外出就餐。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-4" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307140854.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1月3日 回程，斑马旅游告知师傅下午3点05 送机，我们2点30分在大堂等候，告知斑马我们已经在等候。一直到3点05分，没人举牌。
询问斑马。斑马和本地送机服务商沟通之后，才知道师傅好久之前已经到了，体验糟糕。&lt;/p&gt;
&lt;p&gt;终于发现所谓的高品质旅游，只是拼凑各类产品，接送机、机票酒店、本地团等等，他们的产品经理也不会整个行程真的从产品角度上进行考量。&lt;br&gt;
在我提出和他们的产品负责人沟通的时候，斑马的管家人员只是想大事化小，一直强调自己安排的行程是前台披露的行程单，&lt;strong&gt;并不违法&lt;/strong&gt;。。。。也是非常无奈斑马旅游的目标就是不违法。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://news.ifeng.com/a/20170809/51594943_0.shtml"&gt;《斑马旅游：它们“死磕”产品和服务，打造出了中国最“贴心”》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“在中国众多旅游品牌中，斑马旅游应该是最“用心”它的旅行线路全由产品经理精心设计而来，服务精细到了你所能想象得到的任意细枝末节。亦或，你今天提出了建议，明天，新的专属于你的旅行线路就出现了，反应速度快的惊人”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写这文章的人真是对不起他的良心，东南亚线还是他们主力的产品，都搞成这样，其他的线路可想而知。&lt;/p&gt;
&lt;p&gt;广告很美好，体验很残酷。&lt;/p&gt;
&lt;h2&gt;投诉投诉&lt;/h2&gt;
&lt;p&gt;从第三天开始，就开始想着回家好了，斑马旅游毁掉了我和女朋友的年度旅游，回家再投诉。回国之后，提出经济赔偿，屎已经踩了，假期也毁了，斑马旅游的负责人说最多赔500，精神损失。。。并且示意我们拿了赔偿之后，闭嘴。我一万多都花了，不差你这几百块，拒绝。&lt;/p&gt;
&lt;p&gt;大致就是&lt;a href="https://zhidao.baidu.com/question/1370162280692029979.html"&gt;这位网友&lt;/a&gt;的感觉：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-5" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307141001.jpg"&gt;&lt;/p&gt;
&lt;p&gt;随后向携程投诉，携程处理的倒挺快，表示他们和斑马只是合作商的关系，不是上下级，没有权限。。。说给我们400 的赔偿，作为精神损失。&lt;/p&gt;
&lt;p&gt;再向斑马旅游所在的&lt;a href="http://lyw.sh.gov.cn/lyj_website/HTML/DefaultSite/lyj_zmhd_lyts/List/index.htm?mail=lyj_zmhd_lyts"&gt;上海市旅游局投诉&lt;/a&gt;，这次发现斑马旅游过去每个月几乎也都会被投诉。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307141028.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不过上海旅游局表示我们是和携程签的合同，投诉主体不对。回家之后年前很忙，就当倒霉了，今天整理资料，看到行程单等文件，才又气上心头，十分不爽。&lt;/p&gt;
&lt;p&gt;36Kr 上有一篇他们的&lt;a href="https://36kr.com/p/5106337.html"&gt;公关稿&lt;/a&gt;，17年获得了Pre-A轮融资，看来他们的广告文案，讲故事的能力还骗到了一些傻子。所谓的好评、所谓的数据，都能够造假，都能刷，但是线下的体验是无法造假的。&lt;/p&gt;
&lt;p&gt;总的来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高价格的糟心之旅&lt;/li&gt;
&lt;li&gt;低质量的机器人客服&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不如自己做攻略，一分钱一分货，享受旅游。&lt;br&gt;
想省心，还是报个大旅行社的团吧，远离这种“皮包”公司。&lt;/p&gt;
&lt;h2&gt;花絮&lt;/h2&gt;
&lt;p&gt;知乎&lt;a href="https://www.zhihu.com/question/28105489/answer/173499903"&gt;软广&lt;/a&gt;，&lt;a href="https://www.zhihu.com/people/yitiao-ban-ma-7"&gt;这人&lt;/a&gt; 看起来很明显是员工，也挺不容易的，写这么长的帖子，就为了这几句话：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-6" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307141348.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在知乎搜斑马，发现一堆骂公司的&lt;a href="https://www.zhihu.com/question/61230719"&gt;帖&lt;/a&gt;，看起来乌烟瘴气，压榨员工。&lt;/p&gt;
&lt;p&gt;想起和我对接的客服妹子，挺不容易的，她能做到的，都帮我了，斑马旅游拿她当廉价机器人使。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-9" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307141613.jpg"&gt;&lt;/p&gt;
&lt;p&gt;回来再仔细看了一些携程评价，有些好评似乎是旅游结束之后，客服妹子“催”，或者说是“求”出来的，类似&lt;a href="https://www.dianping.com/review/355995485"&gt;这位网友说的情况&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmtrip-8" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307141542.jpg"&gt;&lt;/p&gt;
&lt;p&gt;我写了一个差评之后，斑马旅游直接下线了，&lt;a href="http://vacations.ctrip.com/tour/detail/p19877402s30.html"&gt;下线的&lt;/a&gt;，&lt;a href="http://vacations.ctrip.com/tour/detail/p20446619s2.html"&gt;替换上线的&lt;/a&gt;，内容行程一模一样，原来就是这样掩盖的。。我下回还是认真看差评吧。&lt;/p&gt;</content><category term="2019"></category><category term="trip"></category></entry><entry><title>ip_local_port_range 小问题</title><link href="https://fangpsh.github.io/posts/2019/2019-03-01.html" rel="alternate"></link><published>2019-03-01T00:00:00+08:00</published><updated>2019-03-01T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-03-01:/posts/2019/2019-03-01.html</id><summary type="html">&lt;p&gt;发现系统打印了一条日志，类似&lt;a href="https://access.redhat.com/solutions/2887631"&gt;redhat solution:2887631&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jan 23 14:37:22 localhost kernel: ip_local_port_range: prefer different parity for start/end values.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;意思是建议将&lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 的两个数设置一个 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;发现系统打印了一条日志，类似&lt;a href="https://access.redhat.com/solutions/2887631"&gt;redhat solution:2887631&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Jan 23 14:37:22 localhost kernel: ip_local_port_range: prefer different parity for start/end values.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;意思是建议将&lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 的两个数设置一个奇数，一个偶数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ip_local_port_range - 2 INTEGERS  
        Defines the local port range that is used by TCP and UDP to  
        choose the local port. The first number is the first, the
        second the last local port number.
        If possible, it is better these numbers have different parity.
        (one even and one odd values)
        The default values are 32768 and 60999 respectively.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;建议改，那就改一下咯。可是为什么呢？能让系统分配端口的时候更高效？&lt;/p&gt;
&lt;p&gt;搜索一下，找到2个相关的Patch：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.spinics.net/lists/netdev/msg330439.html"&gt;[PATCH net-next] tcp/dccp: try to not exhaust ip_local_port_range in connect()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.spinics.net/lists/netdev/msg330895.html"&gt;[PATCH net-next] tcp/dccp: warn user for preferred ip_local_port_range&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找下第一个Patch 里面的 &lt;code&gt;__inet_hash_connect&lt;/code&gt; 函数的完整内容看下：&lt;a href="https://github.com/torvalds/linux/blob/07f4c90062f8fc7c8c26f8f95324cbe8fa3145a5/net/ipv4/inet_hashtables.c#L483,L595"&gt;linux/net/ipv4/inet_hashtables.c&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://linuxperf.com/?p=178"&gt;临时端口号(EPHEMERAL PORT)的动态分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/u/2310891/blog/652323"&gt;TCP你学得会：之 TCP端口选择那些事儿&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://vcpu.me/bind/"&gt;bind()实现源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.linuxtcpipstack.com/430.html"&gt;TCP层bind系统调用的实现分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看完好像有点明白了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 3766bddb3e8a7303123aa7e32507f6f7801c10d5..8c0fc6fbc1afa08baf07ca86e98aa966a3f8e826 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -501,8 +501,14 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
         inet_get_local_port_range(net, &amp;amp;low, &amp;amp;high);
         remaining = (high - low) + 1;

+        /* By starting with offset being an even number,
+         * we tend to leave about 50% of ports for other uses,
+         * like bind(0).
+         */
+        offset &amp;amp;= ~1;  // offset 始终为偶数
+
         local_bh_disable();
-        for (i = 1; i &amp;lt;= remaining; i++) {
+        for (i = 0; i &amp;lt; remaining; i++) {
             port = low + (i + offset) % remaining;  // 每次总是加偶数开始找，即i=0 的时候
             if (inet_is_local_reserved_port(net, port))
                 continue;
@@ -546,7 +552,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
         return -EADDRNOTAVAIL;

 ok:
-        hint += i;
+        hint += (i + 2) &amp;amp; ~1;  // 每次调用函数时， offset = hint + port_offset; hint 是全局静态变量，始终为偶数
                                // 这样在同一个目地地址+端口，重复调用，且没其他connect 请求插入的时候，分配的端口号是加2递增

         /* Head lock still held and bh&amp;#39;s disabled */
         inet_bind_hash(sk, tb, port);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;N 个端口，每次从第偶数个开始找，看下&lt;code&gt;bind(0)&lt;/code&gt; 分配端口的&lt;a href="https://github.com/torvalds/linux/blob/29c6852602e259d2c1882f320b29d5c3fec0de04/net/ipv4/inet_connection_sock.c#L119"&gt;相关函数&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;smallest_rover = rover = prandom_u32() % remaining + low;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后者看意思是完全随机的，所以意思是&lt;code&gt;connect&lt;/code&gt;从偶数个开始找，让出一半的空间给&lt;code&gt;bind(0)&lt;/code&gt;，提高&lt;code&gt;bind(0)&lt;/code&gt;的效率。&lt;/p&gt;
&lt;p&gt;如果是这样的话，为什么建议&lt;code&gt;ip_local_port_range&lt;/code&gt; 可用的端口是偶数，即要有一个奇数、一个偶数呢？&lt;code&gt;offset&lt;/code&gt; 每次也都是无论哪种情况是偶数，
remaining 为偶数为奇数好像都不影响逻辑，只差一个而已，一定要50%？&lt;/p&gt;
&lt;p&gt;愚钝，没想明白。&lt;/p&gt;
&lt;p&gt;看了下新的&lt;a href="https://github.com/torvalds/linux/blob/1580ab63fc9a03593072cc5656167a75c4f1d173/net/ipv4/inet_hashtables.c#L562"&gt;__inet_hash_connect&lt;/a&gt;，感觉更合理一些，
&lt;code&gt;connect&lt;/code&gt; 优先从偶数个开始，如果分配失败，每次找下一个的时候，也是跳到下一个偶数个，即&lt;code&gt;port+=2&lt;/code&gt;，&lt;code&gt;inet_csk_find_open_port&lt;/code&gt;则是&lt;a href="https://github.com/torvalds/linux/blob/b71acb0e372160167bf6d5500b88b30b52ccef6e/net/ipv4/inet_connection_sock.c#L208"&gt;反过来&lt;/a&gt;，更加高效，大家都优先用一半，不行再找对方的一半。&lt;/p&gt;</content><category term="2019"></category><category term="linux"></category><category term="kernel"></category><category term="tcp"></category></entry><entry><title>Python Switch 多次调用小问题</title><link href="https://fangpsh.github.io/posts/2019/2019-02-24.html" rel="alternate"></link><published>2019-02-24T00:00:00+08:00</published><updated>2019-02-24T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2019-02-24:/posts/2019/2019-02-24.html</id><summary type="html">&lt;p&gt;大家都知道Python 中没有Switch 关键词，如果写一堆if-elif-else 非常不美观，通常的做法是使用字典，今天遇到一个小问题，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Recource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;do …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;大家都知道Python 中没有Switch 关键词，如果写一堆if-elif-else 非常不美观，通常的做法是使用字典，今天遇到一个小问题，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Recource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;do&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
       &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="s1"&gt;&amp;#39;aliyun&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;
             &lt;span class="s1"&gt;&amp;#39;create&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__create__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
             &lt;span class="s1"&gt;&amp;#39;update&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__update__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
             &lt;span class="o"&gt;...&lt;/span&gt;
             &lt;span class="p"&gt;},&lt;/span&gt;
         &lt;span class="s1"&gt;&amp;#39;aws&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;写完测试一下，发现字典里面每个函数都会被执行一遍，发现自己傻逼了，但是一时不知道该如何解决，Google 下找到了解决方式：
&lt;a href="https://stackoverflow.com/questions/46908510/pythonic-switch-within-class"&gt;Pythonic switch within class&lt;/a&gt;,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Recource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;do&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
       &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="s1"&gt;&amp;#39;aliyun&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;            &lt;span class="s1"&gt;&amp;#39;create&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__create__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;            &lt;span class="s1"&gt;&amp;#39;update&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__update__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;            &lt;span class="s1"&gt;&amp;#39;create&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__create__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;            &lt;span class="s1"&gt;&amp;#39;update&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__update__&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
             &lt;span class="o"&gt;...&lt;/span&gt;
             &lt;span class="p"&gt;},&lt;/span&gt;
         &lt;span class="s1"&gt;&amp;#39;aws&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;       &lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;       &lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原来如此，lambda 定义一个匿名函数，这个对象指向具体函数对象的地址，类似&lt;a href="https://en.wikipedia.org/wiki/Branch_table"&gt;jump table&lt;/a&gt;。&lt;br&gt;
又一次面向Stack Overflow 编程 :P。&lt;/p&gt;</content><category term="2019"></category><category term="python"></category></entry><entry><title>ANAME、CNAME、DNAME</title><link href="https://fangpsh.github.io/posts/2018/2018-11-04.html" rel="alternate"></link><published>2018-11-04T00:00:00+08:00</published><updated>2018-11-04T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-11-04:/posts/2018/2018-11-04.html</id><summary type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/CNAME_record"&gt;CNAME&lt;/a&gt; 很常见，一般人都很熟悉，将一个域名映射到另外一个域名。但是CNAME 有个限制，顶级域名（apex domain）不建议设置CNAME，因为会和MX 记 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/CNAME_record"&gt;CNAME&lt;/a&gt; 很常见，一般人都很熟悉，将一个域名映射到另外一个域名。但是CNAME 有个限制，顶级域名（apex domain）不建议设置CNAME，因为会和MX 记录冲突，详细解释：&lt;a href="https://www.v2ex.com/t/204489#26"&gt;为什么裸域名不可以设置 CNAME？#26&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ietf.org/rfc/rfc1912.txt"&gt;RFC1912:2.4 CNAME records&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A CNAME record is not allowed to coexist with any other data.  In other words, if suzy.podunk.xx is an alias for sue.podunk.xx, you can't also have an MX record for suzy.podunk.edu, or an A record, or even a TXT record...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以就诞生了&lt;a href="https://dnsmadeeasy.com/services/anamerecords/"&gt;ANAME&lt;/a&gt;，有些DNS 服务商叫做&lt;a href="https://support.dnsimple.com/articles/alias-record/"&gt;ALIAS&lt;/a&gt;，可以在apex domain 上实现类似CNAME 效果。第一次见到这个，是在配置&lt;a href="https://blog.github.com/2014-01-07-faster-more-awesome-github-pages/#apex-domain-examplecom---with-alias-or-a"&gt;Github Pages&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前只有一些国外的DNS 服务商支持：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://help.iwantmyname.com/customer/portal/articles/1599947-do-you-support-alias-or-aname-dns-records-"&gt;Do you support ALIAS or ANAME DNS records?&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CloudFlare&lt;/li&gt;
&lt;li&gt;DNSMadeEasy&lt;/li&gt;
&lt;li&gt;DNSimple&lt;/li&gt;
&lt;li&gt;PointDNS&lt;/li&gt;
&lt;li&gt;Amazon Route 53 (only for hosting on AWS)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过这是非标准的实现，生产环境还是少用为好。&lt;/p&gt;
&lt;h2&gt;DNAME&lt;/h2&gt;
&lt;p&gt;除了ANAME，CNAME，还有一个&lt;a href="https://www.ietf.org/rfc/rfc2672.txt"&gt;DNAME&lt;/a&gt;。DNAME 和CNAME 的区别是，CNAME 只是映射一个子域名，DNAME 映射的是整个子域名空间。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;aaa.example.com CNAME bbb.example.org

还可以添加记录

a1.aaa.example.com CNAME  b1.bbb.example.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;aaa&lt;/code&gt; 的CNAME 只是表示把&lt;code&gt;aaa&lt;/code&gt;这个子域名映射过去，并不影响&lt;code&gt;*.aaa&lt;/code&gt;。但是如果DNAME 的话，就不一样了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;aaa.example.com CNAME bbb.example.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候你再解析&lt;code&gt;a1.aaa.example.com&lt;/code&gt;，得到的实际是&lt;code&gt;a1.bbb.example.org&lt;/code&gt; 的结果。因为&lt;code&gt;aaa.example.com&lt;/code&gt; 节点包括其子节点都映射到了&lt;code&gt;bbb.example.org&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;更详细的例子可以参考台湾网友的这篇文章：&lt;a href="https://ssorc.tw/994"&gt;DNS的CNAME/DNAME傻傻分不清楚&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外DNAME 记录，国内的DNS 服务商也几乎都不支持╮(╯▽╰)╭ 。&lt;/p&gt;</content><category term="2018"></category><category term="DNS"></category></entry><entry><title>IPv6-Test DNS 测试</title><link href="https://fangpsh.github.io/posts/2018/2018-11-3.html" rel="alternate"></link><published>2018-11-03T00:00:00+08:00</published><updated>2018-11-03T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-11-03:/posts/2018/2018-11-3.html</id><summary type="html">&lt;p&gt;&lt;img alt="ipv6-test" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185431.png"&gt;&lt;/p&gt;
&lt;p&gt;最近在折腾办公室的IPv6 环境，通过&lt;a href="http://ipv6-test.com/"&gt;ipv6-test.com&lt;/a&gt;测试的时候，对页面内的“DNS”的测试结果有点疑问。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS4 + IP6&lt;ul&gt;
&lt;li&gt;Connectivity to an IPv6 address served by an IPv4-only name server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS6 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="ipv6-test" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228185431.png"&gt;&lt;/p&gt;
&lt;p&gt;最近在折腾办公室的IPv6 环境，通过&lt;a href="http://ipv6-test.com/"&gt;ipv6-test.com&lt;/a&gt;测试的时候，对页面内的“DNS”的测试结果有点疑问。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS4 + IP6&lt;ul&gt;
&lt;li&gt;Connectivity to an IPv6 address served by an IPv4-only name server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS6 + IP4&lt;ul&gt;
&lt;li&gt;Connectivity to an IPv4 address served by an IPv6-only name server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS6 + IP6&lt;ul&gt;
&lt;li&gt;Connectivity to an IPv6 address served by an IPv6-only name server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看下页面的网络请求，三种测试用例分别请求的地址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS4 + IP6&lt;ul&gt;
&lt;li&gt;v6.zone4.ipv6-test.com&lt;/li&gt;
&lt;li&gt;AAAA 记录：2001:41d0:8:e8ad::1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS6 + IP4&lt;ul&gt;
&lt;li&gt;v4.zone6.ipv6-test.com&lt;/li&gt;
&lt;li&gt;A 记录：5.135.165.173&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS6 + IP6&lt;ul&gt;
&lt;li&gt;v6.zone6.ipv6-test.com&lt;/li&gt;
&lt;li&gt;AAAA 记录：2001:41d0:8:e8ad::1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实还有个&lt;code&gt;DNS4 + IP4&lt;/code&gt;，没啥好测试的嘛。&lt;/p&gt;
&lt;p&gt;明白了，三种测试用例，DNS4/6 表示的是权威服务器的网络环境，要么是IPv4，要么是IPv6；IP4/6 只是其实分别是A和AAAA 记录。测试的其实是本地local dns 对&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;权威服务器托管在IPv4 环境，通过AAAA记录（IPv6 网络）访问&lt;/li&gt;
&lt;li&gt;权威服务器托管在IPv6 环境，通过A记录（IPv4 网络）访问&lt;/li&gt;
&lt;li&gt;权威服务器托管在IPv6 环境，通过AAAA（IPv4 网络）访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，如果你是IPv4 网络的话，1、3 测试肯定是失败的，IPv6 不通嘛，但是2 可能能够成功，因为你的local dns 出口可能是能够访问IPv6 环境的，如果不行的话，换成&lt;code&gt;8.8.8.8&lt;/code&gt; 试一试？&lt;/p&gt;
&lt;p&gt;我在电信的IPv6 环境下测试发现3 失败了，电信还没给IPv6 的DNS，默认的IPv4 的DNS 也不能访问到纯IPv6 环境的权威服务器，手动加个Google 的&lt;code&gt;2001:4860:4860::8888&lt;/code&gt; 就好了。&lt;/p&gt;
&lt;p&gt;IPv6 要推广了，相关的一堆基础知识得抓紧补了，地址格式、SLAAC、DHCPv6、ICMPv6...想起大学计网老师居然自动跳过了IPv6 这一章！&lt;/p&gt;</content><category term="2018"></category><category term="ipv6"></category><category term="dns"></category><category term="network"></category></entry><entry><title>Airflow 并发trigger DAG 的问题</title><link href="https://fangpsh.github.io/posts/2018/2018-10-25.html" rel="alternate"></link><published>2018-10-25T00:00:00+08:00</published><updated>2018-10-25T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-10-25:/posts/2018/2018-10-25.html</id><summary type="html">&lt;p&gt;有一个小服务使用了&lt;a href="http://airflow.apache.org"&gt;airflow&lt;/a&gt;，会把比较耗时的离线任务丢到airflow 处理。
在需要的时候触发（trigger_dag）这些任务。最近发现一小部分任务没 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;有一个小服务使用了&lt;a href="http://airflow.apache.org"&gt;airflow&lt;/a&gt;，会把比较耗时的离线任务丢到airflow 处理。
在需要的时候触发（trigger_dag）这些任务。最近发现一小部分任务没成功，对应的dag 下也没找到日志记录，看起来是没触发成功。
在airflow-web-server 中发现了异常日志：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Run id ... already exists for dag id ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看了下代码：&lt;a href="https://github.com/apache/incubator-airflow/blob/master/airflow/api/common/experimental/trigger_dag.py#L42,L55"&gt;incubator-airflow/airflow/api/common/experimental/trigger_dag.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未指定run_id 的情况下，run_id 默认为&lt;code&gt;utcnow&lt;/code&gt;，并且还默认去掉了microsecond。这样的话，对同一个dag 大量并发trigger 的时候，run_id 很容易相同。&lt;/p&gt;
&lt;p&gt;临时的解决方法，在trigger dag 时指定下run_id。我临时改成了 utcnow+uuid4，应该不会再撞上了吧，不然就是中彩票了。&lt;/p&gt;</content><category term="2018"></category><category term="Airflow"></category></entry><entry><title>关闭服务器节能模式</title><link href="https://fangpsh.github.io/posts/2018/2018-09-20.html" rel="alternate"></link><published>2018-09-20T00:00:00+08:00</published><updated>2018-09-20T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-09-20:/posts/2018/2018-09-20.html</id><summary type="html">&lt;p&gt;不少服务器出厂默认是开启节能模式，会有很多“坑”，例如意外宕机。我不清楚这些坑现在还是否存在，或者该怎样绕过去，也 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;不少服务器出厂默认是开启节能模式，会有很多“坑”，例如意外宕机。我不清楚这些坑现在还是否存在，或者该怎样绕过去，也不想花费这个精力。
反正都是租用的服务器，完全不用操心电费；租机柜托管的，好像也不会另外算电费。没有BAT 量级的机器，没必要花功夫研究细节，关了即可。&lt;/p&gt;
&lt;p&gt;让BIOS 接管电源管理，跑在最佳性能，整理下常见厂商的关闭步骤。&lt;/p&gt;
&lt;h2&gt;Dell&lt;/h2&gt;
&lt;p&gt;Dell 的iDrac：BIOS》System Profile Settings》Performance&lt;/p&gt;
&lt;p&gt;BIOS 中设置：
&lt;img alt="idrac_bios" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161317.png"&gt;&lt;/p&gt;
&lt;p&gt;iDrac Web 中设置：
&lt;img alt="idrac_web1" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161326.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="idrac_web2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161338.png"&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaseywang.me/2013/09/22/nix-下-cpu-的能耗控制/"&gt;《*NIX 下 CPU 的能耗控制》&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说了这么多，其实完全没有必要这么做，前提的是你的机器数量在五位数以下，我估计大陆 p99 的互联网都是这个量级以下的，创业公司就更普遍了。&lt;br&gt;
 因此，最简单的办法是，将 BIOS 设置成 "Performance"(memory freq sets to max, memory patrol scrub sets to standard mode, memory fresh rate sets to 1x, memory operating voltage sets to auto, turbo boost enabled and C1E&amp;amp;C-states disabled) 模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://crtech.tips/performance-mode-omsa/"&gt;PERFORMANCE MODE – OMSA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;浪潮/华为&lt;/h2&gt;
&lt;p&gt;浪潮和华为的服务器大多用的&lt;a href="https://ami.com/"&gt;AMI BIOS &lt;/a&gt;，设置上差不多：
&lt;img alt="ami_bios1" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161352.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ami_bios2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161403.png"&gt;&lt;/p&gt;
&lt;p&gt;Power Techology 选中Performance ，或者选中 Custom，再手动调整。&lt;/p&gt;
&lt;p&gt;Power Policy Select 电源策略选择，菜单选项为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Efficiency（节能模式）：效率优先，启用后是低性能低功耗模式，此模式可确保降低系统的功耗。&lt;/li&gt;
&lt;li&gt;Performance（性能模式）：性能优先，启用后是高性能高功耗模式。&lt;/li&gt;
&lt;li&gt;Custom（自定义）：用户自定义模式，兼顾性能、延迟和能耗。建议配置CPU运行在标准频率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BIOS -&amp;gt; chipset -&amp;gt; Energy Performance Tunning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Energy Performance Tunning 选中BIOS&lt;/li&gt;
&lt;li&gt;Energy PerformanceBIAS 选中Performance&lt;/li&gt;
&lt;li&gt;Workload Configuration 选中Balanced&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU P State Control&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EIST 选中Disabled&lt;/li&gt;
&lt;li&gt;Turbo Mode 选中Enable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU C State Control&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Package C State limit 选中C0/C1 state&lt;/li&gt;
&lt;li&gt;CPU C3 report 选中Disabled&lt;/li&gt;
&lt;li&gt;CPU C6 report 选中Disabled&lt;/li&gt;
&lt;li&gt;Enhanced Halt State (C1E) 选中Disabled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ACPI T-States 选中Disbaled&lt;/p&gt;
&lt;p&gt;&lt;img alt="bmc" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161415.png"&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://support.huawei.com/enterprise/zh/doc/EDOC1000039566?section=j014"&gt;华为服务器 Brickland平台 BIOS：Advanced Power Management Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.4008600011.com/archives/3542"&gt;SA5212M4 BIOS设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.4008600011.com/archives/12499#Advanced_Power_Management_Configuration"&gt;SA5212M5-BIOS设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;HP&lt;/h2&gt;
&lt;p&gt;&lt;img alt="hp" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161426.png"&gt;&lt;/p&gt;
&lt;p&gt;System Profiles 选择：Maxium Performance（最高性能）&lt;/p&gt;
&lt;p&gt;iLo 设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt="iLo_2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161437.png"&gt;&lt;/p&gt;
&lt;p&gt;BIOS 设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt="hp_bios" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161445.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="hp_bios2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161454.png"&gt;&lt;/p&gt;
&lt;h2&gt;IBM&lt;/h2&gt;
&lt;p&gt;IBM 的服务器没接触过，不过都差不多，IBM 的管理卡似乎叫&lt;a href="https://www.ibm.com/support/knowledgecenter/TI0003N/p8hat/p8hat_partitioningwithanhmc.htm"&gt;HMC&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启用固定最大频率模式：使处理器频率设置为可以指定的固定值。此选项允许您设置处理器频率的最大限制和系统的功耗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="hmc" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161506.png"&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/support/knowledgecenter/zh/POWER8/p8ha1/11powermanagementtask.htm"&gt;IBM Knowledge Center - 电源管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power%20Systems/page/POWER9%20EnergyScale%20-%20Configuration%20&amp;amp;%20Management"&gt;POWER9 EnergyScale - Configuration &amp;amp; Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www-01.ibm.com/support/docview.wss?uid=isg3T1025318"&gt;Change Power Management settings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2018"></category><category term="服务器"></category></entry><entry><title>什么是Bogon？</title><link href="https://fangpsh.github.io/posts/2018/2018-09-19.html" rel="alternate"></link><published>2018-09-19T00:00:00+08:00</published><updated>2018-09-19T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-09-19:/posts/2018/2018-09-19.html</id><summary type="html">&lt;p&gt;在&lt;a href="https://bgp.he.net/"&gt;BGP.HE.NET&lt;/a&gt; 上查询IP 信息的时候，Announced By &lt;a href="https://bgp.he.net/AS4808"&gt;AS4808&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="AS4808" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162304.png"&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;a href="https://bgp.he.net/AS4808#_bogons"&gt;AS4808 announces bogons.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="AS4804_Bogon" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162311.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="202.94.1.0" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162324.png"&gt;&lt;/p&gt;
&lt;p&gt;意思这个段还在APNIC 手里，未被分配，但是联通的这个AS 域广播了这个段 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在&lt;a href="https://bgp.he.net/"&gt;BGP.HE.NET&lt;/a&gt; 上查询IP 信息的时候，Announced By &lt;a href="https://bgp.he.net/AS4808"&gt;AS4808&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="AS4808" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162304.png"&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;a href="https://bgp.he.net/AS4808#_bogons"&gt;AS4808 announces bogons.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="AS4804_Bogon" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162311.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="202.94.1.0" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162324.png"&gt;&lt;/p&gt;
&lt;p&gt;意思这个段还在APNIC 手里，未被分配，但是联通的这个AS 域广播了这个段。&lt;/p&gt;
&lt;p&gt;继续查下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;202/8    APNIC    1993-05    whois.apnic.net    https://rdap.apnic.net/    ALLOCATED&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;202/8&lt;/code&gt; 分配给了APNIC。既然是联通，那就到CNNIC 查下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="CNNIC" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301162337.png"&gt;&lt;/p&gt;
&lt;p&gt;看起来确实没分给联通，不过在&lt;a href="https://www.ipip.net/ip.html"&gt;IPIP.NET&lt;/a&gt;查询，这个IP 归属显示是联通。&lt;/p&gt;
&lt;p&gt;就像&lt;code&gt;10.0.0.0/8&lt;/code&gt; 这类私网保留地址，广播出去，大家应该都会丢弃掉。估计得等以后APNIC 开始分配使用这段地址，联通就不能广播了吧。  &lt;/p&gt;
&lt;p&gt;Bogon&lt;code&gt;['bɔɡən]&lt;/code&gt; 这个单词好多词典都查不到，据说起源于bogus&lt;code&gt;bəuɡəs&lt;/code&gt;：假冒，伪造。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A bogon route is a type of route which shouldn't exist on the global Internet. More specifically, "bogon" (derived from the word "bogus") refers to an advertisement for a prefix within a reserved or otherwise unallocated IP network.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml"&gt;IANA IPv4 Address Space Registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ipwhois.cnnic.cn/bns/query/Query/ipwhoisQuery.do?queryOption=ipv4&amp;amp;txtquery=202.94.1.2&amp;amp;x=46&amp;amp;y=10"&gt;CNNIC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://packetlife.net/blog/2009/jan/21/whats-bogon/"&gt;What's a bogon?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Bogon_filtering"&gt;Bogon filtering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2018"></category><category term="BGP"></category></entry><entry><title>echo 输出导致SCP 失效的问题</title><link href="https://fangpsh.github.io/posts/2018/2018-08-11.html" rel="alternate"></link><published>2018-08-11T00:00:00+08:00</published><updated>2018-08-11T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-08-11:/posts/2018/2018-08-11.html</id><summary type="html">&lt;p&gt;搭建了一个跳板机，强制使用密钥对登陆机器，同时需要用户在本地开启&lt;code&gt;ForwardAgent&lt;/code&gt;，跳板机上创建&lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt;，透传私钥。然而常常有用户在 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;搭建了一个跳板机，强制使用密钥对登陆机器，同时需要用户在本地开启&lt;code&gt;ForwardAgent&lt;/code&gt;，跳板机上创建&lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt;，透传私钥。然而常常有用户在本地没有正确配置，导致上了跳板机之后，再SSH 就会失败，于是我在跳板机的&lt;code&gt;.bashrc&lt;/code&gt; 上写了一段检测脚本，如果变量&lt;code&gt;$SSH_AUTH_SOCK&lt;/code&gt; 不存在，就引导用户去看Wiki，不要烦我啦！&lt;/p&gt;
&lt;p&gt;用了一段时间，有用户发现scp 文件到跳板机时会失败，Google 一下：&lt;a href="https://stackoverflow.com/questions/12440287/scp-doesnt-work-when-echo-in-bashrc"&gt;SCP doesn't work when echo in .bashrc?&lt;/a&gt;，怎么判断当前会话是scp？：&lt;a href="https://superuser.com/questions/690735/can-i-tell-if-im-in-an-scp-session-in-my-bashrc"&gt;Can I tell if I'm in an scp session in my .bashrc?&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;改下脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PS1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$SSH_AUTH_SOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;创建SSH_AUTH_SOCK 失败！&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1.请在本机执行 ssh-add 添加私钥至 ssh-agent&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2.请在~/.ssh/config 配置：ForwardAgent yes&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;详细帮助：wiki...&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;搞定！&lt;/p&gt;</content><category term="2018"></category><category term="SSH"></category><category term="linux"></category></entry><entry><title>踩了Systemd 2个坑</title><link href="https://fangpsh.github.io/posts/2018/2018-08-10.html" rel="alternate"></link><published>2018-08-10T00:00:00+08:00</published><updated>2018-08-10T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-08-10:/posts/2018/2018-08-10.html</id><summary type="html">&lt;p&gt;手写Systemd service 的经验不多，非常尴尬，踩了Systemd 2个坑，浪费了近1个小时，记录一下。&lt;/p&gt;
&lt;p&gt;Python项目部署使用了&lt;a href="https://virtualenv.pypa.io/en/stable/"&gt;virtualenv&lt;/a&gt;，添加一个Systemd service，发现启动失败，提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;手写Systemd service 的经验不多，非常尴尬，踩了Systemd 2个坑，浪费了近1个小时，记录一下。&lt;/p&gt;
&lt;p&gt;Python项目部署使用了&lt;a href="https://virtualenv.pypa.io/en/stable/"&gt;virtualenv&lt;/a&gt;，添加一个Systemd service，发现启动失败，提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line 1327, in _execute_child
raise child_exception
OSError: [Errno 2] No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;忘记设置环境了，&lt;code&gt;EnvironmentFile&lt;/code&gt; 里设置&lt;code&gt;PATH&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;EXAMPLE_ENV=/home/www/example_env
PATH=${EXAMPLE_ENV}:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发现无论如何都无效，Google一下才发现傻了：&lt;a href="https://stackoverflow.com/questions/35439123/systemd-environment-directive-to-set-path"&gt;systemd: “Environment” directive to set PATH&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can't use EnvVars in Environment directives. The whole Environment= will be ignored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;改成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;EXAMPLE_ENV=/home/www/example_env
PATH=/home/www/example_env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;终于好了。不过又遇到一个问题，因为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ExecStart=${EXAMPLE_ENV}/bin/example ....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Systemd 提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Executable path is not absolute, ignoring:${EXAMPLE_ENV}/bin/example ...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咦，变量怎么没解析。Google 了下，改成下面这样就好了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ExecStart=/usr/bin/env ${EXAMPLE_ENV}/bin/example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html"&gt;man/systemd.service&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For each of the specified commands, the first argument must be either an absolute path to an executable or a simple file name without any slashes.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="2018"></category><category term="systemd"></category></entry><entry><title>修复Nintendo Switch Joycon 手柄自动漂移问题</title><link href="https://fangpsh.github.io/posts/2018/xiu-fu-nintendo-switch-joycon-shou-bing-zi-dong-piao-yi-wen-ti.html" rel="alternate"></link><published>2018-06-23T00:00:00+08:00</published><updated>2018-06-23T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-06-23:/posts/2018/xiu-fu-nintendo-switch-joycon-shou-bing-zi-dong-piao-yi-wen-ti.html</id><summary type="html">&lt;p&gt;&lt;img alt="joy-con" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306155958.jpg"&gt;&lt;br&gt;
图片来源：&lt;a href="https://www.zhihu.com/question/263710934/answer/282957512"&gt;知乎-西装暴徒&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;去年买的Switch，最近发现左手柄出现自动漂移，林克时不时自动往左走。搜索了下，在贴吧和知乎发现 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="joy-con" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306155958.jpg"&gt;&lt;br&gt;
图片来源：&lt;a href="https://www.zhihu.com/question/263710934/answer/282957512"&gt;知乎-西装暴徒&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;去年买的Switch，最近发现左手柄出现自动漂移，林克时不时自动往左走。搜索了下，在贴吧和知乎发现挺常见的，例如&lt;a href="https://www.zhihu.com/question/263710934"&gt;Nintendo Switch左手柄Joy-con自动漂移问题，如何解决？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有人说用系统的校准摇杆的功能，实际上没用，那个校准只能应对电磁干扰。&lt;/p&gt;
&lt;p&gt;网友分析原因是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摇杆下面会有一圈白色的粉末。那就是摇杆和边缘摩擦造成磨损而掉下来的粉末。这是无法避免的。而这个粉末就是摇杆漂移的元凶。因为粉末有可能会通过摇杆的缝隙飘进手柄内部，然后附着在摇杆的感应元件上，导致误触。也就是所谓的摇杆漂移，摇杆会一直往同一个方向走，不能自动复位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;贴吧和知乎好多人拆手柄，然后换国产的摇杆模块，其实如果是一般的漂移，完全没必要。有人提到可以用吹气大发，牙签挑起摇杆下面半球形的橡胶，大吸一口，然后吹。我试了下，果然有点好使，不过一段时间之后又复发。证明了确实是粉末造成的。&lt;/p&gt;
&lt;p&gt;接着看到说可以喷&lt;a href="http://www.wd40.com.cn/P_1.aspx"&gt;wd-40&lt;/a&gt;，能洗去灰尘。知乎有个答案提到wd-40 会硬化橡胶、塑料，Joycon 全是橡胶和塑料，所以先喷蓝瓶的wd-40，再喷精密电器清洁剂洗去wd-40。。。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wd-40" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160027.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然后我查看了下答案了提到的wd-40精密仪器清洁剂：&lt;/p&gt;
&lt;p&gt;&lt;img alt="wd-40-specialist" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160044.jpg"&gt;&lt;/p&gt;
&lt;p&gt;咦，有清洁功能呀，而且注明了可用于橡胶、塑料。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wd40" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160057.jpg"&gt;&lt;/p&gt;
&lt;p&gt;所以先喷蓝瓶wd-40 是不是多此一举呢。那就买黑瓶的wd-40试一试。京东自营没货，只能去淘宝找，淘宝价格都在41 左右，发现有&lt;a href="https://m.tb.cn/h.eYWcgVg"&gt;一家&lt;/a&gt;还可以领-3块钱代金券+包邮，销量还很高。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://m.tb.cn/h.eYWcgVg"&gt;&lt;img alt="wd-40-shop" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160149.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看瓶体说明似乎对人体有害，不过挥发性好，如果在室内的话喷，建议打开风扇。喷前摇匀，然后揭起摇杆下的橡胶皮，喷一发，转几圈摇杆，等几分钟挥发干净。&lt;/p&gt;
&lt;p&gt;果然好了！林克终于不会自动跳崖了。。。&lt;/p&gt;
&lt;p&gt;我猜测清理完一次之后，以后可能还会出现粉末导致漂移，不过这一瓶360ml 应该够用了。&lt;/p&gt;</content><category term="2018"></category><category term="nintendo"></category></entry><entry><title>《时间管理--给系统管理员》读书笔记</title><link href="https://fangpsh.github.io/posts/2018/2018-06-04.html" rel="alternate"></link><published>2018-06-04T00:00:00+08:00</published><updated>2018-06-04T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-06-04:/posts/2018/2018-06-04.html</id><summary type="html">&lt;p&gt;&lt;img alt="s2917003" src="https://img2.doubanio.com/view/subject/s/public/s2917003.jpg"&gt;&lt;/p&gt;
&lt;p&gt;听说&lt;a href="https://book.douban.com/subject/2253513/"&gt;这本书&lt;/a&gt;是2年前，最近才想起看，逛了下京东亚马逊，全部没货，淘宝上倒是有不少翻印的盗版。07年出版的，已经十年前了，而本书的内 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="s2917003" src="https://img2.doubanio.com/view/subject/s/public/s2917003.jpg"&gt;&lt;/p&gt;
&lt;p&gt;听说&lt;a href="https://book.douban.com/subject/2253513/"&gt;这本书&lt;/a&gt;是2年前，最近才想起看，逛了下京东亚马逊，全部没货，淘宝上倒是有不少翻印的盗版。07年出版的，已经十年前了，而本书的内容感觉更老。作者创作这本书的时候，IBM 还如日中天，Netflix 还在出租DVD 光盘💿 呢。&lt;/p&gt;
&lt;p&gt;我想看这书的大多数都是运维同学，然而今天的运维，已经和作者书中的系统管理员的工作内容大不一样。作者所做的工作内容，一小部分在如今也已经归入到IT 支持一类的职位中了。不过今天的运维依然要面对一堆琐事，不断被打断。&lt;/p&gt;
&lt;p&gt;上大学的时候，第一次听说时间管理、&lt;a href="https://zh.wikipedia.org/wiki/尽管去做"&gt;GTD&lt;/a&gt;，是从&lt;a href="https://miao.hu"&gt;Maple师兄&lt;/a&gt;口中。工作之后，接触和尝试了一些方法，理论，工具，一直觉得挺累的。如果我花那么大精力去编排，去学习，去做时间管理，是不是本末倒置了？尝试了一段时间之后，日常只会在Reminders App里面简单的记录，或者在笔记软件建一页[TODO]标记未完成的工作。&lt;/p&gt;
&lt;p&gt;然而我发现，曾经去学习的一些方法，工具给我留下了一些看起来还不错的习惯，例如安排优先级，按照优先级做事；优先完成简单快速的事情；拆分任务，更好的规划进度；维持TODO 短、少，克服拖延。另外学习时间管理的过程，还让我意识到专注的重要性。频繁查邮件、各类IM工具挂机、工作期间刷论坛、边听音乐边工作这些习惯，会让大脑频繁进入“上下文切换”，效率大大降低，时间不知不觉溜走。所以，好像也不是本末倒置嘛？所谓时间管理、GTD、各类工作法，可能只是为了让大家养成更好的习惯？&lt;/p&gt;
&lt;p&gt;这本书还是非常值得一读，看看作者是怎么应付繁复无比的上古SA 的工作。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;建立共同干扰防线&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;与同事安排共同干扰防线，以便你必须完成项目时候让别人的干扰转向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了做好自动化，减少繁复的工作，运维还是会被不断的打断，我们还想有百分之五十的时间写代码呢！怎么办？安排oncall 轮值。作者这条指导，和今天的oncall 轮值不谋而合。当然，安排oncall，还有更多好处，例如会推动大家梳理文档，工作交接更清晰，组员对整体的工作更熟悉等等。&lt;/p&gt;
&lt;h2&gt;将脑力留给最重要的事&lt;/h2&gt;
&lt;p&gt;尝试使用各类时间管理、GTD的工具，真不行，用个记事本也成。不过记住要保持todo list 尽量的短，如果堆积，就是灾难，你会更没激情去完成。&lt;/p&gt;
&lt;h2&gt;为其他的人管理事项&lt;/h2&gt;
&lt;p&gt;例如别人来找你的时候，如果不是非常紧急的事情，可以告知他你在什么时候会做，并且告诉他你记录下来了，甚至可以给他看你TODO list 上为他创建的记录。之前在腾讯工作时候，我发现，有时候我确实忙不开，并且这样做了，告诉SNG 的同事我记录下了，他们会表示非常理解。&lt;/p&gt;
&lt;p&gt;另外一个是委派给他们的事情，也需要记录下来！对方并不一定会做时间管理，如果要保证你委派的事情顺利推进，最好也做好记录，跟踪。&lt;/p&gt;
&lt;h2&gt;例行公事&lt;/h2&gt;
&lt;p&gt;作者指的一部分是养成习惯，减少出错，不要浪费精力。另外一点我觉得挺好的，就是和上司、同事定期沟通，除了周报之外，挑个时间定期沟通，挺有意义的，无论是事情推进，还是工作考核等方面。并且如果是定期沟通的，也可以让你的leader 或者同事养成这个习惯:P。&lt;/p&gt;
&lt;h2&gt;循环系统&lt;/h2&gt;
&lt;p&gt;后面三~七章，作者都在说他发明的循环系统，可能有意义，不过我觉得没啥意思，可能我还是难以养成这样的习惯。&lt;/p&gt;
&lt;h2&gt;优先级&lt;/h2&gt;
&lt;p&gt;不要成为上司较大项目延迟的原因所在。&lt;/p&gt;
&lt;p&gt;为了管理你的上司，你必须做三件事：确定上司知道你的职涯目标，只有当能善用他的职权时才使用往上委派，以及了解他的目标并成为完成那些目标的一部分。&lt;/p&gt;
&lt;p&gt;挺有道理的，不过好像有点趋炎附势？圆滑世故？&lt;/p&gt;
&lt;h2&gt;排除浪费时间的事情&lt;/h2&gt;
&lt;p&gt;不到为什么办公室总是有人在不断的闲聊，导致我常常得戴着降噪耳机。不断的闲聊不仅浪费参与者的时间，还干扰附近工位的同事。&lt;/p&gt;
&lt;h2&gt;说明文件、自动化&lt;/h2&gt;
&lt;p&gt;建立Wiki 系统，这在今天非常常见，不过维护好Wiki，好好写文档，依然还是少见的。自动化，做运维的都懂，今天大家做的，也不仅仅是书中那种初级的自动化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还有一个收获，就是知道了RAID (Redundant Array of Independent Disks, originally Redundant Array of Inexpensive Disks)，一开始是指廉价磁盘冗余阵列，后来才变成独立磁盘冗余阵列，见：&lt;a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-391.pdf"&gt;A Case for Redundant Arrays of Inexpensive Disks (RAID)&lt;/a&gt;。&lt;/p&gt;</content><category term="2018"></category><category term="book"></category><category term="gtd"></category></entry><entry><title>OpenLDAP 的SSHA</title><link href="https://fangpsh.github.io/posts/2018/2018-05-07.html" rel="alternate"></link><published>2018-05-07T00:00:00+08:00</published><updated>2018-05-07T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-05-07:/posts/2018/2018-05-07.html</id><summary type="html">&lt;p&gt;&lt;img alt="LDAPworm.gif" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161613.png"&gt;&lt;/p&gt;
&lt;p&gt;最近折腾了一下&lt;a href="https://www.openldap.org"&gt;OpenLDAP&lt;/a&gt;，密码用的哈希算法是SSHA，SSHA 其实就是加盐的&lt;a href="https://zh.wikipedia.org/zh/SHA-1"&gt;SHA1&lt;/a&gt;：&lt;code&gt;salted SHA1&lt;/code&gt;，加盐增加了利用彩虹表碰撞的难度。&lt;/p&gt;
&lt;p&gt;摘一段官网&lt;a href="https://www.openldap.org/faq/data/cache/347.html"&gt;FAQ …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="LDAPworm.gif" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161613.png"&gt;&lt;/p&gt;
&lt;p&gt;最近折腾了一下&lt;a href="https://www.openldap.org"&gt;OpenLDAP&lt;/a&gt;，密码用的哈希算法是SSHA，SSHA 其实就是加盐的&lt;a href="https://zh.wikipedia.org/zh/SHA-1"&gt;SHA1&lt;/a&gt;：&lt;code&gt;salted SHA1&lt;/code&gt;，加盐增加了利用彩虹表碰撞的难度。&lt;/p&gt;
&lt;p&gt;摘一段官网&lt;a href="https://www.openldap.org/faq/data/cache/347.html"&gt;FAQ&lt;/a&gt;的perl代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#! /usr/bin/perl&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# This small script generates an Seeded SHA1 hash of &amp;#39;secret&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;# (using the seed &amp;quot;salt&amp;quot;) for use as a userPassword or rootpw value.&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;Digest::SHA1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;MIME::Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$ctx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;Digest::SHA1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;secret&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;salt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$hashedPasswd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#39;{SSHA}&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encode_base64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#39;salt&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#39;userPassword: &amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;$hashedPasswd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;过程很简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;{SSHA}&amp;#39; + base64_encode( SHA1(password + salt) + salt )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以直接使用OpenLDAP 提供的&lt;code&gt;slappasswd&lt;/code&gt; 生成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;slappasswd -h {SSHA} -s password

&amp;#39;{SSHA}0c0blFTXXNuAMHECS4uxrj3ZieMoWImr&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意OpenLDAP SSHA 的salt 长度默认为4个字节。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Python 可以直接用PassLib 这个库，&lt;a href="http://passlib.readthedocs.io/en/stable/lib/passlib.hash.ldap_std.html#passlib.hash.ldap_salted_sha1"&gt;class passlib.hash.ldap_salted_sha1&lt;/a&gt;，简单快捷，也有对应的
verify 函数。&lt;/p&gt;
&lt;p&gt;🌰 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;passlib.hash&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ldap_salted_sha1&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ssha&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;encrypt_password&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ssha&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encrypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;salt_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;verify_password&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;password_hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_user&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ssha&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;verify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;在给&lt;a href="http://walle-web.io"&gt;walle&lt;/a&gt; 添加LDAP 支持的时候，发现无论如何都是用户名和密码不一致，耐心看了下代码，发现作者&lt;a href="https://github.com/meolu/walle-web/blob/03a8d848f398103a097bb79a1c4004062ec83705/models/LdapUser.php#L82,L90"&gt;写错了&lt;/a&gt;，似乎是直接抄的phpldapadmin 的&lt;a href="https://github.com/leenooks/phpLDAPadmin/blob/708bc5ed83cc92f42ec10ae621b39a799c0e3a61/lib/functions.php#L2199,L2209"&gt;代码&lt;/a&gt;🌚🌝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function validatePassword($password) {
    $encryptionType = strstr(substr($this-&amp;gt;_password, 1), &amp;#39;}&amp;#39;, true);
    return self::generate_password($password, $encryptionType) == $this-&amp;gt;_password;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;generate_password&lt;/code&gt; 里面用随机的salt 生成了一个hash，来校验，怎么可能会一样嘛。自己改了本地的代码，提了一个&lt;a href="https://github.com/meolu/walle-web/issues/426"&gt;issue&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;正确的做法应该是取出userPassword 的salt，和用户输入的密码生成hash，再做对比，参考&lt;a href="https://github.com/leenooks/phpLDAPadmin/blob/708bc5ed83cc92f42ec10ae621b39a799c0e3a61/lib/functions.php#L2297,L2313"&gt;case ssha&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="x"&gt;case &amp;#39;ssha&amp;#39;:&lt;/span&gt;
&lt;span class="x"&gt;   # Check php mhash support before using it&lt;/span&gt;
&lt;span class="x"&gt;   if (function_exists(&amp;#39;mhash&amp;#39;)) {&lt;/span&gt;
&lt;span class="x"&gt;       $hash = base64_decode($cryptedpassword);&lt;/span&gt;

&lt;span class="x"&gt;       # OpenLDAP uses a 4 byte salt, SunDS uses an 8 byte salt - both from char 20.&lt;/span&gt;
&lt;span class="x"&gt;       $salt = substr($hash,20);&lt;/span&gt;
&lt;span class="x"&gt;       $new_hash = base64_encode(mhash(MHASH_SHA1,$plainpassword.$salt).$salt);&lt;/span&gt;

&lt;span class="x"&gt;       if (strcmp($cryptedpassword,$new_hash) == 0)&lt;/span&gt;
&lt;span class="x"&gt;           return true;&lt;/span&gt;
&lt;span class="x"&gt;       else&lt;/span&gt;
&lt;span class="x"&gt;           return false;&lt;/span&gt;
&lt;span class="x"&gt;    } else {&lt;/span&gt;
&lt;span class="x"&gt;        error(_(&amp;#39;Your PHP install does not have the mhash() function. Cannot do SHA hashes.&amp;#39;),&amp;#39;error&amp;#39;,&amp;#39;index.php&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;break;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;新的一周又开始咯😆 。&lt;/p&gt;</content><category term="2018"></category><category term="openldap"></category></entry><entry><title>如何搭建一个高匿名的内部论坛</title><link href="https://fangpsh.github.io/posts/2018/2018-04-25.html" rel="alternate"></link><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-04-25:/posts/2018/2018-04-25.html</id><summary type="html">&lt;p&gt;入职腾讯的时候，同学们给我推荐了一个App：&lt;a href="http://tongshiapp.com"&gt;同事&lt;/a&gt;，
这个App 为同事之间提供了匿名交流的平台，各种高压线、污秽色情的信息 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;入职腾讯的时候，同学们给我推荐了一个App：&lt;a href="http://tongshiapp.com"&gt;同事&lt;/a&gt;，
这个App 为同事之间提供了匿名交流的平台，各种高压线、污秽色情的信息络绎不绝，相当刺激。  &lt;/p&gt;
&lt;p&gt;这个App 17年后期就出现HTTPS 证书过期、短信通道欠费收不到短信等问题，看起来要倒闭。有时候在想如果要搭建一个替代品，该如何平衡匿名性，又能验证是腾讯员工，我会怎么做，最后想了一个折中的办法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="tongshiApp" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165344.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前提：员工不信任论坛管理员。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;邮件列表&lt;/h2&gt;
&lt;p&gt;一开始的想法是通过邮件列表，因为邮箱还能匿名注册，而且有各种各样的移动客户端。怎么验证员工身份？无论是工作邮箱发验证码还是什么，只要涉及员工工作邮箱，服务端就有可能记录对应关系。或者通过邀请制度？又感觉不够收敛。做一个网站，只有内网可以访问，然后每日生成邀请码？Bingo，突然想到可以限制注册的来源，限制内网注册即可。&lt;/p&gt;
&lt;h2&gt;Flarum&lt;/h2&gt;
&lt;p&gt;没做邮件列表，基于&lt;a href="http://flarum.org"&gt;Flarum&lt;/a&gt;开始搭建。&lt;/p&gt;
&lt;p&gt;域名：免费的.tk 域名玩一玩，开隐私保护，tongshi.tk。&lt;br&gt;
服务器地址隐藏：cloudflare 免费CDN，全站开启。  &lt;/p&gt;
&lt;p&gt;收集腾讯内网出口的IP 地址范围，三个段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;14.17.22.0/24
103.7.28.0/22
103.7.29.0/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;开启HTTPS 支持，防止在公司内网访问，被中间人监听 🙈  。&lt;/p&gt;
&lt;p&gt;由于使用了CloudFlare 做全站CDN，遇到一个问题，没法校验客户端IP，2个解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;升级CloudFlare 套餐，使用&lt;a href="https://support.cloudflare.com/hc/en-us/articles/115001595131-How-do-I-Lockdown-URLs-in-Cloudflare-"&gt;Zone lockdown&lt;/a&gt;功能。
&lt;img alt="cloudflare_zone_lockdown" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165404.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CloudFlare 会把客户端IP 放在 &lt;code&gt;$http_cf_connecting_ip&lt;/code&gt; 头里面，在Nginx 里面校验一下这个头。参考：&lt;a href="https://support.cloudflare.com/hc/en-us/articles/200170706-How-do-I-restore-original-visitor-IP-with-Nginx-"&gt;How do I restore original visitor IP with Nginx?&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;map $http_cf_connecting_ip $allowed {
    default deny;
    ~\s*14.17.22.*$ allow;
    ~\s*103.7.28.*$ allow;
    ~\s*103.7.29.*$ allow;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试了一下，客户端自己伪造这个头，无效，还是会被CloudFlare 重写为正确的客户端IP。&lt;/p&gt;
&lt;p&gt;安装插件&lt;a href="https://gitlab.com/ReDevelopers/ReFlar/user-management"&gt;reflar/user-management&lt;/a&gt;，关闭邮箱注册。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Disable email registration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在注册接口上限制一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;location /api/reflar/usermanagement/register {
    if ( $allowed = &amp;#39;deny&amp;#39; ) {
        return 403;
    }
    try_files $uri $uri/ /api.php?$query_string;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;搞定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="tongshi-tk" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165416.png"&gt;&lt;/p&gt;
&lt;p&gt;试验一下想法，过三天这台机器就到期，关了。&lt;/p&gt;
&lt;p&gt;总结一下思路，通过办公网出口IP 做注册限制，较宽松的员工认证手段，又保证了一定的匿名性。&lt;/p&gt;
&lt;p&gt;当然如果公司自己愿意做的话，在内网搭就非常简单了。然而这东西对于公司来说是洪水猛兽，审查还来不及。腾讯内网的乐问有匿名发帖功能，然而又有几个人信任匿名的安全性呢。&lt;/p&gt;</content><category term="2018"></category><category term="flarum"></category></entry><entry><title>记一次无比心累的个税申报过程</title><link href="https://fangpsh.github.io/posts/2018/2018-03-20.html" rel="alternate"></link><published>2018-03-20T00:00:00+08:00</published><updated>2018-03-20T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-03-20:/posts/2018/2018-03-20.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;自2006年1月1日起，在一个纳税年度内取得个人所得税法中规定的“工资、薪金所得”、“个体工商户的生产、经营所得”、“对企事业单位的承包经 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;自2006年1月1日起，在一个纳税年度内取得个人所得税法中规定的“工资、薪金所得”、“个体工商户的生产、经营所得”、“对企事业单位的承包经营、承租经营所得”、“劳务报酬所得”等11项应税所得合计数额达到12万元以上的纳税人，应在纳税年度终了后三个月内，向主管税务机关办理自行纳税申报的相关事宜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;城市服务-深圳地税服务&lt;/h2&gt;
&lt;p&gt;腾讯的HR 每日催着我们申报个税，一开始说是可以在微信钱包-城市服务-深圳地税服务 中进行申报，可是输入身份证和姓名之后，总是提示实名验证不通过，查询内网论坛发现大家都这样，行政同学解释：由于招行的接口问题，返回的信息没身份证信息，所以实名认证不通过，需要微信钱包绑定非招行卡才行。&lt;/p&gt;
&lt;p&gt;然后开始倒腾了，解绑招行卡，留建行、中行，也还是不行。怒！&lt;/p&gt;
&lt;h2&gt;深圳地税公众号-自助办税&lt;/h2&gt;
&lt;p&gt;逛逛内网，发现有同事说可以关注：“深圳地税” 公众号，点击“自助办税”-“个人中心” 进行操作。跳转到开户绑定，填写完信息之后，提示我的身份证信息已经登记在册。。。无法绑定，吐血！&lt;/p&gt;
&lt;h2&gt;电子税务局&lt;/h2&gt;
&lt;p&gt;最后只能试一试地税官网-&lt;a href="https://dzswj.szds.gov.cn/dzswj/"&gt;电子税务局&lt;/a&gt;，IE 10 打开这网站，页面卡死，屡试不爽，启用兼容视图，还是一打开就卡死，给跪！内网逛逛，发现有同事说QQ 浏览器好使，遂怒下安装，打开，果然好使！然而好戏才刚刚开始。。&lt;/p&gt;
&lt;p&gt;选择自然人用户标签，点击“我要开通”，填写信息，弹出页面，跳转到“深圳金融电子结算中心”的认证网关，输入银行的预留手机号，170xxxx，咦，收不到验证码，拔插拔插一下，还是不行？奇怪。。换一个手机号，185xxxx，咦，可以了收到验证码了！可是这个手机号不是我预留的，只是一张“流量卡”。&lt;br&gt;
打12366 客服，描述问题，“甩锅”，让我添加他们的技术QQ：“800012366”。&lt;br&gt;
工号1014 为我服务，描述问题，“甩锅”，“这不是地税的问题，是深圳金融电子结算中心”的问题，听起来没毛病，“能帮我反馈一下这个问题吗”，“不能，不是地税的问题”，mmp。  &lt;/p&gt;
&lt;p&gt;打阿里通信的客服电话10029，描述问题，
“阿里通信只支持淘宝、微博，还有个啥，三个平台，其他平台不保证支持”。。。。&lt;br&gt;
上了贼床了。&lt;/p&gt;
&lt;p&gt;自己研究一下请求：&lt;br&gt;
&lt;img alt="szfesc" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302151313.png"&gt;&lt;/p&gt;
&lt;p&gt;猜测发送验证码接口的短信网关，170 等虚拟运营商的发送失败。地税局的网站跳转到认证网关的时候，会带一个merChikBillSn 号，认证网关这边对这个merChikBillSn 进行认证通过之后，才能在地税局那边进行开通。这个认证的接口：&lt;br&gt;
&lt;code&gt;wyzf-gateway/RealNameVerification/checkConfim&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;merChkBillSn
acctID
phoneNm
smsCodeId
smsCodeValue
banType
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;认证网关会校验银行卡和预留的手机号（phoneNm）是否一致，同时会校验smsCodeId 和 smsCodeValue 是否匹配正确，嘿嘿，它不会校验smsCodeId 对应的手机号是否和phoneNm 一致，所以可以简单的绕过，用一个三大运营商的手机号，得到一个smsCodeId 和验证码，然后再构造请求即可。&lt;/p&gt;
&lt;p&gt;可惜乌云不在了，不然还能去报个漏洞。&lt;/p&gt;
&lt;p&gt;兴高采烈，认证通过，回去填写开通信息，然而我还是太年轻。&lt;/p&gt;
&lt;p&gt;填写电话，地址，点击开通！ &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“身份证号码对应的自然人登记信息已存在”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无法开通。。。。和前面在公众号里面开通绑定的提示一样，吐血。&lt;/p&gt;
&lt;p&gt;再怒打客服电话，又被甩到技术客服QQ，描述问题，建议我找回密码。  &lt;/p&gt;
&lt;p&gt;去页面上找回密码，输入信息，提示“还没有开通自然人电子税务局”，什么鬼。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“提供一下你的姓名和身份证”。   &lt;/li&gt;
&lt;li&gt;“你的信息企业登记错误”，我的名字被打错了。。。 &lt;/li&gt;
&lt;li&gt;“去前台更正信息，开通吧”  ，吐血。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;南山地税局&lt;/h2&gt;
&lt;p&gt;取号，A类，前面还有23人，领表，填写。&lt;br&gt;
等吧，逛逛： 那个女的怎么在玩手机，不叫号， 那个胖子在干嘛，怎么不叫号。&lt;/p&gt;
&lt;p&gt;和咨询台小妹吐槽，怎么这么慢，被反问怎么不在微信里操作，答没操作成功，你们做的问题太多，被反怼：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“那个是你们腾讯做的” （上班路上，戴着工牌）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;半小时后，终于等到了，16号小姐姐，了解清楚情况之后，先把个税申报做了，然后帮我开通电子税务局，操作几次，失败。
以为170 手机号不行，换185，也不行。
小姐姐呼叫另外一个小姐姐支援，还是不行，几番电话联系后台服务人员，说我的信息录入错误，需要更正。让我留一个手机号，回去等消息，回去等，流程很慢。&lt;/p&gt;
&lt;p&gt;怒怼：不行，请马上处理。
声调有点高，引来一个男的，一个女阿姨，和我对战：“你们腾讯自己的问题，信息录错了”。
拒绝，不想再跑一趟，另外一个小姐姐打了几个电话，提交工单，做信息更正。十分钟后，搞定！&lt;/p&gt;
&lt;p&gt;联系HR8008，反应+吐槽，HR 小姐姐说检查了，没发现登记有误。。算了。&lt;/p&gt;
&lt;p&gt;到公司，已经快11点。耗费2小时，orz。&lt;/p&gt;</content><category term="2018"></category><category term="hack"></category></entry><entry><title>《HTTP/2 基础教程》读书笔记</title><link href="https://fangpsh.github.io/posts/2018/2018-02-06.html" rel="alternate"></link><published>2018-02-06T00:00:00+08:00</published><updated>2018-02-06T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-02-06:/posts/2018/2018-02-06.html</id><summary type="html">&lt;p&gt;&lt;img alt="http2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230227141517.jpg"&gt;&lt;/p&gt;
&lt;p&gt;最近拿到一本新书：&lt;a href="https://book.douban.com/subject/27665112/"&gt;《HTTP/2 基础教程》&lt;/a&gt;，薄薄一本，除去附录100页不到，卖的挺贵，49元。《精通正则表达式》的译者余晟为这书写了序，也在他的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="http2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230227141517.jpg"&gt;&lt;/p&gt;
&lt;p&gt;最近拿到一本新书：&lt;a href="https://book.douban.com/subject/27665112/"&gt;《HTTP/2 基础教程》&lt;/a&gt;，薄薄一本，除去附录100页不到，卖的挺贵，49元。《精通正则表达式》的译者余晟为这书写了序，也在他的个人公众号上推荐，读完却觉得作为基础教程还不错，翻译上觉得略生硬。作点简单的笔记，方便以后“按图索骥”。&lt;/p&gt;
&lt;h2&gt;3.1.2 关键性能指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;延迟&lt;ul&gt;
&lt;li&gt;延迟是制约Web 性能的主要瓶颈，后文还会提到，丢包会严重影响HTTP/2 的性能&lt;/li&gt;
&lt;li&gt;这就是为什么CDN 的边缘节点要近可能的靠近目标用户，做到本地覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带宽&lt;ul&gt;
&lt;li&gt;带宽可能会成为性能的瓶颈，不过对于普通的网页，目前大多数用户的带宽已经不是瓶颈，延时和丢包更加重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 查询&lt;ul&gt;
&lt;li&gt;网址的域名解析，网页内各项资源的域名解析时间，这块查询时间占比较大，特别是在移动端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立连接的时间&lt;ul&gt;
&lt;li&gt;TCP 三次握手&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TLS 协商时间&lt;ul&gt;
&lt;li&gt;采用HTTPS 之后，TLS 握手，TLS 1.2 需要消耗2个RTT，不过新的TLS1.3 只需要1个RTT。&lt;/li&gt;
&lt;li&gt;针对TLS 有非常多的优化手段，建议阅读&lt;a href="https://book.douban.com/subject/25856314/"&gt;《Web 性能权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;首字节时间（TTFB）&lt;ul&gt;
&lt;li&gt;客户端开始访问网页，到收到服务器响应的第一个字节的时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内容下载时间&lt;ul&gt;
&lt;li&gt;从客户端开始访问，到最后一个响应字节到达客户端的时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始渲染时间&lt;ul&gt;
&lt;li&gt;用户看到空白页面的时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文档加载完成时间（又叫页面加载时间）&lt;ul&gt;
&lt;li&gt;浏览器认为页面加载完毕的时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;互联网发展，遇到的挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的字节：页面资源的体积变大&lt;/li&gt;
&lt;li&gt;更多的资源：页面资源数量变多&lt;/li&gt;
&lt;li&gt;更高的复杂度： 页面越来越复杂，渲染变长&lt;/li&gt;
&lt;li&gt;更多的域名： 一个页面包含的域名越来越多，增加了DNS 查询耗时、建立连接耗时、TLS 协商耗时。&lt;/li&gt;
&lt;li&gt;更多的TCP socket：浏览器会对同一个域名开启多个连接，这增加了服务器协商耗时，加重设备负担，有可能导致网络过载等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.1.3 HTTP/1 的问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;队头堵塞&lt;ul&gt;
&lt;li&gt;HTTP/1 有个特性叫管道化（pipelining），允许一次发送一组请求，当时只能按照发送顺序依次接收请求，&lt;/li&gt;
&lt;li&gt;在应答过程中，如果有一个请求阻塞了，后续所有工作都会被阻塞。现代浏览器会对单个域名开启6个连接，当时每个连接还是会受到“队头阻塞”的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;低效的TCP 利用&lt;ul&gt;
&lt;li&gt;拥塞控制算法，慢启动，以及拥塞避免，TCP 并不高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;臃肿的消息首部&lt;ul&gt;
&lt;li&gt;HTTP/1 消息头部无法被压缩，如果再带上cookies，有个几千字节很常见。大量请求下，消息头的占比不可忽视。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;受限的优先级设置&lt;ul&gt;
&lt;li&gt;处理高优先级的资源时，不会对低优先级的资源发起请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三方资源&lt;ul&gt;
&lt;li&gt;日益增多的第三方资源引用，消耗了大量资源。HTTP/2 对此也束手无策。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.2.1 Web 性能的最佳实践&lt;/h2&gt;
&lt;h3&gt;1. DNS 查询优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限制不同域名的数量。&lt;/li&gt;
&lt;li&gt;保证低限度的解析延迟，定期监控用户分布所有地区的解析时间。&lt;/li&gt;
&lt;li&gt;在主体页面HTML 活响应中利用&lt;a href="https://www.w3.org/TR/resource-hints/#dns-prefetch"&gt;DNS 预取命令&lt;/a&gt;。
 例：
 &lt;code&gt;&amp;lt;link rel="dns-prefetch" hrefp="//ajax.googleapis.com"&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 优化TCP 连接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;利用&lt;a href="https://www.w3.org/TR/resource-hints/#preconnect"&gt;preconnect&lt;/a&gt; 指令。
 例：
 &lt;code&gt;&amp;lt;link rel="preconnect" href="//fonts.example.com" crossorigin&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽早终止并响应，借助CDN，降低RTT，尽快响应。&lt;/li&gt;
&lt;li&gt;实施最新的&lt;a href="https://istlsfastyet.com/"&gt;TLS 最佳实践&lt;/a&gt;来优化HTTPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 避免重定向&lt;/h3&gt;
&lt;p&gt;重定向通常会触发与额外域名建立连接，简单的解决方案就是彻底消灭重定向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用CDN 代替客户端在云端实现重定向，意思就是让CDN 重定向去取回资源再返回给客户端。&lt;/li&gt;
&lt;li&gt;如果是同一域名的重定向，利用Web 服务器上的rewrite 规则，避免重定向。例如Nginx、Apache 里面的rewrite，客户端无需再发起一次请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 客户端缓存&lt;/h3&gt;
&lt;p&gt;客户端直接使用本地缓存是最快的。建议所有的静态资源名称都带上一个随机的ID，然后给一个超长的缓存时间即可。部分需要更新的资源，可以按需调整缓存时间。&lt;/p&gt;
&lt;h3&gt;5. 网络边缘的缓存&lt;/h3&gt;
&lt;p&gt;利用CDN，缓存部分数据。如果一份资源需要缓存，它必须满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多用户间可共享，并且&lt;/li&gt;
&lt;li&gt;能够接受一定程度的旧数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户的隐私信息、以及贵时间敏感的内容都不可以缓存。&lt;/p&gt;
&lt;h3&gt;6. 条件缓存&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;Last-Modified-Since&lt;/code&gt;，&lt;code&gt;ETag&lt;/code&gt; 等头部检查服务端资源更新情况，如果没更新，服务端返回304，否则返回新的资源。&lt;/p&gt;
&lt;h3&gt;7. 压缩和代码极简化&lt;/h3&gt;
&lt;p&gt;去除前端代码里面多余的注释、空格、换行，牺牲可读性降低体积，再通过gzip、deflate、Brotli等算法压缩传输。&lt;/p&gt;
&lt;h3&gt;8. 避免阻塞CSS/JS&lt;/h3&gt;
&lt;p&gt;CSS 要放在head 标签里，在任何JS 和图片前面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定期校验JS 资源的使用情况，清楚不再需要的资源。&lt;/li&gt;
&lt;li&gt;如果JS 执行顺序无关紧要，并且必须在onload 事件触发之前运行，可以设置&lt;a href="http://caniuse.com/#search=async"&gt;async 属性&lt;/a&gt;，
 例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &amp;lt; script async src=&amp;quot;/js/myfile.js&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;如果JS 执行顺序很重要，并且也能接受脚本在DOM 加载完之后运行，可以使用defer 属性，
 例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &amp;lt;script defer src=&amp;quot;/js/myjs.js&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;对于不行影响到页面初次展示的JS脚本，必须在onload 事件触发之后请求（处理）它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;9. 图片优化&lt;/h3&gt;
&lt;p&gt;图片越来越多，针对图片的2条优化建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除图片元信息，例如题材、地理信息、时间戳、尺寸和像素信息等。&lt;/li&gt;
&lt;li&gt;针对不同设备提供不同尺寸的图片，另外例如七牛、又拍云等CDN 厂商都提供图片处理服务，使用起来简单快捷。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于图片优化可以阅读书籍：&lt;a href="http://shop.oreilly.com/product/0636920039730.do"&gt;《High Performance Images》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之前也整理过一篇：[[../2017/170608 图片优化笔记]]。&lt;/p&gt;
&lt;h2&gt;3.2.2 反模式&lt;/h2&gt;
&lt;h2&gt;4.3 撤销针对HTTP/1.1 的优化&lt;/h2&gt;
&lt;h2&gt;6.7 HTTP/2 反模式&lt;/h2&gt;
&lt;p&gt;一些在HTTP/1.X 上使用的优化手段，若应用到HTTP/2 上，会适得其反，书里有三个地方都提到了“反模式”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成精灵图和资源合并/内联：对于HTTP/2 来说，使用精灵图没有意义。也不要将资源进行合并，缓存控制上会不方便，粒度太粗。&lt;/li&gt;
&lt;li&gt;域名拆分：迁移到HTTP/2 需要收拢域名。&lt;/li&gt;
&lt;li&gt;禁用cookie的域名：HTTP/2 中，头部信息会被压缩，无需再对特定域名禁用cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="null" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230227141750.png"&gt;&lt;/p&gt;
&lt;h2&gt;5. HTTP/2 协议&lt;/h2&gt;
&lt;p&gt;第五章介绍了HTTP/2 协议的一些细节，帧结构、流、流量控制、优先级、服务端推送、首部压缩等内容，内容很多，每一块要理解透彻内容很多，具体还是得看书，外加查询其他资料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/web/fundamentals/performance/ht你tp2/?hl=zh-cn"&gt;HTTP/2 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/creeperyang/blog/issues/23"&gt;HTTP2简介和基于HTTP2的Web优化 #23&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.blogjava.net/yongboy/archive/2015/03/20/423655.html"&gt;HTTP/2笔记之帧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://imququ.com/post/header-compression-in-http2.html"&gt;HTTP/2 头部压缩技术介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.blogjava.net/yongboy/archive/2015/03/19/423611.html"&gt;HTTP/2笔记之流和多路复用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.gae999cde7_0_167"&gt;HTTP2 is here, let's optimize!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://http2.github.io/http2-spec/"&gt;Hypertext Transfer Protocol Version 2 (HTTP/2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6. HTTP/2 性能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;并非所有请求在任何情况下都会从HTTP/2 受益；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟：超过一定带宽之后（实验值是5Mbit/s ），增加带宽不会减少延迟，RTT 对性能的影响更新敏感；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丢包：丢包对HTTP/2 影响非常大，因为一个域名就一个连接。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;性能优化因人而异&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注重测试，要遵循业界推荐的方式，但也不要陷入过早优化的陷阱，应当让数据为你的优化指引方向。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;8. HTTP/2 调试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Chrome 开发者工具&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chrome://net-internals&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inspect -&amp;gt; Network&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Firefox 开发者工具&lt;/li&gt;
&lt;li&gt;iOS：Charles Proxy&lt;/li&gt;
&lt;li&gt;Android：手机端-开发者模式-USB调试（USB debugging），PC-Chrome-开发者工具-Remote devices&lt;/li&gt;
&lt;li&gt;WebPagetest&lt;/li&gt;
&lt;li&gt;OpenSSL&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nghttp2.org"&gt;nghttp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -v --http2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bradfitz/http2/tree/master/h2i"&gt;h2i&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wireshark&lt;/li&gt;
&lt;/ul&gt;</content><category term="2018"></category><category term="http"></category><category term="book"></category></entry><entry><title>Nginx 监控</title><link href="https://fangpsh.github.io/posts/2018/2018-01-30.html" rel="alternate"></link><published>2018-01-30T00:00:00+08:00</published><updated>2018-01-30T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-01-30:/posts/2018/2018-01-30.html</id><summary type="html">&lt;p&gt;&lt;img alt="nginx" src="https://nginx.org/nginx.png"&gt;&lt;/p&gt;
&lt;p&gt;前年读过&lt;a href="https://www.scalyr.com/community/guides"&gt;Scalyr&lt;/a&gt; 几篇关于监控的文章，写得挺细致，今天翻收藏夹又发现这个链接，顺便整理一下，主要参考以下2 篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.scalyr.com/community/guides/how-to-monitor-nginx-the-essential-guide"&gt;How to …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="nginx" src="https://nginx.org/nginx.png"&gt;&lt;/p&gt;
&lt;p&gt;前年读过&lt;a href="https://www.scalyr.com/community/guides"&gt;Scalyr&lt;/a&gt; 几篇关于监控的文章，写得挺细致，今天翻收藏夹又发现这个链接，顺便整理一下，主要参考以下2 篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.scalyr.com/community/guides/how-to-monitor-nginx-the-essential-guide"&gt;How to Monitor Nginx: The Essential Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.scalyr.com/community/guides/an-in-depth-guide-to-nginx-metrics"&gt;An In-Depth Guide to Nginx Metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;stub_status&lt;/h2&gt;
&lt;p&gt;参考&lt;a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html"&gt;ngx_http_stub_status_module&lt;/a&gt; 配置&lt;code&gt;stub_status&lt;/code&gt;，访问配置好的路径，看到的页面内容如下（如果是Tengine 还会有&lt;code&gt;request_time&lt;/code&gt; 等）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Active connections: 291
server accepts handled requests
16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;active connections&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Active = Reading + Writing + Waiting
291    = 6       + 179     + 106
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三种连接状态的解释如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Reading
    Nginx 在读取请求头信息
Writing
    Nginx 在发送响应信息给客户端
Waiting
    空闲的连接。
    2种情况会出现Waiting 的连接：
    1.Nginx 读取完请求，还未发送响应信息之前；
    2.发送完响应信息，等待下一个请求时，HTTP 1.1 的keep-alive 常常会出现这种情况。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这4 个值都应该采集，当 active connection 接近于  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阈值：&lt;a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections"&gt;worker_connections&lt;/a&gt; * &lt;a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes"&gt;worker_processes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;触发报警。&lt;/p&gt;
&lt;h3&gt;accepts，handled，requests，dropped&lt;/h3&gt;
&lt;p&gt;accepts 是Nginx 累积接受的连接数，handled 是累计处理完成的连接数。这2个数值一般相等，但是偶尔会发现
handled 值略小于accepts，这说明有一部分请求被dropped：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dropped = accepts - handled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;出现dropped 可能是因为达到Nginx 的处理极限，或者用户配置的限制，参考上文active connection 的报警阈值。应该采集accepts 和handled 的值，监控它们之间的差值。&lt;/p&gt;
&lt;p&gt;requests 常常比accpts 大好几倍，因为一个连接可能产生多个请求，可以通过采集requests，求出一定时间之内的差值，得到当前的RPS（Requests Per Second），每秒请求数，当请求数暴涨时（活动流量突发，被攻击等情况）能及时发现。&lt;/p&gt;
&lt;h3&gt;nginx-moduls-vts&lt;/h3&gt;
&lt;p&gt;Nginx 自带的stub_status 比较简陋，可以考虑加入模块：&lt;a href="https://github.com/vozlt/nginx-module-vts"&gt;nginx-module-vts&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-module-vts" src="https://cloud.githubusercontent.com/assets/3648408/23890539/a4c0de18-08d5-11e7-9a8b-448662454854.png"&gt;&lt;/p&gt;
&lt;p&gt;上图看到的这些值，都可以通过模块提供的接口采集到，绘图、监控，具体参考模块的&lt;a href="https://github.com/vozlt/nginx-module-vts/blob/master/README.md"&gt;README.md&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;日志&lt;/h2&gt;
&lt;h3&gt;访问日志（access.log）&lt;/h3&gt;
&lt;p&gt;访问日志中最重要的就是监控HTTP 状态码&lt;code&gt;$status&lt;/code&gt;，1xx，2xx，3xx，4xx，5xx。按时间段切割计算上报。5xx 大家肯定会重视，不过3xx 和4xx 也需要注意，都是血的教训。&lt;br&gt;
由于需要监控4xx 和3xx，要和业务沟通清楚，不要把业务状态码和HTTP 状态码混在一起。例如用户抽奖的请求，没中奖都返回404，误报严重。&lt;/p&gt;
&lt;p&gt;另外还可以采集日志中的&lt;code&gt;$upstream_response_time&lt;/code&gt;，&lt;code&gt;$request_time&lt;/code&gt; 等数值，一段时间内出现响应时间次数大于某个阈值，报警，可以及时发现后端服务异常、过载等情况。&lt;/p&gt;
&lt;p&gt;更进一步，就是用&lt;a href="https://www.fluentd.org"&gt;fluentd&lt;/a&gt;收集访问日志，采用&lt;a href="https://www.elastic.co/products"&gt;ELK&lt;/a&gt; 、&lt;a href="https://www.graylog.org"&gt;Graylog&lt;/a&gt;等做更细致的分析。&lt;/p&gt;
&lt;h3&gt;错误日志（error.log）&lt;/h3&gt;
&lt;p&gt;Nginx 的错误日志非常重要，我之前的做法是超过N 条就报警。由于error.log 的内容类型非常多，监控脚本需要过滤掉常见的、已知的错误。报警阈值尽量小，当有意想不到的错误出现时，能及时发现。&lt;/p&gt;
&lt;h2&gt;进程&lt;/h2&gt;
&lt;p&gt;在前公司的时候，有一回同事通过&lt;code&gt;salt cmd.run&lt;/code&gt; 远程重启了Nginx，跑了一段时间之后，error.log 狂刷日志，发现进程的&lt;code&gt;Max open files&lt;/code&gt;是1024。先不提如何避免这种情况，方法很多，但是监控还是可以加上。&lt;/p&gt;
&lt;p&gt;ps 过滤出Nginx 进程们的PID，再通过以下命令拿到进程的&lt;code&gt;Max open files&lt;/code&gt; 值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat /proc/{PID}/limit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将得到的值 和设定的值对比，不匹配即报警。&lt;/p&gt;
&lt;p&gt;Nginx 是多进程模型，监控下进程状态，当有异常发生时能更快的发现，进程若处于&lt;code&gt;D&lt;/code&gt;，&lt;code&gt;Z&lt;/code&gt;，&lt;code&gt;X&lt;/code&gt;，&lt;code&gt;T&lt;/code&gt;等状态需要注意。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU 各项指标（sys,idle,iowait,si...）&lt;/li&gt;
&lt;li&gt;系统负载（load)&lt;/li&gt;
&lt;li&gt;磁盘IO&lt;/li&gt;
&lt;li&gt;磁盘空间&lt;/li&gt;
&lt;li&gt;网卡流量、包量&lt;/li&gt;
&lt;li&gt;全连接队列、半连接队列溢出监控&lt;ul&gt;
&lt;li&gt;&lt;code&gt;netstat -s&lt;/code&gt;："SYNs to LISTEN sockets dropped”，"times the listen queue of a socket overflowed"&lt;/li&gt;
&lt;li&gt;参考&lt;a href="http://jm.taobao.org/2017/05/25/525-1/"&gt;关于TCP 半连接队列和全连接队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;域名过期监控，需要注意域名服务商或者DNSPod 之类的警告邮件，或者写个脚本whois 定期查询，或者设个日历、闹钟&lt;/li&gt;
&lt;li&gt;SSL 证书有效期监控，可以自己写个脚本监控，使用&lt;code&gt;openssl&lt;/code&gt;命令，或者用下面这些在线服务：&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.sslcloud.cn"&gt;SSL Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://certificatemonitor.org"&gt;Certificate Expiry Monitor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定期&lt;code&gt;nginx -t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.datadoghq.com/blog/how-to-monitor-nginx/"&gt;How to monitor NGINX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2018"></category><category term="nginx"></category></entry><entry><title>drop_caches</title><link href="https://fangpsh.github.io/posts/2018/2018-01-25.html" rel="alternate"></link><published>2018-01-25T00:00:00+08:00</published><updated>2018-01-25T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-01-25:/posts/2018/2018-01-25.html</id><summary type="html">&lt;p&gt;&lt;img alt="atemyram" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228184158.png"&gt;
&lt;a href="https://www.linuxatemyram.com"&gt;Don't Panic! Your ram is fine!&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;问题排查&lt;/h2&gt;
&lt;p&gt;一台机器的CPU iowait 非常高，perf 分析发现耗时都在&lt;code&gt;isolate_freepages_block&lt;/code&gt; 函数，iostat 看系统盘的iops 也达到瓶颈，free 查看机器内 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="atemyram" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228184158.png"&gt;
&lt;a href="https://www.linuxatemyram.com"&gt;Don't Panic! Your ram is fine!&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;问题排查&lt;/h2&gt;
&lt;p&gt;一台机器的CPU iowait 非常高，perf 分析发现耗时都在&lt;code&gt;isolate_freepages_block&lt;/code&gt; 函数，iostat 看系统盘的iops 也达到瓶颈，free 查看机器内存 buff/cache 占了很大一部分，free 快没了。网友的类似状况： &lt;a href="http://www.yangguanjun.com/2016/09/12/ceph-node-high-workload-issue/"&gt;Ceph节点load很高问题的分析解决&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;程序对文件系统大量的随机读写，&lt;a href="https://en.wikipedia.org/wiki/Page_cache"&gt;page cache&lt;/a&gt; 上涨，内存吃紧，page cache 不断换入换出，磁盘瓶颈，CPU 堵住。&lt;/p&gt;
&lt;p&gt;可以临时drop 掉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;想要也释放脏页，先执行&lt;code&gt;sync&lt;/code&gt;，再drop。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a non-destructive operation and will not free any dirty objects.
To increase the number of objects freed by this operation, the user may run
`sync' prior to writing to /proc/sys/vm/drop_caches.  This will minimize the
number of dirty objects on the system and create more candidates to be
dropped.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一种类似的情况是reclaimable slab objects 占用高（dentries，inodes），分析过程可参考：&lt;a href="http://colobu.com/2017/03/07/what-is-in-linux-cached/"&gt;谁吃了我的Linux内存?&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo 2 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解决方法，换大内存机器，或者慢慢调整系统的&lt;code&gt;proc/sys/vm/pagecache_limit*&lt;/code&gt; 等参数，还有文件系统的&lt;code&gt;/proc/sys/vm/dirty_*&lt;/code&gt;，没太多经验，瞎子过河。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;To free pagecache:
echo 1 &amp;gt; /proc/sys/vm/drop_caches
To free reclaimable slab objects (includes dentries and inodes):
echo 2 &amp;gt; /proc/sys/vm/drop_caches
To free slab objects and pagecache:
echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认值是0，写入1 drop pagecache，写入2 drop reclaimable slab objects，写入3 都释放。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;linux/fs/drop_caches.c&lt;/h2&gt;
&lt;h3&gt;问题一：echo 写入之后，值不会变，怎么办？会不会一直在drop？&lt;/h3&gt;
&lt;p&gt;不会，看看代码：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/torvalds/linux/blob/master/fs/drop_caches.c#L39"&gt;linux/fs/drop_caches.c&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;drop_caches_sysctl_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;ctl_table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loff_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ppos&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;proc_dointvec_minmax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ppos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stfu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_drop_caches&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;iterate_supers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;drop_pagecache_sb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;count_vm_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DROP_PAGECACHE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_drop_caches&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;drop_slab&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;count_vm_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DROP_SLAB&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stfu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;pr_info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s (%d): drop_caches: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;task_pid_nr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;sysctl_drop_caches&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;stfu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sysctl_drop_caches&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;write 为True 的时候，才会执行drop 。&lt;/p&gt;
&lt;p&gt;另外&lt;a href="https://www.fsl.cs.sunysb.edu/kernel-api/re449.html"&gt;proc_dointvec_minmax()&lt;/a&gt; 这个函数的作用是检查传入的值符合大小，drop_cache 允许的值是1，2，3，4。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reads/writes up to table-&amp;gt;maxlen/sizeof(unsigned int) integer values from/to the user buffer, treated as an ASCII string.&lt;br&gt;
This routine will ensure the values are within the range specified by table-&amp;gt;extra1 (min) and table-&amp;gt;extra2 (max).&lt;br&gt;
Returns 0 on success.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/torvalds/linux/blob/2ce079f04d5914dae14fdc8618f804cc0d2a1b8f/kernel/sysctl.c#L1399,L1407"&gt;linux/kernel/sysctl.c&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;procname&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;drop_caches&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sysctl_drop_caches&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;maxlen&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mo"&gt;0644&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proc_handler&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop_caches_sysctl_handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra1&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extra2&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然默认值是0，但是如果你尝试写回0，是会失败的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-&amp;gt; echo 0 &amp;gt; /proc/sys/vm/drop_caches
echo: write error: invalid argument
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外可以看到&lt;code&gt;sysctl_drop_caches&lt;/code&gt; 为3(11b) 时，和1，2 做&amp;amp; 操作，都为True，所以都会drop。&lt;/p&gt;
&lt;h3&gt;问题二：echo 写入4，是什么效果？&lt;/h3&gt;
&lt;p&gt;4(100b)，和1，2做&amp;amp; 操作，都为False，所以不会drop，相当于关闭了drop 功能。&lt;/p&gt;
&lt;p&gt;stfu 为静态变量，第一次执行之后，stfu 为4，&lt;code&gt;if (!stfu)&lt;/code&gt; 也始终为False。不过感觉这里有个问题，echo 4 一次之后，stfu 会始终为4，即使再echo 1|2|3，都无法改变，虽然能正常drop，但是pr_info 语句无法执行，dmesg 看不到日志，除非重启。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;stfu |= sysctl_drop_caches &amp;amp; 4;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hoytech.com/vmtouch/"&gt;vmtouch - the Virtual Memory Toucher&lt;/a&gt;，这个工具非常好用&lt;/li&gt;
&lt;li&gt;&lt;a href="http://linuxperf.com/?p=142"&gt;/PROC/MEMINFO之谜&lt;/a&gt;，这篇文章对系统内存介绍的非常详细&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和这篇笔记主题无关的一个问题，也值得深究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaseywang.me/2012/10/21/numa-在-db-上的一些问题/"&gt;NUMA 在 DB 上的一些问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cenalulu.github.io/linux/numa/"&gt;NUMA架构的CPU -- 你真的用好了么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zhangliyong.github.io/posts/2014/04/09/mongodb-numa-dao-zhi-de-xing-neng-wen-ti.html"&gt;Mongodb NUMA 导致的性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"&gt;kernel.org/doc/Documentation/sysctl/vm.txt&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;drop_caches

Writing to this will cause the kernel to drop clean caches, as well as
reclaimable slab objects like dentries and inodes.  Once dropped, their
memory becomes free.

To free pagecache:
echo 1 &amp;gt; /proc/sys/vm/drop_caches
To free reclaimable slab objects (includes dentries and inodes):
echo 2 &amp;gt; /proc/sys/vm/drop_caches
To free slab objects and pagecache:
echo 3 &amp;gt; /proc/sys/vm/drop_caches

This is a non-destructive operation and will not free any dirty objects.
To increase the number of objects freed by this operation, the user may run
`sync&amp;#39; prior to writing to /proc/sys/vm/drop_caches.  This will minimize the
number of dirty objects on the system and create more candidates to be
dropped.

This file is not a means to control the growth of the various kernel caches
(inodes, dentries, pagecache, etc...)  These objects are automatically
reclaimed by the kernel when memory is needed elsewhere on the system.

Use of this file can cause performance problems.  Since it discards cached
objects, it may cost a significant amount of I/O and CPU to recreate the
dropped objects, especially if they were under heavy use.  Because of this,
use outside of a testing or debugging environment is not recommended.

You may see informational messages in your kernel log when this file is
used:

cat (1234): drop_caches: 3

These are informational only.  They do not mean that anything is wrong
with your system.  To disable them, echo 4 (bit 3) into drop_caches.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2018"></category><category term="linux"></category></entry><entry><title>关于Bash 你需要知道的十件事</title><link href="https://fangpsh.github.io/posts/2018/2018-01-22.html" rel="alternate"></link><published>2018-01-22T00:00:00+08:00</published><updated>2018-01-22T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-01-22:/posts/2018/2018-01-22.html</id><summary type="html">&lt;p&gt;读到一篇文章&lt;a href="https://zwischenzugs.com/2018/01/06/ten-things-i-wish-id-known-about-bash/"&gt;《Ten Things I Wish I’d Known About bash》&lt;/a&gt;，所以有了这个畅销书式的标题，一些笔记。&lt;br&gt;
感觉作者写这本书主要是为了推销他的新 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;读到一篇文章&lt;a href="https://zwischenzugs.com/2018/01/06/ten-things-i-wish-id-known-about-bash/"&gt;《Ten Things I Wish I’d Known About bash》&lt;/a&gt;，所以有了这个畅销书式的标题，一些笔记。&lt;br&gt;
感觉作者写这本书主要是为了推销他的新书&lt;a href="https://leanpub.com/learnbashthehardway"&gt;《Learn Bash the Hard Way》&lt;/a&gt;，不过其中十个关于Bash 的点，倒是挺有趣。&lt;/p&gt;
&lt;h2&gt;1) ` ` vs $()&lt;/h2&gt;
&lt;p&gt;这2个符号的效果一样，它们包含的内容都会被执行，然后再把结果赋值给变量，或者传递给其他命令，很常用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo `ls`
$ echo $(ls)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我个人常用&lt;code&gt;` `&lt;/code&gt;，$() 不常用，它们2个有啥区别呢？看个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo `echo \`echo \\\`echo inside\\\`\``

$ echo $(echo $(echo $(echo inside)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2条语句效果一样，不过后者可读性明显好太多，以后写这种嵌套命令的时候，用&lt;code&gt;$()&lt;/code&gt;吧，不然debug 起来得瞎眼。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://mywiki.wooledge.org/BashFAQ/082"&gt;Why is $(...) preferred over `...` (backticks)?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/4708549/what-is-the-difference-between-command-and-command-in-shell-programming"&gt;What is the difference between $(command) and `command` in shell programming?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有个小插曲，我不知道怎么用Markdown 写出反引号（backticks）内一对反引号的效果: &lt;code&gt;` `&lt;/code&gt; ，发了一条tweet，得到了答案，这个符号好像也可以叫：&lt;a href="https://en.wikipedia.org/wiki/Double_grave_accent"&gt;grave accent&lt;/a&gt;，沉音符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;`` ` ` `` 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2) 通配符 vs 正则表达式&lt;/h2&gt;
&lt;p&gt;这2个是完全不一样的东西，不懂作者说容易搞混。。。作者给的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;#输出目录下所有的文件&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;ls&lt;span class="w"&gt; &lt;/span&gt;*

&lt;span class="c1"&gt;#输出目录下所有以. 开头的文件，是通配符，不是正则&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;ls&lt;span class="w"&gt; &lt;/span&gt;.*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3) 返回码（Exit Codes）&lt;/h2&gt;
&lt;p&gt;Bash 的世界，0 是正常，非0 是异常。&lt;code&gt;echo $?&lt;/code&gt; 可以得到上一条命令的返回码。其实是不是应该按照翻译叫退出码，不过编译语言里&lt;code&gt;return&lt;/code&gt; 都叫返回码嘛。&lt;/p&gt;
&lt;p&gt;常常用grep 的返回码来判断特定内容是否存在，是因为如果存在grep 会返回0，不存在返回1，放在if 语句里面，非常直观、方便！见下文。&lt;/p&gt;
&lt;h2&gt;4) if 语句，[ 和 [[&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;not_there&lt;span class="w"&gt; &lt;/span&gt;/dev/null
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;hi
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;lo
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上脚本执行，输出lo ，非常直观有木有。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[&lt;/code&gt; 和&lt;code&gt;[[&lt;/code&gt; 的差别，前者好像是内置命令，后者是关键词，一般尽量用后者就是了，比较方便。详细区别对比：&lt;a href="http://blog.csdn.net/hittata/article/details/8049665"&gt;BASH 中单括号和双括号&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 直接执行会出错，$(grep note_there /dev/null) 输出为空，就变成了[ = &amp;#39;&amp;#39; ] ，&lt;/span&gt;
&lt;span class="c1"&gt;# 这也就是为什么常常在一些老脚本里面看到这样的语句： [ x$(...) = &amp;#39;&amp;#39;]&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;not_there&lt;span class="w"&gt; &lt;/span&gt;/dev/null&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;hi
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;lo
&lt;span class="k"&gt;fi&lt;/span&gt;


&lt;span class="c1"&gt;# [[ 就没有以上困扰&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;not_there&lt;span class="w"&gt; &lt;/span&gt;/dev/null&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;hi
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;lo
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5) set&lt;/h2&gt;
&lt;p&gt;脚本开头我一般都会加上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;set -eu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-u 表示遇到没定义的变量的时候，直接退出，可以防止如下的悲剧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;rm -rf ${ROOT}/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果&lt;code&gt;${ROOT}&lt;/code&gt; 没赋值，会发生什么？&lt;/p&gt;
&lt;p&gt;-e 表示执行过程中遇到非0 的退出状态码，直接退出，结束执行，也可以防止某些异常情况。&lt;/p&gt;
&lt;p&gt;完整的选择列表和解释：&lt;a href="http://tldp.org/LDP/abs/html/options.html"&gt;Advanced Bash-Scripting Guide: Chapter 33. Options&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;6) &amp;lt;()&lt;/h2&gt;
&lt;p&gt;作者说的这个我倒不常用，看起来挺方便。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;somestring&lt;span class="w"&gt; &lt;/span&gt;file1&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/tmp/a
$&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;somestring&lt;span class="w"&gt; &lt;/span&gt;file2&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/tmp/b
$&lt;span class="w"&gt; &lt;/span&gt;diff&lt;span class="w"&gt; &lt;/span&gt;/tmp/a&lt;span class="w"&gt; &lt;/span&gt;/tmp/b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以简化为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;diff&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;somestring&lt;span class="w"&gt; &lt;/span&gt;file1&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;somestring&lt;span class="w"&gt; &lt;/span&gt;file2&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7) Quoting&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;A=&amp;#39;123&amp;#39;
echo &amp;quot;$A&amp;quot;
echo &amp;#39;$A&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;单引号里面的内容不会展开，输出结果为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;123
$A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;作者文章里面这个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mkdir -p tmp
cd tmp
touch a
echo &amp;quot;*&amp;quot;
echo &amp;#39;*&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不知道是因为版本原因还是配置问题，在我的机器上测试，都是输出 &lt;code&gt;*&lt;/code&gt;，作者说的意想不到的结果大概是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;会输出当前目录下所有的文件名。&lt;/p&gt;
&lt;h2&gt;8) 最常用的三个快捷操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!!&lt;/code&gt;,重复执行上一条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt;，展开为当前用户的home 目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者列了他最常用的3个快捷操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!@&lt;/code&gt;，展开为上一条命令的所有参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!:1-$&lt;/code&gt;：这条命令看着有点复杂，&lt;code&gt;!&lt;/code&gt;表示上一条命令，&lt;code&gt;:&lt;/code&gt;是分隔符，后面就是表示取到第几位。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!:2-3&lt;/code&gt;，展开为上一条命令的参数中的第2到第3位的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;bash-3.2$ echo 1 2 3 4 5
1 2 3 4 5
bash-3.2$ echo !:2-3
2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:h&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep isthere /long/path/to/some/file/or/other.txt
cd !$:h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;!$:h&lt;/code&gt; 展开为 上一条命令最后一个参数的目录路径："/long/path/to/some/file/or"。&lt;/p&gt;
&lt;h2&gt;9) 启动顺序&lt;/h2&gt;
&lt;p&gt;&lt;img alt="shell-startup-actual" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228182436.png"&gt;&lt;/p&gt;
&lt;p&gt;作者放了1个图，左边是Bash，右边是Zsh，来源是：&lt;a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html"&gt;Shell startup scripts&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;非常有趣、直观，顺着一种颜色看，Bash 启动过程，期间加载的文件，一目了然。读这篇文章，最大的收获就是见到这张图。&lt;/p&gt;
&lt;h2&gt;10) getopts (cheapci)&lt;/h2&gt;
&lt;p&gt;作者说的&lt;a href="https://github.com/ianmiell/cheapci"&gt;chepci&lt;/a&gt; 这个项目没咋看，不过这段脚本里的片段 可以作为学习getopts 的&lt;a href="https://github.com/ianmiell/cheapci/blob/master/cheapci#L33-L95"&gt;例子&lt;/a&gt;。&lt;/p&gt;</content><category term="2018"></category><category term="bash"></category><category term="shell"></category><category term="linux"></category></entry><entry><title>HAProxy in 2018</title><link href="https://fangpsh.github.io/posts/2018/2018-01-17.html" rel="alternate"></link><published>2018-01-17T00:00:00+08:00</published><updated>2018-01-17T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-01-17:/posts/2018/2018-01-17.html</id><summary type="html">&lt;p&gt;&lt;img alt="haproxy_in_2018" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145902.jpg"&gt;  &lt;/p&gt;
&lt;p&gt;之前在Twitter 上有看到HAProxy 官方号发&lt;a href="https://twitter.com/haproxy_tech/status/925760917614354434"&gt;tweet&lt;/a&gt;，说新版支持HTTP/2 了，当时没在意，人家Nginx 一年前就支持了好吧，你才来。最近看到一篇文章 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="haproxy_in_2018" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145902.jpg"&gt;  &lt;/p&gt;
&lt;p&gt;之前在Twitter 上有看到HAProxy 官方号发&lt;a href="https://twitter.com/haproxy_tech/status/925760917614354434"&gt;tweet&lt;/a&gt;，说新版支持HTTP/2 了，当时没在意，人家Nginx 一年前就支持了好吧，你才来。最近看到一篇文章，&lt;a href="https://certsimple.com/blog/haproxy-http2-dynamic-load-balancing-ssl"&gt;CertSimple: HAProxy in 2018&lt;/a&gt;，吹了一发HAProxy。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.mail-archive.com/haproxy@formilux.org/msg28004.html"&gt;ANNOUNCE haproxy-1.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.haproxy.com/blog/whats-new-haproxy-1-8/"&gt;What’s New in HAProxy 1.8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.haproxy.com/blog/multithreading-in-haproxy/"&gt;Multithreading in HAProxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.8 提供了完整的 HTTP/2 支持，不知道bug 多不多，记得Nginx 刚刚支持HTTP/2 时修了很多bug。&lt;br&gt;
另外一个重大的变化是Multithreading，多线程支持。HAProxy 支持多进程（nbproc），有几个问题，监控检查是每个进程自己做的，统计页面也不准确，maxconn 参数也只能限制单个进程。在前公司用到HAProxy 的时候，就因为这些问题，把多进程关了。多线程就好了，没了这些问题，依然能充分利用CPU。  &lt;/p&gt;
&lt;p&gt;1.8 还加了一个Master/Worker Mode，类似Nginx 的进程模型，一个Master + 多个 Worker。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps axf -o pid,command
15012      \_ haproxy -f ./master.cfg -d
15013          \_ haproxy -f ./master.cfg -d
15014          \_ haproxy -f ./master.cfg -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;据说是为了解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But this wasn’t really convenient in cases where 3rd party software was monitoring and controlling the HAProxy processes (e.g. needing to reload them) as it had to be aware of HAProxy’s individual processes and control each one separately. One of the examples in this category was certainly systemd.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;管理进程的时候能方便点。&lt;/p&gt;
&lt;p&gt;CertSimple 那篇文章对比HAProxy 和Nginx，吐槽Nginx 默认的status 页面太简单，这个倒是真的。HAProxy 的统计页面确实非常详细。
&lt;img alt="haproxy_stats" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145934.png"&gt;&lt;br&gt;
图片来源&lt;a href="https://www.datadoghq.com/blog/how-to-collect-haproxy-metrics/#stats-page"&gt;datadoghq.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HAProxy 提供了api 来动态的管理、配置机器，Nginx 的动态Upstream 还得用插件搞半天，参考&lt;a href="http://haproxy.tech-notes.net/9-2-unix-socket-commands/"&gt;9.2. Unix Socket commands&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于Haproxy 监控的另外一篇文章：&lt;a href="https://www.datadoghq.com/blog/how-to-collect-haproxy-metrics/"&gt;How to collect HAProxy metrics&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;echo "show stat" | nc -U /var/run/haproxy.sock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HAProxy 日志输出也比Nginx 详细很多，并非常精简，每次分析HAProxy 的日志，都得打开它的文档，一个字符一个字符的查看对比，特别是那一堆Flag，非常有用，CC、CD、cD、sQ 等，因为Haproxy 在后端和客户中间，出现问题的时候，到底是前端还是后端的问题，通过这些标志非常方便，参考&lt;a href="https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#8.5"&gt;Session state at disconnection&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;HAProxy 作为一个纯粹的前端负载均衡器，可能比Nginx 出色很多，不过在Web Server 方面，HAProxy 难以望其项背。&lt;/p&gt;
&lt;p&gt;有机会一定要试一试HAProxy 1.8。&lt;/p&gt;</content><category term="2018"></category><category term="haproxy"></category></entry><entry><title>Ngxfmt</title><link href="https://fangpsh.github.io/posts/2018/2018-01-11.html" rel="alternate"></link><published>2018-01-11T00:00:00+08:00</published><updated>2018-01-11T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2018-01-11:/posts/2018/2018-01-11.html</id><summary type="html">&lt;p&gt;接手一坨缩进、格式乱七八糟的Nginx 配置，简直要命。想起golang 有一个gofmt，动手做一个简单的ngxfmt。&lt;/p&gt;
&lt;p&gt;Nginx 的配置语法比较简单，分为块配 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;接手一坨缩进、格式乱七八糟的Nginx 配置，简直要命。想起golang 有一个gofmt，动手做一个简单的ngxfmt。&lt;/p&gt;
&lt;p&gt;Nginx 的配置语法比较简单，分为块配置和简单配置，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;server { # simple reverse-proxy
    listen       80;
    server_name  domain2.com www.domain2.com;
    access_log   logs/domain2.access.log  main;

    # serve static files
    location ~ ^/(/images|javascript|js|css|flash|media|static)/  {
       root    /var/www/virtual/big.server.com/htdocs;
       expires 30d;
    }

    # pass requests for dynamic content to rails/turbogears/zope, et al
    location / {
        proxy_pass      http://127.0.0.1:8080;
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;listen&lt;/code&gt;, &lt;code&gt;server_name&lt;/code&gt; 这种是简单配置，以分号结尾；&lt;code&gt;server&lt;/code&gt;，&lt;code&gt;locaiton&lt;/code&gt; 这种为块配置，带一对小括号。写过nginx 插件或者看过&lt;a href="http://lxr.nginx.org/source/src/core/ngx_conf_file.c"&gt;ngx_conf_parse&lt;/a&gt; 对nginx 的配置加载会更了解一点。&lt;/p&gt;
&lt;p&gt;毕业快3年，忽然十分想念编译原理老师，语法分析，词法分析，LR，yacc，lex  什么的。然而编译原理龙书早被我卖了，买鸡肉卷吃。听说快乐基倒闭了？？可惜可惜。&lt;/p&gt;
&lt;p&gt;只能非常不优雅的解决，从上往下手动撸，处理好缩进，清楚多余的空格，再整一下左对齐就好了。吃一个鸡肉卷的时间就能撸好🐔 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ngxfmt" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164340.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;log_format&lt;/code&gt; 这换行可以说是非常舒服了😌  ，&lt;code&gt;gzip_types&lt;/code&gt; 这对齐能让人高潮🎆 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ngxfmt-2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165631.png"&gt;&lt;/p&gt;
&lt;p&gt;在前公司曾经三个产品线要写到一个server 里面，&lt;code&gt;server_name&lt;/code&gt; 长到让人绝望😭 ，而且偶尔还得改改，这样换行就清爽多了🍃 。&lt;/p&gt;
&lt;p&gt;相邻的配置项如果一样，对所有的值都进行左对齐处理，像这样⬇️  ：&lt;br&gt;
&lt;img alt="ngxfmt-2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165710.png"&gt;&lt;/p&gt;
&lt;p&gt;源代码🐙  ：&lt;a href="https://github.com/fangpsh/ngxfmt"&gt;fangpsh/ngxfmt&lt;/a&gt;，&lt;br&gt;
有点乱，回头再看估计会被恶心到，就像一次性吃了3个鸡肉卷。&lt;/p&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.nginx.com/resources/wiki/start/topics/examples/full/"&gt;Full Example Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chr4/nginx.vim/blob/master/syntax/nginx.vim"&gt;nginx.vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kancloud.cn/digest/understandingnginx/202597"&gt;Nginx 配置解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2018"></category><category term="nginx"></category><category term="python"></category></entry><entry><title>抓取微博，同步到Twitter</title><link href="https://fangpsh.github.io/posts/2017/2017-12-21.html" rel="alternate"></link><published>2017-12-21T00:00:00+08:00</published><updated>2017-12-21T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-12-21:/posts/2017/2017-12-21.html</id><summary type="html">&lt;p&gt;&lt;img alt="zelda" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306161433.jpg"&gt;&lt;/p&gt;
&lt;p&gt;前几个月买了&lt;a href="https://www.nintendo.co.jp/hardware/switch/"&gt;NintendoSwitch&lt;/a&gt;，沉迷于“塞尔达-荒野之息”不能自拔，同时也关注着NS 新游戏的资讯。
微博上有几个帐号会发布各种NS 游戏 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="zelda" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306161433.jpg"&gt;&lt;/p&gt;
&lt;p&gt;前几个月买了&lt;a href="https://www.nintendo.co.jp/hardware/switch/"&gt;NintendoSwitch&lt;/a&gt;，沉迷于“塞尔达-荒野之息”不能自拔，同时也关注着NS 新游戏的资讯。
微博上有几个帐号会发布各种NS 游戏信息，不过微博做的和💩 一样，完全不想用。联系了那几个微博博主，询问是否考虑也同步发在Twitter，没理我，那就自己动手吧。&lt;/p&gt;
&lt;h2&gt;爬取微博&lt;/h2&gt;
&lt;p&gt;本来还以为得手动解析网页，偶尔发现移动版居然有现成的API 可以用，十分酸爽。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;https://m.weibo.cn/u/5084965647
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="weibo1" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306161502.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;https://m.weibo.cn/api/container/getIndex?containerid=1076035084965647&amp;amp;page=2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="weibo2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306161516.jpg"&gt;&lt;/p&gt;
&lt;p&gt;结构挺清晰的，data-cards 就是每一条微博，不过会有不同的card-type，选出card-type=9 的即可。&lt;/p&gt;
&lt;p&gt;每一个card 里面，主要关注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;itemid： 微博的唯一ID&lt;/li&gt;
&lt;li&gt;text： 文本内容&lt;/li&gt;
&lt;li&gt;pics： 图片&lt;/li&gt;
&lt;li&gt;page_info: 如果带视频，会有一个page_info，其中包含视频信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些接口应该有频率限制，不过我只想抓最新的，几十分钟访问一次即可。&lt;/p&gt;
&lt;h2&gt;发布到Twitter&lt;/h2&gt;
&lt;p&gt;创建一个帐号，然后再在这个帐号下创建一个 apps.twitter.com，直接生成一堆token，这样最方便。&lt;/p&gt;
&lt;p&gt;关于Twitter 的认证可以参考：&lt;a href="http://isouth.org/archives/286.html"&gt;OAuth 认证步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重点得到这四个东西即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;CONSUMER_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your-consumer-key&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;CONSUMER_SECRET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your-consumer-secret&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ACCESS_TOKEN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your-access-token&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ACCESS_TOKEN_SECRET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your-access-secret&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于图片和视频上传可以参考：&lt;a href="https://github.com/twitterdev/large-video-upload-python"&gt;twitterdev/large-video-upload-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博的text 中带了大量的链接，需要处理一下，用re.sub 替换掉即可。&lt;br&gt;
微博的话题是&lt;code&gt;#话题#&lt;/code&gt;，而Twitter 是&lt;code&gt;#话题&lt;/code&gt;，也需要处理一下。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mblog&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;text&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data-url=\&amp;quot;([^\&amp;quot; ]+)\&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;gt; \1 &amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;[^&amp;lt;]*&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#([^#]+)#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#\1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于图片、视频的几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Twitter 的图片（除GIF 之外）限制一条tweet 只能发4张，微博可以有多张，需要注意拆分，然后把第一条tweet 的ID 作为第二条的 &lt;code&gt;in_reply_to_status_id&lt;/code&gt;，就能串成所谓的“主题帖”；&lt;/li&gt;
&lt;li&gt;Twitter 的视频有一大堆限制，允许的视频时长也很短。索性不传视频了，直接保留微博原来的秒拍跳转链接；&lt;/li&gt;
&lt;li&gt;GIF 图片，Twitter 一条tweet 也只能传一张，还不能是动图，懒得判断，直接丢弃GIF 图了。&lt;/li&gt;
&lt;li&gt;传图片和视频时，记得带上&lt;code&gt;media_category&lt;/code&gt;，图片是&lt;code&gt;tweet_image&lt;/code&gt;，视频是&lt;code&gt;tweet_video&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写好之后，丢到VPS 上，15分钟运行一次即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://twitter.com/NinSwitch_News"&gt;@NinSwitch_News&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
&lt;img alt="ns_news" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306161552.jpg"&gt;&lt;/p&gt;
&lt;p&gt;代码就不发了，写得很快很糙，也没啥难度。  &lt;/p&gt;</content><category term="2017"></category><category term="spider"></category></entry><entry><title>ioping</title><link href="https://fangpsh.github.io/posts/2017/2017-12-13.html" rel="alternate"></link><published>2017-12-13T00:00:00+08:00</published><updated>2017-12-13T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-12-13:/posts/2017/2017-12-13.html</id><summary type="html">&lt;p&gt;&lt;img alt="ioping" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306152430.jpg"&gt;&lt;/p&gt;
&lt;p&gt;发现一个有趣的工具 - ioping，类似常用的ping 命令。ping 用来ping 网络，看延时、丢包等等，ioping 用来 “ping” IO，看IO 耗时，读写速度等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/koct9i/ioping"&gt;ioping&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;simple disk I …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="ioping" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306152430.jpg"&gt;&lt;/p&gt;
&lt;p&gt;发现一个有趣的工具 - ioping，类似常用的ping 命令。ping 用来ping 网络，看延时、丢包等等，ioping 用来 “ping” IO，看IO 耗时，读写速度等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/koct9i/ioping"&gt;ioping&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;simple disk I/0 latency measuring tool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用常见的包管理工具就可以安装上，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt/yum/dnf/brew install ioping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ping 命令基本无害，不过ioping 据说可能会损坏数据，得小心使用。&lt;/p&gt;
&lt;p&gt;安装之后，man 一下查看手册，会发现选项还挺多：每一次写入的大小，写入/读取请求的间隔，请求的总次数，同步/异步 IO， direct I/O 、cached I/O 多种模式等等。&lt;/p&gt;
&lt;p&gt;默认一个数据块是4k ，可以选择写入，读取，或者读写交替模式，以前简单的IO测试都是用&lt;a href="https://en.wikipedia.org/wiki/Dd_(Unix)"&gt;dd&lt;/a&gt;，以后可以试一试用ioping，当然，专业严谨的压测还是得用&lt;a href="https://github.com/axboe/fio"&gt;fio&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;具体语法和示例，可以参考以下资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.systutorials.com/docs/linux/man/1-ioping/"&gt;ioping(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/koct9i/ioping"&gt;koct9i/ioping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cyberciti.biz/faq/linux-freebsd-openbsd-macosx-find-disk-io-latency-with-ioping/amp/?__twitter_impression=true"&gt;How to find disk I/O latency with ioping monitoring tool on Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2017"></category><category term="bash"></category></entry><entry><title>禁用透明大页</title><link href="https://fangpsh.github.io/posts/2017/2017-12-05.html" rel="alternate"></link><published>2017-12-05T00:00:00+08:00</published><updated>2017-12-05T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-12-05:/posts/2017/2017-12-05.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href="https://blog.nelhage.com/post/transparent-hugepages/#fn:tree"&gt;blog.nelhage.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href="https://blog.nelhage.com/about/"&gt;Nelson Elhage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文发表时间： 2017-07-10&lt;/li&gt;
&lt;li&gt;原文许可协议：&lt;a href="https://creativecommons.org/licenses/by/4.0/"&gt;CC BY 4.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;tl;dr（长话短说）&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt"&gt;“透明大页（Transparent Hugepages）”&lt;/a&gt;是一个Linux 内核特性 …&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href="https://blog.nelhage.com/post/transparent-hugepages/#fn:tree"&gt;blog.nelhage.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href="https://blog.nelhage.com/about/"&gt;Nelson Elhage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文发表时间： 2017-07-10&lt;/li&gt;
&lt;li&gt;原文许可协议：&lt;a href="https://creativecommons.org/licenses/by/4.0/"&gt;CC BY 4.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;tl;dr（长话短说）&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt"&gt;“透明大页（Transparent Hugepages）”&lt;/a&gt;是一个Linux 内核特性，它通过提高处理器的内存映射硬件的使用效率（译注：降低TLB Miss 和page fault，提高TLB 的命中率，这部分基础知识可以翻下操作系统书）来获取更好的性能。在绝大多数Linux 发行版中是默认启用的（“&lt;code&gt;enabled=always&lt;/code&gt;”）。&lt;/p&gt;
&lt;p&gt;透明大页能让一些应用程序的&lt;a href="https://lwn.net/Articles/423590/"&gt;性能提高一点点&lt;/a&gt;（最好的情况大约是10%，一般在0~3%），但是会造成很明显的性能问题（参考：1.&lt;a href="https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/"&gt;mongodb&lt;/a&gt;，2.&lt;a href="https://blogs.oracle.com/linux/performance-issues-with-transparent-huge-pages-thp"&gt;oracle&lt;/a&gt;, 3.&lt;a href="https://docs.splunk.com/Documentation/Splunk/6.5.2/ReleaseNotes/SplunkandTHP"&gt;splunk&lt;/a&gt;）, 甚至会造成严重的内存泄漏（参考：1.&lt;a href="https://blog.digitalocean.com/transparent-huge-pages-and-alternative-memory-allocators/"&gt;digitalocean&lt;/a&gt;，2.&lt;a href="https://github.com/golang/go/issues/8832"&gt;golang/go&lt;/a&gt;）.&lt;/p&gt;
&lt;p&gt;为了避免这些问题，你应该将运行的服务器设置成&lt;code&gt;enabled=madvise&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并在服务器的内核命令行上设置&lt;code&gt;transparent_hugepage=madvise&lt;/code&gt;（例如在&lt;code&gt;/etc/default/grub&lt;/code&gt; 中设置）。&lt;/p&gt;
&lt;p&gt;完成这些修改之后，应用程序能通过透明大页提升性能，也能避免上述问题（译注：设置成&lt;code&gt;madvise&lt;/code&gt;，应用程序通过设置&lt;code&gt;MADV_HUGEPAGE&lt;/code&gt;标志就能分配到大页，不需要的程序则不受影响）。&lt;/p&gt;
&lt;p&gt;继续阅读了解更多细节。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h2&gt;什么是透明大页？&lt;/h2&gt;
&lt;h3&gt;什么是大页？&lt;/h3&gt;
&lt;p&gt;数十年来，处理器和操作系统之间通过使用&lt;a href="https://en.wikipedia.org/wiki/Virtual_memory"&gt;虚拟内存&lt;/a&gt;，在应用程序可见的内存空间（“虚拟内存空间(virtual address space)”）和底层的物理内存之间设置了间接层。间接层不仅保护了应用程序互相不受影响，还有许多强大的特性。&lt;/p&gt;
&lt;p&gt;非常多的 x86 处理器都是通过一个叫&lt;a href="https://en.wikipedia.org/wiki/Page_table"&gt;页表（page table）&lt;/a&gt;的方案实现虚拟内存，这个方案会在内存中存一个非常大的映射表（实际上一个深度不同的树结构，不过也可以看作是一个稀疏表）。传统上，x86 处理器中一份页表条目对应一份4KB 的内存“页”。&lt;/p&gt;
&lt;p&gt;虽然页表都是存在内存里，但是处理器会缓存一部分页表条目到处理器的寄存器上，它被称为&lt;a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer"&gt;TLB&lt;/a&gt; 。查看我笔记本上的&lt;code&gt;cpuid(1)&lt;/code&gt;（译注：&lt;a href="http://www.etallen.com/cpuid.html"&gt;Linux tool to dump x86 CPUID information about the CPU(s)&lt;/a&gt;）发现最低等级的TLB 只包含64个条目，每个条目对应一份4KB 的数据页。现在是2017年，64*4KB 只有四分之一兆字节，远小于目前使用的大多数应用程序的工作内存。这种大小不匹配的情况意味着占用大量内存的应用程序会周期性的遇到TLB 不命中的情况，从而需要花费很高的代价访问主内存，只为得到具体的内存地址（译注：TLB Miss 之后需要访问内存中的页表，从而得到具体内存地址）。&lt;/p&gt;
&lt;p&gt;为了改进TLB 的效率，x86 及其他处理器长期以来都支持创建“大页（huge pages）”，大页的页表条目能映射一大段的物理内存地址。根据操作系统的配置不同，大多数最近的芯片能够映射2MB，4MB，甚至1GB 的内存页。使用大页意味着TLB 存着更多的数据，对某些特定的任务来说效率更高。&lt;/p&gt;
&lt;h3&gt;什么是透明大页？&lt;/h3&gt;
&lt;p&gt;存在各种页表管理方式，这意味着操作系统需要决定如何映射地址空间和物理内存。由于应用程序的内存管理接口（例如&lt;code&gt;mmap(2)&lt;/code&gt;）一直都是基于最小的 4KB 页，所以内核映射数据必须以4KB 为单位。最简单和最灵活的（就已支持的内存布局而言）方案是只采用4KB 的页，应用程序映射内存无法使用大页。长期以来，这是内核最通用的内存管理策略。&lt;/p&gt;
&lt;p&gt;对于需要大量内存并对性能敏感的应用程序（例如某些特定数据库或者科学计算程序），内核引入&lt;a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"&gt;hugetlbfs&lt;/a&gt; 特性，该特性允许系统管理员通过配置让特定的应用程序使用大页。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt"&gt;透明大页（简称“THP”）&lt;/a&gt;，正如其名，旨在自动为应用程序提供大页支持，不需要特殊配置（译注：透明大页的透明，类似透明代理的透明）。透明大页通过在后台扫描（使用&lt;code&gt;khugepaged&lt;/code&gt; 内核线程）内存映射，尝试找到或者创建（通过移动相邻的内存）总共2MB 的连续4KB 映射，用一个大页来替换这一段内存映射。&lt;/p&gt;
&lt;h2&gt;有什么问题？&lt;/h2&gt;
&lt;p&gt;透明大页运行良好时，特定的测试场景下，可以带来大约10% 的性能提升。然而，它也会造成至少两种非常严重的故障：&lt;/p&gt;
&lt;h3&gt;内存泄漏&lt;/h3&gt;
&lt;p&gt;THP 倾向于创建2MB 的内存映射。然而，这样做太贪心，即使必要的情况下，也不愿意把它们拆分回去。如果一个应用程序映射了一大段内存但是只访问前面几个字节，传统上只会消耗一个4KB 的物理内存页。THP 开启的情况下，&lt;code&gt;khugepaged&lt;/code&gt;会将4KB 页扩张到2MB，内存占用量增大512倍（这份&lt;a href="https://bugzilla.kernel.org/show_bug.cgi?id=93111"&gt;Bug 报告&lt;/a&gt; 中的例子更糟糕，甚至超过512 倍！）。&lt;/p&gt;
&lt;p&gt;这种情况不是假设；Go 语言的GC 就有一个&lt;a href="https://github.com/golang/go/issues/8832"&gt;明确的解决方法&lt;/a&gt;，Digital Ocean 也&lt;a href="https://blog.digitalocean.com/transparent-huge-pages-and-alternative-memory-allocators/"&gt;记录&lt;/a&gt;了它们是如何处理Redis，THP 和&lt;code&gt;jemalloc&lt;/code&gt;遇到的问题。 &lt;/p&gt;
&lt;p&gt;（译注：据说3.10 内核透明零页有泄漏问题，内核只释放2MB 中第一个4KB 的页面，剩余的页面泄漏）&lt;/p&gt;
&lt;h3&gt;卡顿和高CPU 使用率&lt;/h3&gt;
&lt;p&gt;应用程序都是分配相对静态的内存，稳定的状态下，&lt;code&gt;khugepaged&lt;/code&gt; 的工作量是最小的。但是如果存在频繁映射内存的情况，或者存在生命周期很短的进程，&lt;code&gt;khugepaged&lt;/code&gt; 会进行大量的拆分/合并内存区域的工作，毫无意义，存活时间很短。这会引起很高的CPU 使用率，以及较长的卡顿，因为内核被迫得先把2MB 的页拆分成4KB 的页，才能执行原本在单页上效率很高的操作。&lt;/p&gt;
&lt;p&gt;因为这些原因，启用了THP 之后，好几个应用程序都观察到30% 的性能下降，甚至更糟。&lt;/p&gt;
&lt;h2&gt;现在怎么办？&lt;/h2&gt;
&lt;p&gt;THP 作者们事先意识到了透明大页可能有潜在的问题（尽管如今看来，他们低估了问题的严重性），所以他们选择通过 &lt;code&gt;/sys/kernel/mm/transparent_hugepage/enabled&lt;/code&gt; 系统文件配置透明大页。&lt;/p&gt;
&lt;p&gt;更重要的是，他们为透明大页实现了一种可选择的模式。将&lt;code&gt;/sys/kernel/mm/transparent_hugepage/enabled&lt;/code&gt; 设置为&lt;code&gt;madvise&lt;/code&gt;，&lt;code&gt;khugepaged&lt;/code&gt; 默认情况下不会处理内存，除非应用程序使用&lt;code&gt;madvise&lt;/code&gt; 系统调用，给特定范围的内存进行THP 处理。&lt;/p&gt;
&lt;p&gt;由于在大多数情况下，只有少数特定的应用程序能通过透明大页显著提升性能，所以这是一个两全其美的选项。这些少数的应用程序可以选择使用&lt;code&gt;madvise&lt;/code&gt;，其余的应用程序不受影响。&lt;/p&gt;
&lt;p&gt;所以，我建议每个用户都把透明大页配置成&lt;code&gt;madvise&lt;/code&gt;，如文章开头&lt;a href="#tl;dr"&gt;tl;dr&lt;/a&gt;所说的。同时我也希望说服主流的发行版默认禁用透明大页，让更多的系统管理员和开发者避免踩这些坑。&lt;/p&gt;</content><category term="2017"></category><category term="linux"></category></entry><entry><title>Chrome，ERR_SPDY_PROTOCOL_ERROR 和无效的HTTP header</title><link href="https://fangpsh.github.io/posts/2017/2017-12-04.html" rel="alternate"></link><published>2017-12-04T00:00:00+08:00</published><updated>2017-12-04T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-12-04:/posts/2017/2017-12-04.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href="https://www.michalspacek.com/chrome-err_spdy_protocol_error-and-an-invalid-http-header"&gt;michalspacek.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href="https://www.michalspacek.com/contact"&gt;Michal Špaček&lt;/a&gt;https://www.michalspacek.com/contact&lt;/li&gt;
&lt;li&gt;发表时间：2017-08-28&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你把网站迁移到性能更好的HTTP/2 协议时，可能会出现Chrome 没法加载 …&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href="https://www.michalspacek.com/chrome-err_spdy_protocol_error-and-an-invalid-http-header"&gt;michalspacek.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href="https://www.michalspacek.com/contact"&gt;Michal Špaček&lt;/a&gt;https://www.michalspacek.com/contact&lt;/li&gt;
&lt;li&gt;发表时间：2017-08-28&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你把网站迁移到性能更好的HTTP/2 协议时，可能会出现Chrome 没法加载页面的问题，取而代之是一个显示&lt;strong&gt;This site can’t be reached&lt;/strong&gt;，以及错误信息为&lt;code&gt;ERR_SPDY_PROTOCOL_ERROR&lt;/code&gt; 的页面。错误信息里面没有提到HTTP/2， 可能是因为 HTTP/2 是从SPDY 协议发展而来，所以错误信息还是老的SPDY。&lt;/p&gt;
&lt;p&gt;&lt;img alt="chrome_err_spdy_protocol_error" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160946.png"&gt;&lt;/p&gt;
&lt;p&gt;出现&lt;code&gt;ERR_SPDY_PROTOCOL_ERROR&lt;/code&gt; 可能是因为服务器发送了一个无效的HTTP header。Chrome 处理二进制的HTTP/2 协议时有一些严格，不会处理以空格代替破折号的header（例如用&lt;code&gt;Referrer Policy&lt;/code&gt; 代替&lt;code&gt;Referrer-Policy&lt;/code&gt;），也不会处理带着2个冒号的header（例如&lt;code&gt;Content-Security-Policy:: ...&lt;/code&gt;），所以检查下你的header 是否准确。Firefox 会忽略这些无效的header，正常显示页面。&lt;/p&gt;
&lt;p&gt;给出一个如何找到这些有问题的header 的方法。访问&lt;code&gt;chrome://net-internals/#events&lt;/code&gt;（这链接没法点击，只能复制然后粘贴到地址栏再访问），在搜索框输入你的域名（我以&lt;code&gt;example.com&lt;/code&gt;为例），然后在其他标签中打开出问题的网站。返回&lt;code&gt;chrome://net-internals/#events&lt;/code&gt; ，选中Source Type 是&lt;code&gt;HTTP2_SESSION&lt;/code&gt; 的行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="chrome-events-http2_session" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228211536.png"&gt;&lt;/p&gt;
&lt;p&gt;在右边，可以看到HTTP/2 协议的详细信息，重点部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;t=50413 [st=7]  HTTP2_SESSION_RECV_INVALID_HEADER
                --&amp;gt; header_name = &amp;quot;referrer policy&amp;quot;
                --&amp;gt; header_value = &amp;quot;same-origin&amp;quot;
t=50413 [st=7]  HTTP2_SESSION_SEND_RST_STREAM
               --&amp;gt; description = &amp;quot;Could not parse Spdy Control Frame Header.&amp;quot;
               --&amp;gt; error_code = &amp;quot;1 (PROTOCOL_ERROR)&amp;quot;
               --&amp;gt; stream_id = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看到&lt;code&gt;HTTP2_SESSION_RECV_INVALID_HEADER&lt;/code&gt; 那行了吗？无效的header 就在它下面，在这个问题中，无效的header 是&lt;code&gt;referrer policy&lt;/code&gt;，用空格代替了破折号。HTTP/2 协议理的header 名称必须全小写，如果你发送一个&lt;code&gt;Referrer-Policy&lt;/code&gt;的header，浏览器会视为&lt;code&gt;referrer-policy&lt;/code&gt;。在这个问题中，被视为成无效的&lt;code&gt;referrer policy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在你浏览器的&lt;code&gt;chrome://net-internals/&lt;/code&gt;中，你能发现很多有趣的东西。这里有一些不会出现在开发者工具中的请求，例如浏览器扩展发出的请求。去试一试，说不定下次你debug 时能帮上忙。我在研究&lt;a href="https://www.michalspacek.com/opera-browsers-vpn-is-just-a-proxy"&gt;Opera browser “VPN” &lt;/a&gt;和&lt;a href="https://www.michalspacek.com/ur-browser-vpn-and-other-tales"&gt;“VPN” in UR browser&lt;/a&gt; 就用过它。&lt;/p&gt;</content><category term="2017"></category><category term="chrome"></category><category term="http2"></category></entry><entry><title>搭建HTTP/2 代理</title><link href="https://fangpsh.github.io/posts/2017/2017-11-01.html" rel="alternate"></link><published>2017-11-01T00:00:00+08:00</published><updated>2017-11-01T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-11-01:/posts/2017/2017-11-01.html</id><summary type="html">&lt;p&gt;这个月又抢到了内部的100元腾讯云代金券，听说最近流行HTTP/2 代理，快速折腾一下，主要内容都是参考这篇文章：&lt;a href="https://wzyboy.im/post/1052.html"&gt;《使用 nghttpx 搭建 HTTP/2 代理》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;证书 …&lt;/h2&gt;</summary><content type="html">&lt;p&gt;这个月又抢到了内部的100元腾讯云代金券，听说最近流行HTTP/2 代理，快速折腾一下，主要内容都是参考这篇文章：&lt;a href="https://wzyboy.im/post/1052.html"&gt;《使用 nghttpx 搭建 HTTP/2 代理》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;证书&lt;/h2&gt;
&lt;p&gt;HTTP/2 代理其实也就是HTTPS 代理了，首先需要一个证书，可以自己签，太麻烦了。腾讯云和阿里云都提供了免费的DV 证书。搞一个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.qcloud.com/blog/?p=1237"&gt;腾讯云支持DV SSL证书免费申请&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.aliyun.com/product/cas"&gt;Alibaba Cloud Certificates Service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为域名托管在DNSPOD，在腾讯云申请都无需验证，挺快的，会给一个压缩包，打开里面Nginx 子目录，拿到crt 和key 备用。&lt;/p&gt;
&lt;h2&gt;nghttpx&lt;/h2&gt;
&lt;p&gt;nghttpx 可以对外提供HTTP/2 服务，将请求转换成HTTP/1.X 转发给后端，相当于一个中间人。&lt;/p&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;aptitude install nghttp2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不懂为啥ubuntu 的包名是&lt;a href="https://packages.ubuntu.com/xenial/nghttp2"&gt;nghttp2&lt;/a&gt;，然后包含三个包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nghttp2-client
nghttp2-proxy
nghttp2-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编辑配置文件 &lt;code&gt;/etc/nghttpx/nghttpx.conf&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;frontend=0.0.0.0,443
backend=127.0.0.1,3128
private-key-file=/root/ssl/2_xxxxx.fangpeishi.com.key
certificate-file=/root/ssl/1_xxxxx.fangpeishi.com_bundle.crt
http2-proxy=yes
errorlog-syslog=yes
workers=1

add-x-forwarded-for=no

no-via=yes
no-ocsp=yes
tls-proto-list=TLSv1.2
ciphers=ECDHE+AES128
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我是抄的上文文章中的配置，先跑起来再说。。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;systemctl restart nghttpx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;squid&lt;/h2&gt;
&lt;p&gt;squid 作为nghttpx 后端的透明代理，不过记住要让它监听在本地，别暴露在公网上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-get install squid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编辑配置文件&lt;code&gt;/etc/squid/squid.conf&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;http_port 127.0.0.1:3128

cache deny all
access_log none

dns_v4_first on

via off

forwarded_for delete

auth_param basic program /usr/lib/squid/basic_ncsa_auth  /etc/squid/passwd
auth_param basic casesensitive off
acl auth_user proxy_auth REQUIRED
http_access allow auth_user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也是抄的教程中的配置。。先跑起来再说。鉴权那段下文说明。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;systemctl restart squid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;鉴权&lt;/h2&gt;
&lt;p&gt;暴露在公网被其他人乱跑流量总不太好，在Squid 上加一个简单的HTTP Auth。&lt;/p&gt;
&lt;p&gt;安装 htpasswd 工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-get install apache2-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#-c 创建文件
htpasswd  -c  /etc/squid/passwd [用户名]

# 添加其他用户
htpasswd /etc/squid/passwd [用户名]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code&gt;/etc/squid/squid.conf&lt;/code&gt; 添加配置，再重启即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;auth_param basic program /usr/lib/squid/basic_ncsa_auth  /etc/squid/passwd
auth_param basic casesensitive off
acl auth_user proxy_auth REQUIRED
http_access allow auth_user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;更多关于squid 的配置需求，直接参考官方文档，应该没有啥是squid 做不到了。&lt;/p&gt;
&lt;h2&gt;BBR&lt;/h2&gt;
&lt;p&gt;再顺便升下内核，开启下 BBR，听说有奇效？不过我没有做对比。。直接开启了。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href="https://imtx.me/archives/2379.html"&gt;《使用标准方式在 Ubuntu 16.04 下启用 TCP 拥塞控制之 BBR》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简明步骤，来着上面这篇文章：&lt;/p&gt;
&lt;p&gt;安装内核&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-get install linux-generic-hwe-16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;reboot 之后，检查内核是不是&amp;gt; 4.9&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;uname -a 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加载模块，打开参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;modprobe tcp_bbr
echo &amp;quot;tcp_bbr&amp;quot; | tee -a /etc/modules-load.d/modules.conf

echo &amp;quot;net.core.default_qdisc=fq&amp;quot; | tee -a /etc/sysctl.conf
echo &amp;quot;net.ipv4.tcp_congestion_control=bbr&amp;quot; | tee -a /etc/sysctl.conf
sysctl -p
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后验证一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sysctl net.ipv4.tcp_congestion_control
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;返回结果必须是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;net.ipv4.tcp_congestion_control = bbr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;搞完之后，验证一下，Chrome 安装&lt;a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=en"&gt;SwitchyOmega&lt;/a&gt; 插件，新建一份配置，协议选择HTTPS，记得填入HTTP Auth验证信息。然后选中启用，打开 &lt;a href="https://www.whatismyip.com/"&gt;whatismyip&lt;/a&gt; 看看IP 是不是变了。在不同的平台上要使用，找不同的客户端支持吧。&lt;/p&gt;</content><category term="2017"></category><category term="代理"></category></entry><entry><title>写一个Terraform Provider</title><link href="https://fangpsh.github.io/posts/2017/2017-10-13.html" rel="alternate"></link><published>2017-10-13T00:00:00+08:00</published><updated>2017-10-13T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-10-13:/posts/2017/2017-10-13.html</id><summary type="html">&lt;p&gt;上个月想给腾讯云写一个terraform provider，花了一周的时间入门Golang，参考现有的一些项目完成了&lt;a href="https://cloud.tencent.com/product/clb"&gt;CLB&lt;/a&gt; 的&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete"&gt;CRUD&lt;/a&gt;。本来想做成和阿里云的provider 一 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上个月想给腾讯云写一个terraform provider，花了一周的时间入门Golang，参考现有的一些项目完成了&lt;a href="https://cloud.tencent.com/product/clb"&gt;CLB&lt;/a&gt; 的&lt;a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete"&gt;CRUD&lt;/a&gt;。本来想做成和阿里云的provider 一样完善，但是腾讯云的API 错误百出，有些产品的API 返回参数不一致。算了，等以后遇到具体需求再继续做。把学习写provider 的过程简单记录一下。&lt;/p&gt;
&lt;p&gt;入门Golang，读了&lt;a href="https://book.douban.com/subject/11577300/"&gt;《Go 语言编程》&lt;/a&gt; 的1~4章, 重点看了下map 和interface 就够用了。goroutine、channel 啥的先不用看，写provider 用不到。&lt;/p&gt;
&lt;p&gt;官网的教程&lt;a href="https://www.terraform.io/guides/writing-custom-terraform-providers.html"&gt;Writing Custom Providers&lt;/a&gt; 比较简单，我是先看这个例子，了解大致的结构。再读&lt;a href="https://github.com/alibaba/terraform-provider"&gt;alibaba/terraform-provider&lt;/a&gt; 源码，照猫画虎。&lt;/p&gt;
&lt;p&gt;这篇教程写的也不错&lt;a href="http://blog.jfabre.net/2017/01/22/writing-terraform-provider/"&gt;Writing a Terraform provider&lt;/a&gt;，看完之后很受用，写邮件给作者表示希望能翻译，没理我:( 。&lt;/p&gt;
&lt;p&gt;代码目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;├── README.md
├── api
│   ├── clb
│   ├── common
│   └── cvm
├── main.go
├── qcloud
│   ├── config.go
│   ├── data_source_qcloud_zones.go
│   ├── provider.go
│   ├── resource_qcloud_clb.go
│   ├── resource_qcloud_clb_listener.go
│   ├── resource_qcloud_eip.go
│   └── validators.go
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;main.go&lt;/h2&gt;
&lt;p&gt;main.go 每个provider 都差不多，包含一个main 函数，build 的时候生成一个二进制文件，照抄即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;github.com/hashicorp/terraform/plugin&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;terraform-provider-qcloud/qcloud&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;plugin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Serve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;plugin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ServeOpts&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;ProviderFunc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;qcloud&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Provider&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;api/&lt;/h2&gt;
&lt;p&gt;provider 是通过云产品的api 调用相关的接口对资源进行CRUD，不过腾讯云没有提供golang 的sdk，需要自己封装一下。我参考了阿里云的&lt;a href="https://github.com/denverdino/aliyungo"&gt;denverdino/aliyungo&lt;/a&gt;，阿里云的provider 也是使用的这个SDK。签名函数直接用了腾讯云的&lt;a href="https://github.com/QcloudApi/qcloud_sign_golang"&gt;QcloudApi/qcloud_sign_golang&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.
├── clb
│   ├── client.go
│   ├── listener.go
│   └── load_balancer.go
├── common
│   ├── client.go
│   └── sign.go
└── cvm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照不同产品分成多个client，是因为不同产品的API 在参数上有一些区别，例如版本号，接口地址等。我放弃继续实现的主要原因就是腾讯云的API 文档错误百出，各个产品API 风格不统一，非常累。&lt;/p&gt;
&lt;h2&gt;provider.go&lt;/h2&gt;
&lt;p&gt;这个文件包含你实现的Provider 所提供的所有内容，具体可以看源码。Provider() 函数返回一个 terraform.ResourceProvider 对象，包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Schema 是需要提供给你provider 的参数，例如访问API 的key 之类的。&lt;/li&gt;
&lt;li&gt;ResourceMap 是你provider 将提供的resources，例如腾讯云的CLB，CVM，CDN 之类的，每个resource 你需要实现特定的CRUD 接口。&lt;/li&gt;
&lt;li&gt;DataSourcesMap 是你provider 将提供的数据源，例如腾讯云CVM 都提供了哪些镜像，可以通过实现一个镜像的datasource 拿到，在操作resources 的时候使用，使用方法可以参考&lt;a href="https://yq.aliyun.com/articles/137596?spm=5176.100239.0.0.Sztgba"&gt;Terraform中DataSource的深度分析&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;ConfigureFunc 指向一个你实现的函数，用来做一些准备工作，例如初始化上文中出现各种Client，后续API 调用时使用 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/fangpeishi/terraform-provider-qcloud/blob/master/qcloud/provider.go"&gt;terraform-provider-qcloud/qcloud/provider.go&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;config.go&lt;/h3&gt;
&lt;p&gt;ConfigureFunc 指向的函数providerConfigure 中创建了一个 Config 对象，这个对象就来自config.go ，这里面会包含各类client 的init 代码。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fangpeishi/terraform-provider-qcloud/blob/master/qcloud/config.go"&gt;terraform-provider-qcloud/qcloud/config.go&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;validators.go&lt;/h3&gt;
&lt;p&gt;在实现Resource 或者DataSource 的时候，需要传一些参数给API，服务端对这类参数一般都有规定，除了基本的类型区别，比如Int，String 之类的，还会有必须大于几，小于几，字符串必须以什么结尾开头等等。&lt;/p&gt;
&lt;p&gt;例如阿里云provider 的这个&lt;a href="https://github.com/alibaba/terraform-provider/blob/master/alicloud/resource_alicloud_slb.go#L32"&gt;片段&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;func resourceAliyunSlb() *schema.Resource {
    return &amp;amp;schema.Resource{
        Create: resourceAliyunSlbCreate,
        Read:   resourceAliyunSlbRead,
        Update: resourceAliyunSlbUpdate,
        Delete: resourceAliyunSlbDelete,
        Importer: &amp;amp;schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },

        Schema: map[string]*schema.Schema{
            &amp;quot;name&amp;quot;: &amp;amp;schema.Schema{
            Type:         schema.TypeString,
            Optional:     true,
            ValidateFunc: validateSlbName,
            Computed:     true,
            },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ValidateFunc 调用的 &lt;a href="https://github.com/alibaba/terraform-provider/blob/master/alicloud/validators.go#L305"&gt;validateSlbName&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// SLB
func validateSlbName(v interface{}, k string) (ws []string, errors []error) {
    if value := v.(string); value != &amp;quot;&amp;quot; {
        if len(value) &amp;lt; 1 || len(value) &amp;gt; 80 {
            errors = append(errors, fmt.Errorf(
                    &amp;quot;%q must be a valid load balancer name characters between 1 and 80&amp;quot;,
                    k))
                return
            }
    }


    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看看阿里云官网文档的&lt;a href="https://help.aliyun.com/document_detail/27577.html?spm=5176.doc27566.2.4.K5ta6Q"&gt;要求&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;LoadBalancerName

String

负载均衡实例的显示名称。
取值：用户自定义字符串。长度限制为1-80个字符，允许包含字母、数字、‘-’、‘/’、‘.’、‘_’这些字符。

默认值：无。

不指定该参数时，默认由系统分配一个实例名称。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在实现其他Provider 时，对着API 文档敲即可。&lt;/p&gt;
&lt;h2&gt;resource_*.go&lt;/h2&gt;
&lt;p&gt;provider 的resource 可以认为是云服务的各项产品了，例如腾讯云的CLB，CDN，CVM 等。按照要求实现增删改查的函数即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;func resourceQcloudClb() *schema.Resource {
    return &amp;amp;schema.Resource{
        Create: resourceQcloudClbCreate,
        Read:   resourceQcloudClbRead,
        Update: resourceQcloudClbUpdate,
        Delete: resourceQcloudClbDelete,
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Create&lt;/h3&gt;
&lt;p&gt;Create 是创建时调用的函数，创建成功后需要调用一下func (*ResourceData) SetId：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SetId sets the ID of the resource. If the value is blank, then the resource is destroyed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;d.SetId(clb.UnLoadBalancerIds[clb.DealIds[0]][0])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个ID 必须唯一。&lt;/p&gt;
&lt;h3&gt;Read&lt;/h3&gt;
&lt;p&gt;获取对应ID 资源的最新状态。如果有一些资源的属性在服务端可以修改的，拉取到最新的，得更新本地的状态，例如CLB 的名称。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Set sets the value for the given key.&lt;/p&gt;
&lt;p&gt;If the key is invalid or the value is not a correct type, an error will be returned.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;d.Set(&amp;quot;load_balancer_type&amp;quot;, clb.LoadBalancerSet[0].LoadBalancerType)
d.Set(&amp;quot;forward&amp;quot;, clb.LoadBalancerSet[0].LoadBalancerName)
d.Set(&amp;quot;load_balancer_name&amp;quot;, clb.LoadBalancerSet[0].LoadBalancerName)
d.Set(&amp;quot;domain_prefix&amp;quot;, clb.LoadBalancerSet[0].Domain)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Update&lt;/h3&gt;
&lt;p&gt;这个函数相对比较复杂，更新tf 文件中资源属性的时候，会调用这个函数，apply 到服务端。一般用 d.HasChange 来检测对应的属性是否改变：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;d.Partial(true)

...

if d.HasChange(&amp;quot;load_balancer_name&amp;quot;) {
    args.LoadBalancerName = d.Get(&amp;quot;load_balancer_name&amp;quot;).(string)
    argList = append(argList, &amp;quot;load_balancer_name&amp;quot;)
    _, err := conn.ModifyLoadBalancerAttributes(args, argList)
    if err != nil {
        return err
    }

    d.SetPartial(&amp;quot;load_balancer_name&amp;quot;)
}

...

d.Partial(false)
return resourceQcloudClbRead(d, meta)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;code&gt;func (*ResourceData) HasChange&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HasChange returns whether or not the given key has been changed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;func (*ResourceData) Partial&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Partial turns partial state mode on/off.&lt;/p&gt;
&lt;p&gt;When partial state mode is enabled, then only key prefixes specified by SetPartial will be in the final state. This allows providers to return partial states for partially applied resources (when errors occur).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;func (*ResourceData) SetPartial&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SetPartial adds the key to the final state output while in partial state mode. The key must be a root key in the schema (i.e. it cannot be "list.0").&lt;/p&gt;
&lt;p&gt;If partial state mode is disabled, then this has no effect. Additionally, whenever partial state mode is toggled, the partial data is cleared.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Update 一般能用HasChange 应付，但是如果遇到出现子资源这种需求时，就比较麻烦。例如阿里云的一个SLB 后面会挂很多listener（监听器） ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Create a new load balancer for classic
resource &amp;quot;alicloud_slb&amp;quot; &amp;quot;classic&amp;quot; {
name                 = &amp;quot;test-slb-tf&amp;quot;
internet             = true
internet_charge_type = &amp;quot;paybybandwidth&amp;quot;
bandwidth            = 5

listener = [
    {
        &amp;quot;instance_port&amp;quot; = &amp;quot;2111&amp;quot;
        &amp;quot;lb_port&amp;quot;       = &amp;quot;21&amp;quot;
        &amp;quot;lb_protocol&amp;quot;   = &amp;quot;tcp&amp;quot;
        &amp;quot;bandwidth&amp;quot;     = &amp;quot;5&amp;quot;
    },
    {
        &amp;quot;instance_port&amp;quot; = &amp;quot;8000&amp;quot;
        &amp;quot;lb_port&amp;quot;       = &amp;quot;80&amp;quot;
        &amp;quot;lb_protocol&amp;quot;   = &amp;quot;http&amp;quot;
        &amp;quot;bandwidth&amp;quot;     = &amp;quot;5&amp;quot;
    },
    {
        &amp;quot;instance_port&amp;quot; = &amp;quot;1611&amp;quot;
        &amp;quot;lb_port&amp;quot;       = &amp;quot;161&amp;quot;
        &amp;quot;lb_protocol&amp;quot;   = &amp;quot;udp&amp;quot;
        &amp;quot;bandwidth&amp;quot;     = &amp;quot;5&amp;quot;
    },
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种在Update 时就比较尴尬，因为listener 就是一个list，没有唯一标识，修改一下端口啥的，总不能把所有listener 删除再添加一遍。&lt;/p&gt;
&lt;p&gt;阿里云的做法是通过&lt;code&gt;func (*ResourceData) GetChange&lt;/code&gt; 难道新、旧的值，互相对比，把改变的listener 删除掉，修改后的listener 新增，&lt;a href="https://github.com/terraform-providers/terraform-provider-alicloud/blob/974aa3101f94ab18099c1284274128c042a902bb/alicloud/resource_alicloud_slb.go#L335,#L362"&gt;HasChange("listener")&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不过我在实现腾讯云的CLB Listener 时候，采用的做法是用一个&lt;code&gt;load_balancer_id&lt;/code&gt;  指向CLB 的资源ID，这样建立起对应关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;resource &amp;quot;qcloud_clb_listener&amp;quot; &amp;quot;tcp1234&amp;quot; {
    depends_on = [&amp;quot;qcloud_clb.example&amp;quot;]
    load_balancer_id = &amp;quot;${qcloud_clb.example.id}&amp;quot;
    listener_name = &amp;quot;abcxxxxxsodo&amp;quot;
    load_balancer_port = 1234
    instance_port = 4567
    protocol = 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不过我在给listener 加backend server 的时候，感觉还是得用阿里那种做法。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href="https://github.com/hashicorp/terraform/issues/2275"&gt;helper/schema feature: nestable resources #2275&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Delete&lt;/h3&gt;
&lt;p&gt;把本地tf 文件对应的资源删除时，会调用这个函数，删除服务端的资源。&lt;/p&gt;
&lt;h2&gt;data_source_*.go&lt;/h2&gt;
&lt;p&gt;这个没实现过，不过看起来和resource 差不多，只是大量的属性是Computed，供resource 使用。可以参考阿里云的datasource 实现。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最后，感觉腾讯云和AWS 之间，还差十个阿里云，手动再见。&lt;/p&gt;</content><category term="2017"></category><category term="terraform"></category><category term="golang"></category></entry><entry><title>基于OpenResty 的whoami.akaimai.net 实现</title><link href="https://fangpsh.github.io/posts/2017/2017-08-30.html" rel="alternate"></link><published>2017-08-30T00:00:00+08:00</published><updated>2017-08-30T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-08-30:/posts/2017/2017-08-30.html</id><summary type="html">&lt;p&gt;上次收集整理[[170822 获取Local DNS 地址信息]]) 的时候看到akamai 的&lt;code&gt;whoami.akamai.net&lt;/code&gt;，想起之前看到&lt;a href="https://twitter.com/agentzh/status/767963492850601985"&gt;agentzh&lt;/a&gt; 基于OpenResty实现了一个权威DNS 服务器，感觉可以用openresty 简单快速的实 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上次收集整理[[170822 获取Local DNS 地址信息]]) 的时候看到akamai 的&lt;code&gt;whoami.akamai.net&lt;/code&gt;，想起之前看到&lt;a href="https://twitter.com/agentzh/status/767963492850601985"&gt;agentzh&lt;/a&gt; 基于OpenResty实现了一个权威DNS 服务器，感觉可以用openresty 简单快速的实现。&lt;/p&gt;
&lt;p&gt;找到agentzh 当时的 &lt;a href="https://gist.github.com/agentzh/6c50d37510daef792ed220fa0d970393"&gt;gist&lt;/a&gt;，第一次学习OpenResty ，决定照猫画虎。看起来要在OpenResty 里面接受dns 数据包，并且返回，需要用到&lt;a href="https://github.com/openresty/stream-lua-nginx-module"&gt;stream-lua-nginx-module&lt;/a&gt;这个模块，这里要注意的时候，截至目前(2017-08-30) master 分支还不支持 &lt;code&gt;ngx.req.udp_socket&lt;/code&gt; ，agentzh 当时hack 的代码都在 bloody-dns-server 分支下面。&lt;/p&gt;
&lt;h2&gt;编译OpenResty&lt;/h2&gt;
&lt;p&gt;说来惭愧，编译OpenResty费了好大一番工夫。先是没有看清stream-lua-nginx-modele 的分支，直接用master 分支的编译，测试代码的时候直接返回 &lt;code&gt;ngx.req.udp_socket&lt;/code&gt; 是空。&lt;/p&gt;
&lt;p&gt;然后用bloody-dns-server 分支编译，又遇到 mmdb 库的问题。Mac OS 下需要在编译的时候指定maxminddb 的库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./configure \
--with-cc-opt=&amp;quot;-I/usr/local/opt/openssl/include/ -I/usr/local/opt/pcre/include/&amp;quot; \
--with-ld-opt=&amp;quot;-L/usr/local/opt/openssl/lib/ -L/usr/local/opt/pcre/lib/ -L/opt/mmdb/lib -lmaxminddb&amp;quot; \ 
--with-stream \
--with-stream_ssl_module \
--add-module=./bundle/stream-lua-nginx-module
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不然会出现一堆:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;undefined reference to `MMDB_open&amp;#39;
undefined reference to `MMDB_strerror&amp;#39;
undefined reference to `MMDB_lookup_sockaddr&amp;#39;
ndefined reference to `MMDB_strerror&amp;#39;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我看了一下 stream-lua-nginx-module 的&lt;code&gt;build.sh&lt;/code&gt; 是显式指定了&lt;code&gt;-L/opt/mmdb/lib -lmaxminddb&lt;/code&gt;，但是nginx 编译的时候没指定，就会报错。&lt;/p&gt;
&lt;p&gt;相关问题：&lt;a href="https://stackoverflow.com/questions/32425361/ld-symbols-not-found-for-architecture-x86-64-clang-linker-command-failed"&gt;ld: symbols not found for architecture x86_64, clang: linker command failed&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;遇到错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx: [alert] cannot open file /opt/mmdb/database/GeoLite2-Country.mmdb for reading: Error opening the specified MaxMind DB file in
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;去Maxmind 官网下一个，丢到对应的目录即可。&lt;/p&gt;
&lt;p&gt;另外编译的时候要注意选择版本，我选择的是OpenResty-1.11.2.5，其中的Nginx 的版本是&lt;code&gt;1.11.2&lt;/code&gt;，太新的Nginx 可能没测试过。&lt;/p&gt;
&lt;h2&gt;实现whoami.akamai.net&lt;/h2&gt;
&lt;p&gt;编译成功之后，就是开始动手了。&lt;/p&gt;
&lt;p&gt;首先是DNS 报文格式，参考这2篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.ietf.org/rfc/rfc1035.txt"&gt;rfc1035 DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zhujunwu.cn/python-dns-server/"&gt;Python利用socket架设DNS服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及自己用wireshark 抓包分析。&lt;/p&gt;
&lt;p&gt;对着文档一个一个bit 校对，对任何DNS 查询报文，都拿出它的IP，然后返回一条A记录就好了，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="whoami" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301155214.png"&gt;&lt;/p&gt;
&lt;h2&gt;上线&lt;/h2&gt;
&lt;p&gt;我在个人的VPS 上部署了一个，再添加一条NS 记录，注意需要是域名，不能添加IP：&lt;/p&gt;
&lt;p&gt;&lt;img alt="whoami_ns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301155222.png"&gt;&lt;/p&gt;
&lt;p&gt;再 &lt;code&gt;dig whoami.example.com&lt;/code&gt; 或者 &lt;code&gt;ping whoami.example.com&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="whoami_dig" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301155233.png"&gt;&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;实现代码: &lt;a href="https://gist.github.com/fangpsh/c7de2d718f6c50befe389eb646e60426"&gt;whoami.lua&lt;/a&gt;&lt;/p&gt;</content><category term="2017"></category><category term="openresty"></category><category term="dns"></category></entry><entry><title>获取Local DNS 地址信息</title><link href="https://fangpsh.github.io/posts/2017/2017-08-22.html" rel="alternate"></link><published>2017-08-22T00:00:00+08:00</published><updated>2017-08-22T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-08-22:/posts/2017/2017-08-22.html</id><summary type="html">&lt;p&gt;在网页中获取local dns 不太方便，看看大家是怎么做的。  &lt;/p&gt;
&lt;h2&gt;阿里云CDN 诊断工具&lt;/h2&gt;
&lt;p&gt;阿里云CDN提供的&lt;a href="https://cdn.dns-detect.alicdn.com/https/doc.html"&gt;阿里昆仑用户诊断工具&lt;/a&gt;：&lt;br&gt;
&lt;img alt="alicdn_local_dns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171842.png"&gt;  &lt;/p&gt;
&lt;p&gt;获取到local dns 的这 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在网页中获取local dns 不太方便，看看大家是怎么做的。  &lt;/p&gt;
&lt;h2&gt;阿里云CDN 诊断工具&lt;/h2&gt;
&lt;p&gt;阿里云CDN提供的&lt;a href="https://cdn.dns-detect.alicdn.com/https/doc.html"&gt;阿里昆仑用户诊断工具&lt;/a&gt;：&lt;br&gt;
&lt;img alt="alicdn_local_dns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171842.png"&gt;  &lt;/p&gt;
&lt;p&gt;获取到local dns 的这个请求：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;https://123-66-35-57-122894414.dns-detect.alicdn.com/api/cdnDetectHttps?method=commitDetectHttps&amp;amp;detectId=122894414&amp;amp;cb=jQuery110102821084573750223_1503489263656&amp;amp;_=1503489263658

一个奇怪的域名，每次访问都不一样：
123-66-35-57-122894414.dns-detect.alicdn.com
设备ID ：
detectId=122894414
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用户访问一个域名，浏览器给按照分配的local dns 发起dns 迭代查询，最后向域名的权威服务器名查询，最后这一步的时候可以得到local dns 的地址。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="microsoft-offical-course-20410c07-18-638" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171853.png"&gt;&lt;br&gt;
&lt;strong&gt;图片来源：&lt;a href="https://www.slideshare.net/gameaxt/microsoft-offical-course-20410c07"&gt;Microsoft Offical Course 20410C_07&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要怎么把local dns 地址和用户对应起来呢？这就是前面那个奇怪的域名的作用，每次的域名都不同，当浏览器访问的时候，我们就可以根据这个唯一域名再结合域名服务器的信息，把对应的local dns 返回给用户。&lt;/p&gt;
&lt;h2&gt;腾讯华佗&lt;/h2&gt;
&lt;p&gt;腾讯的华佗分析系统&lt;a href="http://utp.qq.com/"&gt;utp.qq.com&lt;/a&gt;或&lt;a href="http://ping.huatuo.qq.com/"&gt;ping.huatuo.qq.com&lt;/a&gt;：&lt;br&gt;
&lt;img alt="qq_ldns_1" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171906.png"&gt;  &lt;/p&gt;
&lt;p&gt;腾讯这服务现在好像挂了。。不过不妨碍我们分析它的原理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;http://utp.qq.com/getldns.php?d=
1503491352464.1724.sngdia.imtmp.net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个&lt;code&gt;imtmp.net&lt;/code&gt; 的域名看下whois 信息，属于腾讯：&lt;br&gt;
&lt;img alt="imtmp.net" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171920.png"&gt;&lt;/p&gt;
&lt;p&gt;前面这个数字看着像时间戳，做法应该和阿里的做法一样，那用户对这个域名的查询在哪里呢。&lt;/p&gt;
&lt;p&gt;翻下代码：&lt;br&gt;
&lt;img alt="qq_ldns_2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171939.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;getDNS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/getldns.php?d=&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;dns_domain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ldndsip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;typeof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;saveDns&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;function&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="nx"&gt;saveDns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ldndsip&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ldnsIMG&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;img&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;IMG&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;img&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;img&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;style&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;body&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;img&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;dns_domain&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;getTime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1000000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.sngdia.imtmp.net&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="nx"&gt;img&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;src&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;dns_domain&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;果然和时间戳有关。翻下前面，也找到了这个图片的请求：&lt;br&gt;
&lt;img alt="qq_ldns_3" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171950.png"&gt;&lt;/p&gt;
&lt;p&gt;多此一举？&lt;/p&gt;
&lt;h2&gt;网易DNS 检测工具&lt;/h2&gt;
&lt;p&gt;网易也有一个&lt;a href="https://nstool.netease.com/"&gt;DNS检测工具&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="netease_ldns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301172004.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;GET https://only-425945-183-240-25-249.nstool.netease.com/
&amp;gt;Response: 您好，尊敬的网易用户&amp;lt;br&amp;gt;您的IP地址信息: 183.240.25.249 广东省广州市移动&amp;lt;br&amp;gt;您的DNS地址信息: 211.136.209.212 广东省广州市移动&amp;lt;br&amp;gt;您的DNS设置正确
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也是类似的做法。&lt;/p&gt;
&lt;h2&gt;豆瓣用户检测工具&lt;/h2&gt;
&lt;p&gt;发现豆瓣也有一个&lt;a href="http://doctor.douban.com/"&gt;检测工具&lt;/a&gt;:&lt;br&gt;
&lt;img alt="douban_ldns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301172015.png"&gt;&lt;/p&gt;
&lt;p&gt;居然直接用阿里的接口。&lt;/p&gt;
&lt;h2&gt;whoami.akamai.net&lt;/h2&gt;
&lt;p&gt;akamai 提供了一个域名，直接ping 或者dig 就可以获取local dns地址，这个很酷，直接把local dns 当作查询结果返回：&lt;/p&gt;
&lt;p&gt;&lt;img alt="akamai_ldns" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301172035.png"&gt;&lt;/p&gt;
&lt;h2&gt;Anycast&lt;/h2&gt;
&lt;p&gt;使用以上工具多次检测，如果会发现检测到的地址不同，可能是由于local dns 做了&lt;a href="https://en.wikipedia.org/wiki/Anycast"&gt;Anycast&lt;/a&gt;，或者有出口IP 有多个造成。&lt;/p&gt;</content><category term="2017"></category><category term="dns"></category><category term="web"></category></entry><entry><title>给Pelican 添加Twitter Card</title><link href="https://fangpsh.github.io/posts/2017/2017-08-21.html" rel="alternate"></link><published>2017-08-21T00:00:00+08:00</published><updated>2017-08-21T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-08-21:/posts/2017/2017-08-21.html</id><summary type="html">&lt;p&gt;之前发Tweet 的时候，发现有些链接能够被识别出内容，带着一个“卡片”。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_demo" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165513.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_demo_2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165525.png"&gt;&lt;/p&gt;
&lt;p&gt;一开始以为是Twitter 对某些网站的特殊照顾，最近喵了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前发Tweet 的时候，发现有些链接能够被识别出内容，带着一个“卡片”。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_demo" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165513.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_demo_2" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165525.png"&gt;&lt;/p&gt;
&lt;p&gt;一开始以为是Twitter 对某些网站的特殊照顾，最近喵了下某个网址的源码，才明白是需要自己设置的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_meta" src="twitter_card_meta.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;twitter:card 是类型，常见的有summary 和summary_large_image&lt;/li&gt;
&lt;li&gt;twitter:site 是网站的twitter 帐号&lt;/li&gt;
&lt;li&gt;twitter:title 卡片显示的标题&lt;/li&gt;
&lt;li&gt;twitter:description 卡片显示的内容概述&lt;/li&gt;
&lt;li&gt;twitter:images 卡片中的图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;细节可以参考：&lt;a href="https://dev.twitter.com/cards/types/summary"&gt;Twitter Developer Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于我的个人博客来说，summary 类似的卡片就够用了，给每篇文章找个配图也挺累的。&lt;/p&gt;
&lt;p&gt;博客是用Pelican 生成的，找了一下插件，果然有一个，我fork 了下，修了一个bug ：&lt;a href="https://github.com/fangpeishi/twitter_card"&gt;twitter_card&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;按照插件的说明搞完之后，测试一下，可以用这个工具：&lt;a href="https://cards-dev.twitter.com/validator"&gt;Card validator&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="twitter_card_validator" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165545.png"&gt;&lt;/p&gt;
&lt;p&gt;搞定，然而并没有什么卵用。&lt;/p&gt;</content><category term="2017"></category><category term="pelican"></category></entry><entry><title>英文缩写字典</title><link href="https://fangpsh.github.io/posts/2017/2017-07-18.html" rel="alternate"></link><published>2017-07-18T00:00:00+08:00</published><updated>2017-07-18T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-07-18:/posts/2017/2017-07-18.html</id><summary type="html">&lt;p&gt;&lt;img alt="abbreviations_dictionary" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165301.png"&gt;&lt;/p&gt;
&lt;p&gt;好久之前在V2EX 见过网友分享的 &lt;a href="https://www.v2ex.com/t/227197"&gt;发现一个查单词缩写的网站，妈妈再也不用担心我给变量命名了！&lt;/a&gt;，一直收藏着挺好用，不过 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="abbreviations_dictionary" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165301.png"&gt;&lt;/p&gt;
&lt;p&gt;好久之前在V2EX 见过网友分享的 &lt;a href="https://www.v2ex.com/t/227197"&gt;发现一个查单词缩写的网站，妈妈再也不用担心我给变量命名了！&lt;/a&gt;，一直收藏着挺好用，不过由于个人一直在用的是Mac OS 自带的Dictionary App，如果能做个专门查缩写的字典库，就更方便了。&lt;/p&gt;
&lt;p&gt;先要看看怎么创建一个Mac Dictionary App 的字典文件。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.nagpals.com/mac-dictionaries/"&gt;Create Custom Dictionaries For Mac OSX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/DictionaryServicesProgGuide/Introduction/Introduction.html"&gt;Dictionary Services Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个链接是一篇博文，比较老了，可以看一下，主要还是看第二个官方的指南。基本来说照着做即可，不过一开始就遇到一个问题，生成字典需要的Dictionary Development Kit 不见了。现在新版本的Xcode 都不带这个工具了，得自己去&lt;a href="https://developer.apple.com"&gt;developer.apple.com&lt;/a&gt;下Auxiliary Tools。下载之后解压开，把Dictionary Development Kit 拷贝到自己喜欢的目录，同时可以看下文件夹里面的project_templates ，照着这个改改即可。记得要改Makefile 里面的&lt;code&gt;DICT_BUILD_TOOL_DIR&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://apple.stackexchange.com/questions/80099/how-can-i-create-a-dictionary-for-mac-os-x"&gt;How can I create a dictionary for Mac OS X?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概知道怎么构建字典之后，就开始找缩写的来源了，扒了下面这2个网站的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://public.oed.com/how-to-use-the-oed/abbreviations/"&gt;public.oed.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.easypacelearning.com/english-books/english-books-for-download-pdf/category/33-3-dictionaries-to-download-in-pdf"&gt;easypacelearning.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只收录缩写，不收录首字母大写，例如CCTV、NBA 这种，因为觉得首字母大写没啥用，这个字典的出发点就是我敲代码的时候，函数名太长了想找缩写。&lt;/p&gt;
&lt;p&gt;手动整理加一些简单的命令，得到初始文件，再写个脚本生成需要的xml，最后得到字典，效果如上图。&lt;/p&gt;
&lt;p&gt;字典库下载、相关源码：&lt;a href="https://github.com/fangpsh/Abbreviations"&gt;fangpsh/Abbreviations&lt;/a&gt;。&lt;/p&gt;</content><category term="2017"></category><category term="dictionary"></category><category term="mac"></category></entry><entry><title>Pelican插件：CDN Support</title><link href="https://fangpsh.github.io/posts/2017/2017-07-10.html" rel="alternate"></link><published>2017-07-10T00:00:00+08:00</published><updated>2017-07-10T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-07-10:/posts/2017/2017-07-10.html</id><summary type="html">&lt;p&gt;之前用WordPress 做博客的时候，用过一个&lt;a href="https://srd.wordpress.org/plugins/wp-super-cache/"&gt;WP Super Cache&lt;/a&gt; 的插件，&lt;br&gt;
这个插件可以把WordPress 的页面静态化，然后用内存或者磁盘等做缓存，提升性 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前用WordPress 做博客的时候，用过一个&lt;a href="https://srd.wordpress.org/plugins/wp-super-cache/"&gt;WP Super Cache&lt;/a&gt; 的插件，&lt;br&gt;
这个插件可以把WordPress 的页面静态化，然后用内存或者磁盘等做缓存，提升性能。&lt;/p&gt;
&lt;p&gt;其中有个选项是开启CDN 支持，开启这种功能之后，插件会把所有指向本站的静态资源（CSS，JS，各类图片）的URL 替换为CDN 的URL，当然填入的CDN 域名需要配置好回源。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wp-super-cache" src="https://www.shoutmeloud.com/wp-content/uploads/2015/05/Enabling-cache-with-WP-Super-cache-plugin.png"&gt;&lt;/p&gt;
&lt;p&gt;最近帮妹子做了一个网站，想着各种优化，又想起这事。这个网站是用Pelican 生成的，所有就有了这个插件。&lt;/p&gt;
&lt;p&gt;Pelican 插件可以注册不同阶段的信号，选择了&lt;a href="http://docs.getpelican.com/en/3.6.3/plugins.html"&gt;&lt;code&gt;finalized&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;finalized:
invoked after all the generators are executed and just before pelican exits useful for custom post processing actions, such as: - minifying js/css assets. - notify/ping search engines with an updated sitemap.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用&lt;code&gt;re.sub&lt;/code&gt; 模块过滤生成的html 文件，替换静态资源的URL，再写回文件即可。&lt;/p&gt;
&lt;p&gt;源代码及设置说明：https://github.com/fangpsh/cdn_support&lt;/p&gt;
&lt;p&gt;当然，替换之后的CDN 域名，需要提前做好接入和回源设置等工作。&lt;/p&gt;</content><category term="2017"></category><category term="pelican"></category></entry><entry><title>图片优化笔记</title><link href="https://fangpsh.github.io/posts/2017/2017-06-08.html" rel="alternate"></link><published>2017-06-08T15:11:11+08:00</published><updated>2017-06-08T15:11:11+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-06-08:/posts/2017/2017-06-08.html</id><summary type="html">&lt;p&gt;这里说的图片优化，目标是想尽可能降低图片大小，但又要保证质量不错，非常矛盾。不过降低图片大小，可以剩一大笔流量 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这里说的图片优化，目标是想尽可能降低图片大小，但又要保证质量不错，非常矛盾。不过降低图片大小，可以剩一大笔流量钱，降低负载，还能提升用户体验，值得花点功夫。&lt;/p&gt;
&lt;p&gt;前端方面有一些关于图片加载速度的优化，例如CSS 画图，CSS 合并素材，甚至用CSS 把图片Base64 编码（不推荐），和这份笔记关系不大。&lt;/p&gt;
&lt;h2&gt;格式选择&lt;/h2&gt;
&lt;p&gt;不同的需求选择不同的格式, JPEG 能够满足的需求没必要选择PNG。&lt;/p&gt;
&lt;p&gt;&lt;img alt="format-tree" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301155951.png"&gt;&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href="http://jixianqianduan.com/frontend-weboptimize/2015/11/17/front-end-image-optmize.html"&gt;《web前端图片极限优化策略》&lt;/a&gt;，原图是Google 的&lt;a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization"&gt;Image Optimization&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;WebP、SharpP&lt;/h3&gt;
&lt;p&gt;目前对于WebP 的支持已经很好了，所以新业务能够选择WebP，就选WebP。&lt;br&gt;
豆瓣的相册切到了WebP，另外提供了一个让图片变清晰的思路：把图片尺寸拉大到2倍，然后缩小成1倍。&lt;br&gt;
图片清晰度大大提升，还降低了图片大小：&lt;code&gt;2x WebP(73k) &amp;lt; 1x JPG(119k)&lt;/code&gt;，效果如下图（图片来源 豆瓣 波希米亚的日记）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="douban.jpg" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160002.png"&gt;&lt;/p&gt;
&lt;p&gt;不过采用WebP 之后，用户“另存为”不太方便，毕竟大家对PNG和JPEG 比较熟悉。&lt;/p&gt;
&lt;p&gt;豆瓣的WebP 实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.douban.com/note/613447642/"&gt;《这个世界又美好了一点点——相册篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.douban.com/note/616303673/"&gt;《这个世界又美好了一点点——日记篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有趣的是，WebP 基于&lt;a href="https://zh.wikipedia.org/wiki/VP8"&gt;VP8&lt;/a&gt;，VP8 的下一代是&lt;a href="https://zh.wikipedia.org/wiki/VP9"&gt;VP9&lt;/a&gt;，VP9 的对手是&lt;a href="https://zh.wikipedia.org/zh/%E9%AB%98%E6%95%88%E7%8E%87%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81"&gt;HEVC/H.265&lt;/a&gt;，&lt;a href="https://zh.wikipedia.org/wiki/BPG"&gt;BGP&lt;/a&gt; 基于HEVC，据说表现比WebP 好很多，不知为啥应用不多，因为专利？&lt;/p&gt;
&lt;p&gt;腾讯基于HEVC 搞出了一个SharpP 格式，听说秒天秒地，目前已在腾讯云CDN 上应用，不过接入的大都是腾讯自家的产品：&lt;/p&gt;
&lt;p&gt;&lt;img alt="SharpP.jpg" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160018.png"&gt;&lt;/p&gt;
&lt;p&gt;图片模煳的没办法:( ，&lt;br&gt;
图片来源：&lt;a href="https://www.qcloud.com/community/article/164816001481011868"&gt;《图片流量节省大杀器：基于 CDN 的 sharpP 自适应图片技术实践》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看起来确实不错，听说在移动端解码速度也很快，不过如此大规模使用估计花了不少专利费。第三方用户使用也不方便，得使用&lt;a href="https://x5.tencent.com/tbs/"&gt;X5内核&lt;/a&gt;，且只能用腾讯云的CDN，这样被活活绑死的事情，愿意的人应该不多。另外腾讯还搞了一个&lt;a href="http://www.ifanr.com/832678"&gt;TPG&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不过各种专利之争，只会导致推广受阻，我们还是想想怎么优化JPEG 和PNG 吧。&lt;/p&gt;
&lt;p&gt;各种格式的介绍可以参考：&lt;a href="http://jixianqianduan.com/frontend-weboptimize/2015/11/17/front-end-image-optmize.html"&gt;《web前端图片极限优化策略》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Yelp 的图片优化经验&lt;/h2&gt;
&lt;p&gt;写这篇笔记，也是因为看到Yelp 的一篇博文：&lt;a href="https://engineeringblog.yelp.com/2017/06/making-photos-smaller.html"&gt;Making Photos Smaller Without Quality Loss&lt;/a&gt;，然后延伸看了一些东西。
Yelp 的优化围绕JPEG 和PNG，而且看起来很通用，值得学习。&lt;/p&gt;
&lt;h3&gt;用Pillow 优化图片&lt;/h3&gt;
&lt;p&gt;Yelp 用&lt;a href="https://python-pillow.org/"&gt;Pillow &lt;/a&gt;来保存图片，Pillow 支持&lt;a href="http://pillow.readthedocs.io/en/4.1.x/handbook/image-file-formats.html?highlight=optimize"&gt;optimize&lt;/a&gt;的参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;optimize
If present and true, indicates that the encoder should make an extra pass over the image in order to select optimal encoder settings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外也还有其他优化方式，例如大名鼎鼎的&lt;a href="https://tinypng.com/"&gt;Tinypng&lt;/a&gt;，&lt;a href="https://zhitu.isux.us/"&gt;智图&lt;/a&gt; 等。推荐Pillow，Pillow 的效果不差，而且开源、免费。&lt;/p&gt;
&lt;h3&gt;选择渐进式（Progressive） JPEG&lt;/h3&gt;
&lt;p&gt;常见的JPEG 有2种，基本式（Baseline）和渐进式（Progressive），明显的区别是前者从上至下加载，后者加载过程从模煳到清晰。参考下图：
&lt;img alt="progressive" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160342.png"&gt;&lt;/p&gt;
&lt;p&gt;渐进式一般会比基本式小一些，而且加载速度更快。&lt;/p&gt;
&lt;p&gt;&lt;img alt="speed" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160125.png"&gt;&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/"&gt;《渐进式jpeg(progressive jpeg)图片及其相关》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而且从用户体验上来说，从模煳到清晰比从空白展开到全部，前者体验更好。&lt;/p&gt;
&lt;p&gt;关于为何渐进式会更小，需要从JPEG 的原理说起（对这一块也一知半解），JPEG被按照8x8，从坐标变换，DCT 变换，重排列，最后量化，得到的结果左上角是大量正数，右下角聚集大量0，然后再Zig-Zag 扫描，再用霍夫曼编码压缩。渐进式的情况下，相当于分层了，前面的扫描包含着大量正数，后面的扫描关注更多细节，包含大量的0，这样导致0 一起出现的概率增加，从而更易于压缩。&lt;/p&gt;
&lt;p&gt;对此一知半解，看到DCT 变换，涉及到傅里叶变换，感觉高数都忘记了，惭愧，有兴趣的同学请自行阅读以下两份资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://twins.ee.nctu.edu.tw/courses/soclab_04/lab_hw_pdf/proj1_jpeg_introduction.pdf"&gt;台湾国立交通大学电子工程系的一份实验手册：JPEG 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.codingnow.com/2000/download/jpeg.txt"&gt;云风：JPEG 简易文档 V2.15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;大尺寸的PNG 判断，然后转换为JPEG&lt;/h3&gt;
&lt;p&gt;PNG 无损压缩，体积都很大，所以能不用PNG 就不用，不过如果像Yelp 这种，用户会上传PNG 的话，例如iPhone 的屏幕截图保存的格式就是PNG，完全可以转换为JPEG。Yelp 遇到的问题是如果用户传的是LOGO 之类的，需要无损，就不能转换成JPEG，所以他们想了一个办法：&lt;br&gt;
生成一份PNG 的缩略图，如果大于300KiB，再检查这个缩略图是否包含超过2^16 种不同的色彩。一般来说LOGO 的色彩都比较少和单一。&lt;/p&gt;
&lt;h3&gt;动态设置JPEG 质量因子（Quality）&lt;/h3&gt;
&lt;p&gt;JPEG 有一个质量因子，从0到100，表示图片的质量从差到好。Yelp 做了一个实验，发现在quality 在80~85 之间的时候，图片效果肉眼看基本没差别，&lt;a href="https://zh.wikipedia.org/wiki/%E7%B5%90%E6%A7%8B%E7%9B%B8%E4%BC%BC%E6%80%A7"&gt;SSIM&lt;/a&gt; 在0.9~0.95。SSIM 中文名称：结构相似性，用来判断两张图片的相似程度，拿一张压缩后的图片和原图比较，相似越高，说明失真越小，数学原理可以看维基百科，Yelp 用&lt;a href="https://github.com/jterrace/pyssim/"&gt;pyssim&lt;/a&gt;来计算SSIM。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ssims-strategies" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160134.png"&gt;&lt;/p&gt;
&lt;p&gt;质量设置为80~85 之间某一个值的时候，SSIM 还能保持在0.9到0.95，多奇妙啊。Yelp 提供了一段脚本来找出图片合适的quality 值：&lt;a href="https://gist.github.com/thebostik/cfc9f059459cfefd1f61134b48291436"&gt;dynamic_quality.py&lt;/a&gt;，用类似二分法猜数字的方法:P。&lt;/p&gt;
&lt;p&gt;不过个人觉得对于一些色彩比较单一的图片，可以激进一点，例如从20~85 开始找最合适的压缩比。为什么色彩单一的可以调低质量呢，因为肉眼看不出来啊。所以是不是可以延伸一下，用大量的训练数据，用AI 的方法找到最合适的quality ？想起来Google之前推出的&lt;a href="https://www.blog.google/products/google-plus/saving-you-bandwidth-through-machine-learning/"&gt;RAISR&lt;/a&gt;，非常厉害。&lt;/p&gt;
&lt;p&gt;&lt;img alt="RAISR" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160144.png"&gt;&lt;/p&gt;
&lt;p&gt;扯远了。&lt;/p&gt;
&lt;p&gt;Yelp 博客提到的其他两篇相关文章，类似的思路，并且文中都有成型的开源工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://codeascraft.com/2017/05/30/reducing-image-file-size-at-etsy/"&gt;Reducing Image File Size at Etsy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@duhroach/reducing-jpg-file-size-e5b27df3257c"&gt;Reducing JPG File size&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用Mozjpeg 替代libjpeg-turbo 或 libjpeg，性能提升明显。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Chroma_subsampling"&gt;Subsampling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尝试有损的PNG 编码&lt;/li&gt;
&lt;li&gt;SVG 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前，工作上没有实践的机会，纸上谈兵，希望以后有机会练手、实践。&lt;/p&gt;</content><category term="2017"></category><category term="image"></category></entry><entry><title>htop 解释</title><link href="https://fangpsh.github.io/posts/2017/2017-04-05.html" rel="alternate"></link><published>2017-04-05T10:18:30+08:00</published><updated>2017-04-05T10:18:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-04-05:/posts/2017/2017-04-05.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;"Explanation of everything you can see in htop/top on Linux"&lt;/p&gt;
&lt;p&gt;“解释你在Linux 上htop/top 中看到的所有内容”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://peteris.rocks/blog/htop/"&gt;原文地址&lt;/a&gt;：&lt;ul&gt;
&lt;li&gt;https://peteris.rocks/blog/htop/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遵循原文许可协议：&lt;a href="http://www.apache.org/licenses/LICENSE-2.0"&gt;Apache 2.0 license&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;"Explanation of everything you can see in htop/top on Linux"&lt;/p&gt;
&lt;p&gt;“解释你在Linux 上htop/top 中看到的所有内容”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://peteris.rocks/blog/htop/"&gt;原文地址&lt;/a&gt;：&lt;ul&gt;
&lt;li&gt;https://peteris.rocks/blog/htop/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遵循原文许可协议：&lt;a href="http://www.apache.org/licenses/LICENSE-2.0"&gt;Apache 2.0 license&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者:&lt;a href="https://peteris.rocks/"&gt;Pēteris Ņikiforovs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文修订时间：January 2, 2017 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很长一段时间我都不清楚htop 中所有内容的意思。&lt;br&gt;
我曾经以为我的双核机器上&lt;code&gt;1.0&lt;/code&gt;的平均负载意味着CPU 利用率是50%。这并不完全正确。而且，为什么是&lt;code&gt;1.0&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;我决定查清楚，并记录成这份文档。&lt;/p&gt;
&lt;p&gt;大家也都说，学习事物的最好方式是通过教别人。&lt;/p&gt;
&lt;h2&gt;Ubuntu Server 16.04 x64 上的htop&lt;/h2&gt;
&lt;p&gt;这是一张我要解释的htop 截图。&lt;br&gt;
&lt;img alt="canyoukillit-before" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153350.png"&gt;&lt;/p&gt;
&lt;h2&gt;Uptime&lt;/h2&gt;
&lt;p&gt;Uptime 显示系统已经正常运行了多久。&lt;br&gt;
你可以通过运行&lt;code&gt;uptime&lt;/code&gt; 命令看到同样的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ uptime
 12:17:58 up 111 days, 31 min,  1 user,  load average: 0.00, 0.01, 0.05
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;uptime&lt;/code&gt; 程序是怎么获取这些信息的？&lt;br&gt;
它是从&lt;code&gt;/proc/uptime&lt;/code&gt;文件中读取这些信息。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;9592411.58 9566042.33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个值是系统总共已经运行的秒数。第二个值是机器空闲的总秒数，在多核机器上第二个值可能某些时刻会大于系统总体的运行时间，因为它是多个核心的总空闲时间。&lt;/p&gt;
&lt;p&gt;我怎么知道的？我查看了&lt;code&gt;uptime&lt;/code&gt; 程序运行的时候打开了哪些文件。我们可以用&lt;code&gt;strace&lt;/code&gt; 工具来跟踪。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;strace uptime
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上述命令会得到一大堆输出。我们可以使用&lt;code&gt;grep&lt;/code&gt; 过滤出&lt;code&gt;open&lt;/code&gt;  的系统调用。但是这样不会起作用，因为&lt;code&gt;strace&lt;/code&gt; 会把所有内容输出到标准错误(stderr)流。我们用&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;可以把标准错误输出重定向到标准输出(stdout)流。&lt;/p&gt;
&lt;p&gt;我们得到的输出如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ strace uptime 2&amp;gt;&amp;amp;1 | grep open
...
open(&amp;quot;/proc/uptime&amp;quot;, O_RDONLY)          = 3
open(&amp;quot;/var/run/utmp&amp;quot;, O_RDONLY|O_CLOEXEC) = 4
open(&amp;quot;/proc/loadavg&amp;quot;, O_RDONLY)         = 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中包含我提到的&lt;code&gt;/proc/uptime&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;其实你也可以用&lt;code&gt;strace -e open uptime&lt;/code&gt;，不必用&lt;code&gt;grep&lt;/code&gt; 过滤。&lt;/p&gt;
&lt;p&gt;所以，如果我们可以从这些文件中读取内容，为什么还需要&lt;code&gt;uptime&lt;/code&gt; 程序呢？这是因为&lt;code&gt;uptime&lt;/code&gt;的输出格式对人来说更友好，不过在你的程序或者脚本里还是使用秒数方便一些。&lt;/p&gt;
&lt;h2&gt;平均负载&lt;/h2&gt;
&lt;p&gt;除了正常运行时间，另外还有三个数值表示平均负载。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ uptime
 12:59:09 up 32 min,  1 user,  load average: 0.00, 0.01, 0.03
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它们是从&lt;code&gt;/proc/loadavg&lt;/code&gt;文件中读取的。如果你再看一眼&lt;code&gt;strace&lt;/code&gt;的输出，你也可以看到这个文件被打开了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /proc/loadavg
0.00 0.01 0.03 1/120 1500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前三列数分别表示系统最近1分钟，5分钟和15分钟的平均负载。第四列数表示目前正在运行的进程数和总进程数。最后一列显示了最近一次运行的进程ID。&lt;/p&gt;
&lt;p&gt;让我们从最后一个数开始。&lt;/p&gt;
&lt;p&gt;你每次启动一个新进程时，都会被分配一个ID 号。进程ID 通常是逐渐增大，除非它们已经耗尽，并被重复使用。进程ID 1 属于&lt;code&gt;/sbin/init&lt;/code&gt;，它会在系统启动的时运行。&lt;/p&gt;
&lt;p&gt;在看一遍&lt;code&gt;/proc/loadavg&lt;/code&gt;的内容，并在后台执行&lt;code&gt;sleep&lt;/code&gt;命令。当它在后台启动时，它的进程ID 会显示出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /proc/loadavg
0.00 0.01 0.03 1/123 1566
$ sleep 10 &amp;amp;
[1] 1567
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以&lt;code&gt;1/123&lt;/code&gt; 意味着这一刻只有一个进程在运行，并且总共有&lt;code&gt;123&lt;/code&gt;个进程。&lt;/p&gt;
&lt;p&gt;当你运行&lt;code&gt;htop&lt;/code&gt; 时，只看到只有一个正在运行的进程的话，这个进程就是&lt;code&gt;htop&lt;/code&gt; 自身。&lt;/p&gt;
&lt;p&gt;如果你执行&lt;code&gt;sleep 30&lt;/code&gt;，然后再次运行&lt;code&gt;htop&lt;/code&gt;，你会看到还是只有一个正在运行的进程。这是因为&lt;code&gt;sleep&lt;/code&gt;没在运行，它正处于休眠或空闲状态，或者说是在等待某事发生。一个正在运行的进程的定义是当前正在某个物理CPU 上运行，或者等待调度到CPU 上运行的进程。&lt;/p&gt;
&lt;p&gt;如果你执行&lt;code&gt;cat /dev/urandom &amp;gt; /dev/null&lt;/code&gt;，这个命令会不断生成随机的字节，并写入到一个特殊的无法被读取的文件，你将会看到有2个正在执行的进程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /dev/urandom &amp;gt; /dev/null &amp;amp;
[1] 1639
$ cat /proc/loadavg
1.00 0.69 0.35 2/124 1679
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样现在有2个运行中的进程（随机数生成和读取&lt;code&gt;/proc/loadavg&lt;/code&gt;内容的&lt;code&gt;cat&lt;/code&gt;），同时你也会注意到平均负载升高了。&lt;/p&gt;
&lt;p&gt;平均负载表示一段时间内系统的平均负载。&lt;/p&gt;
&lt;p&gt;负载是通过统计运行中的进程（正在运行或者等待运行）和不可中断（uninterruptible）进程（等待磁盘或网络的相应）数量计算得到的。简单来说是一些进程的总数。&lt;/p&gt;
&lt;p&gt;所以平均负载是最近1分钟，5分钟和15分钟内这些进程的平均数，对吗？&lt;/p&gt;
&lt;p&gt;实际上没这么简单。&lt;/p&gt;
&lt;p&gt;平均负载是负载的指数移动平均。摘自维基百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从数学上来讲，这三个值都是系统起来以来的平均值。它们都是指数级衰减的，不过衰减速度不同。因此，1分钟的平均负载是63% 的最近一分钟的负载，再加上37%的系统启动以来除去最近一分钟的负载得到的。所以，1分钟的平均负载只包含最近60秒的情况从技术上看是不准确的（因为它还包含了过去37% 的情况），只是大部分是最近一分钟的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（译注：&lt;a href="https://en.wikipedia.org/wiki/Load_(computing)"&gt;Load (computing)&lt;/a&gt;，&lt;a href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87"&gt;移动平均&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;这是你意料之中的吗？&lt;/p&gt;
&lt;p&gt;让我们再看看我们的随机数生成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /proc/loadavg
1.00 0.69 0.35 2/124 1679
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;尽管从技术上看是不准确的，但是为了便于理解，还是把平均负载简单化。&lt;/p&gt;
&lt;p&gt;在这个例子中，生成随机数的进程是CPU 密集型（CPU Bound），所以最近一分钟的平均负载是&lt;code&gt;1&lt;/code&gt;，或者说最近一分钟平均有1个正在运行的进程。&lt;/p&gt;
&lt;p&gt;因为我的系统上只有一颗CPU，一颗CPU上同一时刻只能运行一个进程，所以CPU 利用率是100%。&lt;/p&gt;
&lt;p&gt;如果有2个核心，CPU 利用率将会是50%，因为同一时刻可以运行2个进程。2个核心的计算机的CPU 利用率达到100% 的话，它的平均负载会是&lt;code&gt;2.0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;htop&lt;/code&gt; 左上角或者执行&lt;code&gt;nproc&lt;/code&gt; 命令，看到你的CPU 核心数。&lt;/p&gt;
&lt;p&gt;因为负载数还包括出于不可中断状态的进程，但是这些进程不会太影响CPU 利用率，所以从平均负载推断CPU 利用率不太准确。这也解释了你可能遇到过的平均负载很高但是CPU 不忙的情况。&lt;/p&gt;
&lt;p&gt;不过也有一些例如&lt;code&gt;mpstat&lt;/code&gt; 这样的工具可以显示即时的CPU 利用率。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt install sysstat -y
$ mpstat 1
Linux 4.4.0-47-generic (hostname)   12/03/2016      _x86_64_        (1 CPU)

10:16:20 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
10:16:21 PM  all    0.00    0.00  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
10:16:22 PM  all    0.00    0.00  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
10:16:23 PM  all    0.00    0.00  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
# ...
# kill cat /dev/urandom
# ...
10:17:00 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
10:17:01 PM  all    1.00    0.00    0.00    2.00    0.00    0.00    0.00    0.00    0.00   97.00
10:17:02 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那为什么我们还要使用平均负载呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ curl -s https://raw.githubusercontent.com/torvalds/linux/v4.8/kernel/sched/loadavg.c | head -n 7
/*
* kernel/sched/loadavg.c
*
* This file contains the magic bits required to compute the global loadavg
* figure. Its a silly number but people think its important. We go through
* great pains to make it work on big machines and tickless kernels.
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（译注：总的来说，平均负载十分愚蠢，
tickles 内核参考：&lt;a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E5%98%80%E5%97%92%E5%86%85%E6%A0%B8"&gt;无嘀嗒内核&lt;/a&gt;）,&lt;a href="http://kernel.meizu.com/linux-tick-and-tickless.html"&gt;Linux Tick 和 Tickless&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;进程&lt;/h2&gt;
&lt;p&gt;htop 右上角显示了进程总数和运行中的数量，不过它显示的是&lt;em&gt;任务（Task）&lt;/em&gt;而不是进程，这是为什么呢？&lt;/p&gt;
&lt;p&gt;进程的另一个名字是任务。Linux 内核内部把进程称为任务。&lt;code&gt;htop&lt;/code&gt; 使用任务（Task）来代替进程（Process）可能是因为它（Task）更短，更节省屏幕空间。&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;htop&lt;/code&gt;中看到线程。按下&lt;code&gt;Shift&lt;/code&gt;和&lt;code&gt;H&lt;/code&gt; 键可以切换到显示线程的模式。如果你看到&lt;code&gt;Tasks: 23, 10 thr&lt;/code&gt;，即显示了线程。&lt;/p&gt;
&lt;p&gt;你也可以看到内核的线程，按下&lt;code&gt;Shift&lt;/code&gt;和&lt;code&gt;K&lt;/code&gt;键。它们会显示的是&lt;code&gt;Tasks: 23, 40 kthr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;进程 ID / PID&lt;/h2&gt;
&lt;p&gt;每次新建一个进程的时候，都会分配给它一个标识的数字（ID），也称为进程ID 或简称为PID。&lt;/p&gt;
&lt;p&gt;如果你在bash 里运行一个后台（&amp;amp;）的程序，你会看到方扩号里的任务号和PID。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sleep 1000 &amp;amp;
[1] 12503
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你错过这些内容，在bash 里面可以用&lt;code&gt;$!&lt;/code&gt;这个变量，它会显示最近的后台进程的ID。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo $!
12503
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进程ID 非常有用。可以用它来查看进程的细节和控制进程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;procfs&lt;/code&gt; 是一个虚拟文件系统，用来让用户程序通过读取文件获取内核的信息。&lt;code&gt;procfs&lt;/code&gt;通常挂载在&lt;code&gt;/proc/&lt;/code&gt;，对你来说，它看起来想一个普通的文件目录，你可以使用&lt;code&gt;ls&lt;/code&gt;和&lt;code&gt;cd&lt;/code&gt;进行浏览。&lt;/p&gt;
&lt;p&gt;所有关于一个进程的信息都在&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls /proc/12503
attr        coredump_filter  fdinfo     maps        ns             personality  smaps    task
auxv        cpuset           gid_map    mem         numa_maps      projid_map   stack    uid_map
cgroup      cwd              io         mountinfo   oom_adj        root         stat     wchan
clear_refs  environ          limits     mounts      oom_score      schedstat    statm
cmdline     exe              loginuid   mountstats  oom_score_adj  sessionid    status
comm        fd               map_files  net         pagemap        setgroups    syscall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举个例子，&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/cmdline&lt;/code&gt; 包含运行这个进程所用的命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /proc/12503/cmdline
sleep1000$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;额，不对。实际上这个命令是以&lt;code&gt;\0&lt;/code&gt;字节分隔的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ od -c /proc/12503/cmdline
0000000   s   l   e   e   p  \0   1   0   0   0  \0
0000013
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以用空格或者换行符替换&lt;code&gt;\0&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ tr &amp;#39;\0&amp;#39; &amp;#39;\n&amp;#39; &amp;lt; /proc/12503/cmdline
sleep
1000
$ strings /proc/12503/cmdline
sleep
1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个进程的目录可以包含链接！例如，&lt;code&gt;cwd&lt;/code&gt;指向当前的工作目录，&lt;code&gt;exe&lt;/code&gt;指向可执行的二进制文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l /proc/12503/{cwd,exe}
lrwxrwxrwx 1 ubuntu ubuntu 0 Jul  6 10:10 /proc/12503/cwd -&amp;gt; /home/ubuntu
lrwxrwxrwx 1 ubuntu ubuntu 0 Jul  6 10:10 /proc/12503/exe -&amp;gt; /bin/sleep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这就是&lt;code&gt;htop&lt;/code&gt;,&lt;code&gt;top&lt;/code&gt;,&lt;code&gt;ps&lt;/code&gt;和其他诊断工具获取进程详细信息的方式：&lt;br&gt;
都是通过读取&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/&amp;lt;file&amp;gt;&lt;/code&gt;的内容。&lt;/p&gt;
&lt;h2&gt;进程树&lt;/h2&gt;
&lt;p&gt;当启动一个新进程的时候，启动这个新进程的那个进程被称为父进程。新的进程是父进程的一个子进程。它们是树状结构的关系。&lt;/p&gt;
&lt;p&gt;如果你在&lt;code&gt;htop&lt;/code&gt;里按&lt;code&gt;F5&lt;/code&gt;键，就可以看到分层的进程。&lt;/p&gt;
&lt;p&gt;你也可以使用&lt;code&gt;ps&lt;/code&gt;的&lt;code&gt;f&lt;/code&gt;选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps f
PID TTY      STAT   TIME COMMAND
12472 pts/0    Ss     0:00 -bash
12684 pts/0    R+     0:00  \_ ps f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;code&gt;pstree&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pstree -a
init
├─atd
├─cron
├─sshd -D
│   └─sshd
│       └─sshd
│           └─bash
│               └─pstree -a
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这也就是为什么你可能经常看到&lt;code&gt;bash&lt;/code&gt;或者&lt;code&gt;sshd&lt;/code&gt; 是一些进程的父进程的原因。&lt;/p&gt;
&lt;p&gt;当你在&lt;code&gt;bash&lt;/code&gt;里运行&lt;code&gt;date&lt;/code&gt;，会发生以下这些事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bash&lt;/code&gt; 新建一个进程，这个进程是它自身的拷贝（使用&lt;code&gt;fork&lt;/code&gt;系统调用）&lt;/li&gt;
&lt;li&gt;接着从可执行文件&lt;code&gt;/bin/date&lt;/code&gt;加载程序到内存中（使用&lt;code&gt;exec&lt;/code&gt;系统调用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash&lt;/code&gt;作为父进程将等待直到它的子进程退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ID 为1 的&lt;code&gt;/sbin/init&lt;/code&gt;是在启动时运行的，它生成了SSH 守护进程&lt;code&gt;sshd&lt;/code&gt;。当你连接到计算机时，&lt;code&gt;sshd&lt;/code&gt;将产生一个会话进程，这个会话进程再启动&lt;code&gt;bash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我喜欢在&lt;code&gt;htop&lt;/code&gt;中使用树状图，当我想看到所有线程的时候。&lt;/p&gt;
&lt;h2&gt;进程用户&lt;/h2&gt;
&lt;p&gt;每个进程都属于一个用户，通过一个数字标识用户。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sleep 1000 &amp;amp;
[1] 2045
$  grep Uid /proc/2045/status
Uid:    1000    1000    1000    1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以用&lt;code&gt;id&lt;/code&gt;命令找出这个UID 的用户名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ id 1000
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上&lt;code&gt;id&lt;/code&gt; 是从&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/group&lt;/code&gt;文件中获取信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ strace -e open id 1000
...
open(&amp;quot;/etc/nsswitch.conf&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
open(&amp;quot;/lib/x86_64-linux-gnu/libnss_compat.so.2&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
open(&amp;quot;/lib/x86_64-linux-gnu/libnss_files.so.2&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
open(&amp;quot;/etc/passwd&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
open(&amp;quot;/etc/group&amp;quot;, O_RDONLY|O_CLOEXEC)  = 3
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是因为Name Service Switch （NSS）的配置文件&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;表示通过这些文件解析名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ head -n 9 /etc/nsswitch.conf
# ...
passwd:         compat
group:          compat
shadow:         compat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;compat&lt;/code&gt;（兼容模式：Compatibility mode）这个配置项和&lt;code&gt;files&lt;/code&gt;作用一样，除了支持一些特殊的条目。&lt;code&gt;files&lt;/code&gt;表示数据存在一个文件中（通过&lt;code&gt;libnss_files.so&lt;/code&gt;加载）。不过你也可以把你的用户信息存在其他数据库或者服务中，例如使用轻型目录访问协议（LDAP）等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/group&lt;/code&gt;是纯文本文件，将数字化的用户ID 映射到对人类可读的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash
$ cat /etc/group
root:x:0:
adm:x:4:syslog,ubuntu
ubuntu:x:1000:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt;？哪里有密码？&lt;/p&gt;
&lt;p&gt;它们实际上是在&lt;code&gt;/etc/shadow&lt;/code&gt;中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo cat /etc/shadow
root:$6$mS9o0QBw$P1ojPSTexV2PQ.Z./rqzYex.k7TJE2nVeIVL0dql/:17126:0:99999:7:::
daemon:*:17109:0:99999:7:::
ubuntu:$6$GIfdqlb/$ms9ZoxfrUq455K6UbmHyOfz7DVf7TWaveyHcp.:17126:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些乱七八糟的内容是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$6$&lt;/code&gt;是使用的密码hash 算法，现在这个表示的是&lt;code&gt;sha512&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;紧跟着的是随机产生的盐，防止彩虹表攻击&lt;/li&gt;
&lt;li&gt;最后是密码+盐的hash 值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你运行一个程序的时候，它会以你的用户运行。即时这个可执行文件不属于你。&lt;/p&gt;
&lt;p&gt;如果你想以&lt;code&gt;root&lt;/code&gt;或者其他用户运行程序，可以使用&lt;code&gt;sudo&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm)
$ sudo id
uid=0(root) gid=0(root) groups=0(root)
$ sudo -u ubuntu id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm)
$ sudo -u daemon id
uid=1(daemon) gid=1(daemon) groups=1(daemon)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你想要登录其他用户的帐号来运行更多的命令该怎么做？可以使用&lt;code&gt;sudo bash&lt;/code&gt;或&lt;code&gt;sudo -u user bash&lt;/code&gt;。你将能以其他用户的身份使用shell。&lt;/p&gt;
&lt;p&gt;如果你不喜欢每次都被要求输入root 密码，把你的用户名添加到&lt;code&gt;/etcsudoers&lt;/code&gt;文件中就能关闭它。&lt;/p&gt;
&lt;p&gt;让我们试一试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo &amp;quot;$USER ALL=(ALL) NOPASSWD: ALL&amp;quot; &amp;gt;&amp;gt; /etc/sudoers
-bash: /etc/sudoers: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好吧，只有root 才有权限。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo echo &amp;quot;$USER ALL=(ALL) NOPASSWD: ALL&amp;quot; &amp;gt;&amp;gt; /etc/sudoers
-bash: /etc/sudoers: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我擦，什么情况？&lt;/p&gt;
&lt;p&gt;现在你是以root 用户执行了&lt;code&gt;echo&lt;/code&gt;命令，不过追加内容到&lt;code&gt;/etc/sudoers&lt;/code&gt;还是以你的用户身份。&lt;/p&gt;
&lt;p&gt;通常有两种方法解决这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo "$USER ALL=(ALL) NOPASSWD: ALL" | sudo tee -a /etc/sudoers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo bash -c "echo '$USER ALL=(ALL) NOPASSWD: ALL' &amp;gt;&amp;gt; /etc/sudoers"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个例子中，&lt;code&gt;tee -a&lt;/code&gt;将标准输出的内容追加到文件中，我们是以root 用户执行这个命令的。&lt;/p&gt;
&lt;p&gt;第二个例子中，我们以root 用户运行bash，并让它执行一条命令，这条命令会以root 用户执行。
注意这里面复杂的单引号和双引号，它们决定了&lt;code&gt;$USER&lt;/code&gt;标量什么时候被展开。&lt;/p&gt;
&lt;p&gt;如果你看一眼&lt;code&gt;/etc/sudoers&lt;/code&gt;文件，在开头你会看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo head -n 3 /etc/sudoers
#
# This file MUST be edited with the &amp;#39;visudo&amp;#39; command as root.
#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;哎呦。&lt;/p&gt;
&lt;p&gt;这是一个有用的警告，说你应该使用&lt;code&gt;sudo visudo&lt;/code&gt;来编辑这个文件。它会在你保存文件之前校验内容，防止发生错误。
如果你没有使用&lt;code&gt;visudo&lt;/code&gt;而导致错误的话，将把你锁定无法使用&lt;code&gt;sudo&lt;/code&gt;。这意味着你没法修正错误。&lt;/p&gt;
&lt;p&gt;假设你想要修改你的密码，你可以使用&lt;code&gt;password&lt;/code&gt;命令。如前面提到的，它会把密码保存在&lt;code&gt;/etc/shaow&lt;/code&gt;文件中。&lt;/p&gt;
&lt;p&gt;这个文件非常敏感，只有root 用户才能写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1122 Nov 27 18:52 /etc/shadow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以普通用户执行的&lt;code&gt;password&lt;/code&gt;程序是怎么可能写入内容到一个守保护的文件呢？&lt;/p&gt;
&lt;p&gt;我前面说过当你执行一个程序的时候，它是以你的身份执行的，即使这个可执行文件的所有者是另外一个用户。&lt;/p&gt;
&lt;p&gt;实际上你可以通过修改文件权限改变这个行为。让我们看看。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 54256 Mar 29  2016 /usr/bin/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意&lt;code&gt;s&lt;/code&gt;的字母。这是通过&lt;code&gt;sudo chmod u+s /usr/bin/passwd&lt;/code&gt;加上的。它表示一个可执行文件会以文件的所有者的身份被执行，这里是以root 用户执行。&lt;/p&gt;
&lt;p&gt;你可以用&lt;code&gt;find /bin -user root -perm -u+s&lt;/code&gt; 找到具有&lt;code&gt;setuid&lt;/code&gt;权限的可执行文件。&lt;/p&gt;
&lt;p&gt;注意你也可以对用户组执行相同的操作（&lt;code&gt;g+s&lt;/code&gt;）。&lt;/p&gt;
&lt;h2&gt;进程状态&lt;/h2&gt;
&lt;p&gt;接下来我们看一下&lt;code&gt;htop&lt;/code&gt;中用字母&lt;code&gt;s&lt;/code&gt;表示的进程状态这一列。&lt;/p&gt;
&lt;p&gt;几种可能的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;R    running or runnable (on run queue) 运行中或者即将运行
S    interruptible sleep (waiting for an event to complete) 中断睡眠
D    uninterruptible sleep (usually IO) 不可中断睡眠
Z    defunct (&amp;quot;zombie&amp;quot;) process, terminated but not reaped by its parent 僵尸进程
T    stopped by job control signal 被制信号停止
t    stopped by debugger during the tracing 被debugger 停止
X    dead (should never be seen) 死亡
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我把它们按照出现的频率如上排序。&lt;/p&gt;
&lt;p&gt;注意当你执行&lt;code&gt;ps&lt;/code&gt;的时候，也会出现例如&lt;code&gt;Ss&lt;/code&gt;，&lt;code&gt;R+&lt;/code&gt;，&lt;code&gt;Ss+&lt;/code&gt;等状态。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps x
PID TTY      STAT   TIME COMMAND
1688 ?        Ss     0:00 /lib/systemd/systemd --user
1689 ?        S      0:00 (sd-pam)
1724 ?        S      0:01 sshd: vagrant@pts/0
1725 pts/0    Ss     0:00 -bash
2628 pts/0    R+     0:00 ps x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;R - running or runnable (on run queue)&lt;/h3&gt;
&lt;p&gt;这种状态下的进程，要么是正在运行中，要么就是在等待运行的队列中。&lt;/p&gt;
&lt;p&gt;什么是运行？&lt;/p&gt;
&lt;p&gt;当你从源代码编译你的程序后，得到的机器代码其实是CPU 指令。它们被保存到文件中等待执行。当你加载程序的时候，它们被加载到内存中，接着CPU 会执行这些指令。&lt;/p&gt;
&lt;p&gt;基本上这个状态意味着CPU 在执行指令，或者说在处理数学运算。&lt;/p&gt;
&lt;h3&gt;S - interruptible sleep (waiting for an event to complete)&lt;/h3&gt;
&lt;p&gt;这个状态表示该进程的代码指令此刻没在CPU 上运行。相反，进程正在等待一个事件或者一条触发条件产生。当事件发生时，内核会将状态设置为运行中。&lt;/p&gt;
&lt;p&gt;一个例子是核心工具包里的&lt;code&gt;sleep&lt;/code&gt;（译注：GNU核心工具组（英语：GNU Core Utilities，亦常缩写为Coreutils），参考 &lt;a href="https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84"&gt;GNU核心工具组&lt;/a&gt;）。它能睡眠指定的秒数（大致上）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sleep 1000 &amp;amp;
[1] 10089
$ ps f
PID TTY      STAT   TIME COMMAND
3514 pts/1    Ss     0:00 -bash
10089 pts/1    S      0:00  \_ sleep 1000
10094 pts/1    R+     0:00  \_ ps f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是可中断的睡眠。那我们怎么中断它？&lt;/p&gt;
&lt;p&gt;通过发送信号。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;htop&lt;/code&gt;里你可以按下&lt;code&gt;F9&lt;/code&gt;然后在菜单左则选择一个信号来发送。&lt;/p&gt;
&lt;p&gt;发送信号也被称为&lt;code&gt;kill&lt;/code&gt;。这是因为&lt;code&gt;kill&lt;/code&gt;是一个系统调用，它可以给一个进程发送信号。&lt;code&gt;/bin/kill&lt;/code&gt; 程序可以从用户空间发起系统调用，默认的信号是&lt;code&gt;TERM&lt;/code&gt;，这个信号会让进程退出，或者说会杀死进程。&lt;/p&gt;
&lt;p&gt;信号只是一个数字。不过数字很难记，所以我们给它们取了名字。信号名称常常大写，并以&lt;code&gt;SIG&lt;/code&gt;为开头。&lt;/p&gt;
&lt;p&gt;一些常用的信号是&lt;code&gt;INT&lt;/code&gt;，&lt;code&gt;KILL&lt;/code&gt;，&lt;code&gt;STOP&lt;/code&gt;，&lt;code&gt;CONT&lt;/code&gt;，&lt;code&gt;HUP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;让我们给sleep 进程发送&lt;code&gt;INT&lt;/code&gt;（也可称为&lt;code&gt;SIGINT&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt;，&lt;code&gt;Terminal interrupt&lt;/code&gt;）信号中断睡眠。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ kill -INT 10089
[1]+  Interrupt               sleep 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当你按下&lt;code&gt;CTRL&lt;/code&gt;键和&lt;code&gt;C&lt;/code&gt;键的时候，也会发生以上现象。&lt;code&gt;bash&lt;/code&gt;会像我们刚刚那样，给所有后台程序发送&lt;code&gt;SIGINT&lt;/code&gt;信号。&lt;/p&gt;
&lt;p&gt;顺便说一下，&lt;code&gt;kill&lt;/code&gt;是&lt;code&gt;bash&lt;/code&gt;内置的命令，虽然在大多数系统上有&lt;code&gt;/bin/kill&lt;/code&gt;。为什么呢？这是为了当你创建的进程数量达到限制时，还可以用它来杀死进程。&lt;/p&gt;
&lt;p&gt;下列命令是做同样一件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kill -INT 10089&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kill -2 10089&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/kill -2 10089&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外一个有用的信号是&lt;code&gt;SIGKILL&lt;/code&gt;，又称为&lt;code&gt;9&lt;/code&gt;。当你狂按&lt;code&gt;CTRL&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;键不起的作用时，你可能曾用过它来杀死过进程。&lt;/p&gt;
&lt;p&gt;当你写一个程序时，你可以写一些信号处理函数，当你的程序收到信号的时就会调用这些函数。换句话说，你可以捕获信号来做一些事情。举个例子，做一些清理工作和优雅的关闭程序。
所以发送&lt;code&gt;SIGINT&lt;/code&gt;（用户想要中断一个进程）和&lt;code&gt;SIGTERM&lt;/code&gt;（用户想要终止一个进程）并不意味着进程能够被终止。&lt;/p&gt;
&lt;p&gt;你可以见过这个异常，当运行Python 脚本的时候：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python -c &amp;#39;import sys; sys.stdin.read()&amp;#39;
^C
Traceback (most recent call last):
File &amp;quot;&amp;lt;string&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
KeyboardInterrupt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以通过发送&lt;code&gt;KILL&lt;/code&gt;型号让内核强制终止一个进程，不让它有机会响应（译注：原文是 not give it a change to respond ，怀疑是不是作者打错了chance）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sleep 1000 &amp;amp;
[1] 2658
$ kill -9 2658
[1]+  Killed                  sleep 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;D - uninterruptible sleep (usually IO)&lt;/h3&gt;
&lt;p&gt;不同于可中断睡眠，你无法用信号唤醒这个状态下的进程。这也就是为什么很多人怕看到这个状态的原因。你不能杀死这样的进程，以为杀死意味着给进程发送&lt;code&gt;SIGKILL&lt;/code&gt; 信号。&lt;/p&gt;
&lt;p&gt;如果进程必须等待并不能被中断，或者有事件会马上发生，就会用这个状态。比如从磁盘读取内容。但是这只能发生几秒钟。&lt;/p&gt;
&lt;p&gt;StackOverflow 上一个&lt;a href="http://stackoverflow.com/questions/223644/what-is-an-uninterruptable-process"&gt;不错的解答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Uninterruptable processes are USUALLY waiting for I/O following a page fault. The process/task cannot be interrupted in this state, because it can't handle any signals; if it did, another page fault would happen and it would be back where it was.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，如果你使用网络文件系统（NFS），这种清空就会发生，从NSF 读写文件需要花一段时间。&lt;/p&gt;
&lt;p&gt;根据我的经验，这也意味着你的一些进程多次读写交换分区，空闲的内存空间不够用了。&lt;/p&gt;
&lt;p&gt;我们试一试让一个进程进入不可中断状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;8.8.8.8&lt;/code&gt;是一个Google 提供的公用DNS 服务器。它们没有提供一个开发的NFS。不过这不能阻止我们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo mount 8.8.8.8:/tmp /tmp &amp;amp;
[1] 12646
$ sudo ps x | grep mount.nfs
12648 pts/1    D      0:00 /sbin/mount.nfs 8.8.8.8:/tmp /tmp -o rw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如何找出进入这个状态原因？&lt;code&gt;strace&lt;/code&gt;！  &lt;/p&gt;
&lt;p&gt;让我们用&lt;code&gt;strace&lt;/code&gt;跟踪&lt;code&gt;ps&lt;/code&gt; 上面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo strace /sbin/mount.nfs 8.8.8.8:/tmp /tmp -o rw
...
mount(&amp;quot;8.8.8.8:/tmp&amp;quot;, &amp;quot;/tmp&amp;quot;, &amp;quot;nfs&amp;quot;, 0, ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;是&lt;code&gt;mount&lt;/code&gt;这个系统调用阻塞了进程。  &lt;/p&gt;
&lt;p&gt;如果你想知道的话，你可以运行&lt;code&gt;mount&lt;/code&gt; 时加上&lt;code&gt;intr&lt;/code&gt;选项，让它运行在中断模式下：&lt;code&gt;sudo mount 8.8.8.8:/tmp /tmp -o intr&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;Z - defunct ("zombie") process, terminated but not reaped by its parent&lt;/h3&gt;
&lt;p&gt;当进程通过&lt;code&gt;exit&lt;/code&gt; 退出后，子进程还存在的话，它的子进程会变成僵尸进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果僵尸进程短时间存在，这很正常。&lt;/li&gt;
&lt;li&gt;僵尸进程长时间存在的话，辨明程序有一个bug&lt;/li&gt;
&lt;li&gt;僵尸进程不会消耗进程，它只是一个进程ID&lt;/li&gt;
&lt;li&gt;你不能&lt;code&gt;kill&lt;/code&gt; 一个僵尸进程&lt;/li&gt;
&lt;li&gt;你可以请求父进程回收僵尸进程（&lt;code&gt;SIGHLD&lt;/code&gt;信号）&lt;/li&gt;
&lt;li&gt;你可以&lt;code&gt;kill&lt;/code&gt; 僵尸进程的父进程，以此去除父进程和它的僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我将写一段C 代码来演示这个。&lt;/p&gt;
&lt;p&gt;这是我的程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Running&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I am the child process&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The child process is exiting now&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I am the parent process&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The parent process is sleeping now&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The parent process is finished&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来安装GNU C 编译器（GCC）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt install -y gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译并运行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;gcc zombie.c -o zombie
./zombie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看下进程树。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps f
PID TTY      STAT   TIME COMMAND
3514 pts/1    Ss     0:00 -bash
7911 pts/1    S+     0:00  \_ ./zombie
7912 pts/1    Z+     0:00      \_ [zombie] &amp;lt;defunct&amp;gt;
1317 pts/0    Ss     0:00 -bash
 7913 pts/0    R+     0:00  \_ ps f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们得到了僵尸进程。&lt;/p&gt;
&lt;p&gt;当父进程退出之后，僵尸进程也退出了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps f
PID TTY      STAT   TIME COMMAND
3514 pts/1    Ss+    0:00 -bash
1317 pts/0    Ss     0:00 -bash
 7914 pts/0    R+     0:00  \_ ps f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你用&lt;code&gt;sleep 20&lt;/code&gt;代替&lt;code&gt;while (true) ;&lt;/code&gt;，僵尸进程会马上退出。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;exit&lt;/code&gt;退出，所有申请的内存和资源会马上释放，以供其他进程使用。&lt;/p&gt;
&lt;p&gt;父进程可以使用&lt;code&gt;wait&lt;/code&gt;系统调用找到子进程的退出代码（在信号处理函数中）。如果一个进程正在睡眠状态，需要等待它醒来。&lt;/p&gt;
&lt;p&gt;为什么不简单粗暴的唤醒进程，然后杀死它？同样的原因，你也不会在厌烦你孩子的时候把它丢进垃圾桶。后果很严重。&lt;/p&gt;
&lt;h3&gt;T - stopped by job control signal&lt;/h3&gt;
&lt;p&gt;我打开了两个终端窗口，用&lt;code&gt;ps u&lt;/code&gt;可以看到我的用户进程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps u
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
ubuntu    1317  0.0  0.9  21420  4992 pts/0    Ss+  Jun07   0:00 -bash
ubuntu    3514  1.5  1.0  21420  5196 pts/1    Ss   07:28   0:00 -bash
ubuntu    3528  0.0  0.6  36084  3316 pts/1    R+   07:28   0:00 ps u
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下文的输出中我会忽略&lt;code&gt;-bash&lt;/code&gt;和&lt;code&gt;ps u&lt;/code&gt;进程。&lt;/p&gt;
&lt;p&gt;现在在一个终端中运行&lt;code&gt;cat /dev/urandom &amp;gt; /dev/null&lt;/code&gt;。它的状态是&lt;code&gt;R+&lt;/code&gt;，意味着它在运行中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps u
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
ubuntu    3540  103  0.1   6168   688 pts/1    R+   07:29   0:04 cat /dev/urandom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按下&lt;code&gt;CTRL&lt;/code&gt;加&lt;code&gt;Z&lt;/code&gt;键，终止进程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ # CTRL+Z
[1]+  Stopped                 cat /dev/urandom &amp;gt; /dev/null
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
ubuntu    3540 86.8  0.1   6168   688 pts/1    T    07:29   0:15 cat /dev/urandom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在它的状态是&lt;code&gt;T&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在第一个终端运行&lt;code&gt;fg&lt;/code&gt;，恢复它。&lt;/p&gt;
&lt;p&gt;另外一个终止进程的方法是通过&lt;code&gt;kill&lt;/code&gt;发送&lt;code&gt;STOP&lt;/code&gt;信号。你可以用&lt;code&gt;CONT&lt;/code&gt;型号，让进程恢复执行。&lt;/p&gt;
&lt;h3&gt;t - stopped by debugger during the tracing&lt;/h3&gt;
&lt;p&gt;首选，安装GNU Debugger（gdb）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt install -y gdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行一个进程，它会在1234 端口上监听进入的网络连接。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ nc -l 1234 &amp;amp;
[1] 3905
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它在睡眠中意味着它正在等待网络数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps u
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
ubuntu    3905  0.0  0.1   9184   896 pts/0    S    07:41   0:00 nc -l 1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行debugger，连接上ID是3905 的进程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo gdb -p 3905
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你会看到进程状态变为&lt;code&gt;t&lt;/code&gt;，意味着这个进程正在被debugger 跟踪。&lt;/p&gt;
&lt;h2&gt;进程时间片&lt;/h2&gt;
&lt;p&gt;Linux 是一个多任务的操作系统，这意味着即使你只有一颗CPU，也可以同时跑多个进程。当你的Web server 通过互联网把你的博客内容分发给读者的时候，你可以通过SSH 连接到你的服务器，看一下&lt;code&gt;htop&lt;/code&gt;的输出内容。&lt;/p&gt;
&lt;p&gt;一颗CPU同一时刻只能运行一条指令，那这是怎么做到的？&lt;/p&gt;
&lt;p&gt;答案是分时。&lt;/p&gt;
&lt;p&gt;一个进程运行一点时间，接着它进入睡眠，因为其他进程在等待轮流运行。进程运行的一小段时间被称谓时间片。&lt;/p&gt;
&lt;p&gt;一个时间片通常是几毫秒，所以在系统负载不高的时候，你不会注意到它。（找出Linux 的时间片是多长很有意思。）&lt;/p&gt;
&lt;p&gt;这应该可以解释为什么平均负载是运行中的平均进程数。如果你只有一个核心，并且平均负载是&lt;code&gt;1.0&lt;/code&gt;，则CPU 利用率是100%。如果平均负载大于&lt;code&gt;1.0&lt;/code&gt;，这意味着等待运行的进程超过CPU 可以运行的数量，所以这时你可能会感觉到卡顿。如果平均负载低于&lt;code&gt;1.0&lt;/code&gt;，意味着CPU 有时空闲着不做事。&lt;/p&gt;
&lt;p&gt;这应该让你有了思路，为什么有时运行一个执行时间为10秒的进程，运行时间可能长于或者短于10秒。&lt;/p&gt;
&lt;h2&gt;进程友好度和优先级&lt;/h2&gt;
&lt;p&gt;当你有超过CPU H核心数的进程需要运行的时候，你得想个方式决定下一步运行哪些进程，以及让哪些进程排队等待。这就是任务调度器的工作。&lt;/p&gt;
&lt;p&gt;Linux 内核的调度器负责从运行队列中选出下一个运行的进程，具体的选取方法取决于内核使用的调度算法。&lt;/p&gt;
&lt;p&gt;通常你没法影响调度器，不过你可以让调度器知道哪些程序对你来说更重要，调度器会特别关注一下。&lt;/p&gt;
&lt;p&gt;友好度（&lt;code&gt;NI&lt;/code&gt;）是进程的用户空间优先级，范围从-20（优先级最高）到19（优先级最低）。这可能让人有点费解，不过你可以这样想，一个友好的进程会谦让一个不友好的进程。所以一个进程越友好，它谦让得越多。&lt;/p&gt;
&lt;p&gt;通过阅读StackOverflow 和其他站点，我总结整理了下，一个进程的Nice 值每提高1，会让出超过10% 的CPU 时间。&lt;/p&gt;
&lt;p&gt;优先级（&lt;code&gt;PRI&lt;/code&gt;）是Linux 内核使用的内核空间的优先级。优先级的范围是0到139，其中0到99 用于实时进程，100到139 用于用户进程。&lt;/p&gt;
&lt;p&gt;你可以改变进程的友好度，内核会考虑到，不过你没法改变优先级。&lt;/p&gt;
&lt;p&gt;nice 值和优先级的关系是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;PR = 20 + NI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以&lt;code&gt;PR=20 + (-20 to +19)&lt;/code&gt; 的值是0 到39，对应的优先级是100到139 。&lt;br&gt;
你可以在启动一个进程前设置它的友好度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nice -n niceness program
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以用&lt;code&gt;renice&lt;/code&gt;改变运行中的进程的友好度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;renice -n niceness -p PID
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是不同颜色的CPU 利用率的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蓝色：低优先级的线程（nice &amp;gt; 0）&lt;/li&gt;
&lt;li&gt;绿色：普通优先级的线程&lt;/li&gt;
&lt;li&gt;红色：内核线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://askubuntu.com/questions/656771/process-niceness-vs-priority"&gt;http://askubuntu.com/questions/656771/process-niceness-vs-priority&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;内存使用情况 - VIRT/RES/SHR/MEM&lt;/h2&gt;
&lt;p&gt;一个进程会有它是内存里面唯一一个的错觉。这是通过虚拟内存实现的。&lt;/p&gt;
&lt;p&gt;进程没有直接访问物理内存的权限。取而代之的是，它有自己的虚拟地址空间，内核会把虚拟地址空间转换到物理内存地址，或者映射到磁盘上。这就是为什么看起来进程使用的内存超过你计算机上实际的内存。&lt;/p&gt;
&lt;p&gt;在这里我想提出的是弄清楚一个进程到底使用了多少内存不太容易。你也想统计贡献库和磁盘映射的内存？内核提供的和&lt;code&gt;htop&lt;/code&gt; 展示的一些信息可以帮你估算内存使用情况。&lt;/p&gt;
&lt;p&gt;不同颜色的内存使用量的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绿色：已使用的内存&lt;/li&gt;
&lt;li&gt;蓝色：Buffer&lt;/li&gt;
&lt;li&gt;橘黄色：Cache&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;VIRT/VSZ - 虚拟镜像&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The total amount of virtual memory used by the task. It includes all code, data and shared libraries plus pages that have been swapped out and pages that have been mapped but not used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;VIRT&lt;/code&gt;是虚拟内存使用量。它包括所有东西，包括映射的文件。&lt;/p&gt;
&lt;p&gt;如果一个应用程序申请了1GB 内存，但是实际只用了1MB，&lt;code&gt;VIRT&lt;/code&gt;也会显示 1GB。如果它&lt;code&gt;mmap&lt;/code&gt;一个1GB 的文件，但不使用，&lt;code&gt;VIRT&lt;/code&gt;也会显示为 1GB。&lt;/p&gt;
&lt;p&gt;大多数时候，这个值没啥用。&lt;/p&gt;
&lt;h3&gt;RES/RSS - 常驻大小&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The non-swapped physical memory a task has used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;RES&lt;/code&gt;是常驻内存的使用量，即当前物理内存使用量。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;RES&lt;/code&gt;相比&lt;code&gt;VIRT&lt;/code&gt;可以更好的表示进程的内存使用量，不过请记住&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它不包括交换出的内存（译注：即在swap 上的内容）&lt;/li&gt;
&lt;li&gt;可能包括和其他进程的共享内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个进程使用了1GB 内存，它调用&lt;code&gt;fork()&lt;/code&gt;，fork 的结果是有2 个进程，它们的&lt;code&gt;RES&lt;/code&gt;都是1GB，不过实际上只用了1GB，因为Linux 的写入时复制（译注：&lt;a href="https://zh.wikipedia.org/zh-hans/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD"&gt;写入时复制&lt;/a&gt;）。&lt;/p&gt;
&lt;h3&gt;SHR - 共享内存大小&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The amount of shared memory used by a task.
It simply reflects memory that could be potentially shared with other processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Started&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 10 MB&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Allocated 10M&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Used 5M&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Forked&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child used extra 2M&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fallocate -l 10G
gcc -std=c99 mem.c -o mem
./mem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Process  Message               VIRT  RES SHR
main     Started               4200  680 604
main     Allocated 10M        14444  680 604
main     Used 5M              14444 6168 1116
main     Forked               14444 6168 1116
child    Forked               14444 5216 0
main     Child used extra 2M        8252 1116
child    Child used extra 2M        5216 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;TODO: I should finish this.&lt;/p&gt;
&lt;h3&gt;MEM% - 内存使用率&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A task's currently used share of available physical memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;RES&lt;/code&gt; 除以 总物理内存大小。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;RES&lt;/code&gt;是500M，你有8G内存，&lt;code&gt;MEM%&lt;/code&gt; 将是&lt;code&gt;400/8192*100&lt;/code&gt; = &lt;code&gt;4.88%&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;进程&lt;/h2&gt;
&lt;p&gt;我在Digital Ocean 上启动了一台Ubuntu Server。&lt;/p&gt;
&lt;p&gt;系统启动的时候会运行哪些进程呢？&lt;br&gt;
你真的需要它们吗？&lt;/p&gt;
&lt;p&gt;我在Digital Ocean 新启动了一台Ubuntu Server 16.04.1 LTS x64 ，这是关于它的开机启动程序的调研笔记。&lt;/p&gt;
&lt;h3&gt;开始之前&lt;/h3&gt;
&lt;p&gt;&lt;img alt="canyoukillit-before" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153424.png"&gt;&lt;/p&gt;
&lt;h3&gt;/sbin/init&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The /sbin/init program (also called init) coordinates the rest of the boot process and configures the environment for the user.&lt;/p&gt;
&lt;p&gt;When the init command starts, it becomes the parent or grandparent of all of the processes that start up automatically on the system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是Systemd 吗？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ dpkg -S /sbin/init
systemd-sysv: /sbin/init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;是的，就是它。&lt;/p&gt;
&lt;p&gt;如果你kill 掉它会发生什么？&lt;/p&gt;
&lt;p&gt;什么都不会发生（译注：&lt;a href="https://unix.stackexchange.com/questions/66698/how-does-systemd-survive-a-kill-9"&gt;How does systemd survive a kill -9?&lt;/a&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.ubuntu.com/SystemdForUpstartUsers"&gt;https://wiki.ubuntu.com/SystemdForUpstartUsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.centos.org/docs/5/html/5.1/Installation_Guide/s2-boot-init-shutdown-init.html"&gt;https://www.centos.org/docs/5/html/5.1/Installation_Guide/s2-boot-init-shutdown-init.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/lib/systemd/systemd-journald&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd-journald is a system service that collects and stores logging data. It creates and maintains structured, indexed journals based on logging information that is received from a variety of sources.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换种说法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the main changes in journald was to replace simple plain text log files with a special file format optimized for log messages. This file format allows system administrators to access relevant messages more efficiently. It also brings some of the power of database-driven centralized logging implementations to individual systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你应该用&lt;code&gt;journalctl&lt;/code&gt;命令来查询日志。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;journalctl _COMM=sshd&lt;/code&gt; sshd 日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl _COMM=sshd -o json-pretty&lt;/code&gt; JSON 格式的sshd 日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl --since "2015-01-10" --until "2015-01-11 03:00"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl --since 09:00 --until "1 hour ago"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl --since yesterday&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl -b&lt;/code&gt; 启动以来的日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl -f&lt;/code&gt; 滚动更新日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl --disk-usage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl --vacuum-size=1G&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;太酷了。&lt;/p&gt;
&lt;p&gt;看起来没法禁用或者移除这个服务，你只能关闭日志记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-journald.service.html"&gt;https://www.freedesktop.org/software/systemd/man/systemd-journald.service.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs"&gt;https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.loggly.com/blog/why-journald/"&gt;https://www.loggly.com/blog/why-journald/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ask.fedoraproject.org/en/question/63985/how-to-correctly-disable-journald/"&gt;https://ask.fedoraproject.org/en/question/63985/how-to-correctly-disable-journald/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/sbin/lvmetad -f&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The lvmetad daemon caches LVM metadata, so that LVM commands can read metadata without scanning disks.&lt;/p&gt;
&lt;p&gt;Metadata caching can be an advantage because scanning disks is time consuming and may interfere with the normal work of the system and disks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是LVM（逻辑分卷管理器）？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can think of LVM as "dynamic partitions", meaning that you can create/resize/delete LVM "partitions" (they're called "Logical Volumes" in LVM-speak) from the command line while your Linux system is running: no need to reboot the system to make the kernel aware of the newly-created or resized partitions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来如果你在用LVM 的话，应该保留这个服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ lvscan
$ sudo apt remove lvm2 -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/lvmetad.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/lvmetad.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://askubuntu.com/questions/3596/what-is-lvm-and-what-is-it-used-for"&gt;http://askubuntu.com/questions/3596/what-is-lvm-and-what-is-it-used-for&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/lib/systemd/udevd&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd-udevd listens to kernel uevents. For every event, systemd-udevd executes matching instructions specified in udev rules.&lt;/p&gt;
&lt;p&gt;udev is a device manager for the Linux kernel. As the successor of devfsd and hotplug, udev primarily manages device nodes in the /dev directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这个服务是管理&lt;code&gt;dev&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;我不确定在虚拟机上是否需要它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-udevd.service.html"&gt;https://www.freedesktop.org/software/systemd/man/systemd-udevd.service.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/udev"&gt;https://wiki.archlinux.org/index.php/udev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/lib/systemd/timesyncd&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd-timesyncd is a system service that may be used to synchronize the local system clock with a remote Network Time Protocol server.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这是用来代替&lt;code&gt;ntpd&lt;/code&gt;的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ timedatectl status
Local time: Fri 2016-08-26 11:38:21 UTC
Universal time: Fri 2016-08-26 11:38:21 UTC
RTC time: Fri 2016-08-26 11:38:20
Time zone: Etc/UTC (UTC, +0000)
Network time on: yes
NTP synchronized: yes
 RTC in local TZ: no
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们看一下服务器上打开的端口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo netstat -nlput
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2178/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      2178/sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;赞！&lt;/p&gt;
&lt;p&gt;之前的Ubuntu 14.04 是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt-get install ntp -y
$ sudo netstat -nlput
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1380/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      1380/sshd
udp        0      0 10.19.0.6:123           0.0.0.0:*                           2377/ntpd
udp        0      0 139.59.256.256:123      0.0.0.0:*                           2377/ntpd
udp        0      0 127.0.0.1:123           0.0.0.0:*                           2377/ntpd
udp        0      0 0.0.0.0:123             0.0.0.0:*                           2377/ntpd
udp6       0      0 fe80::601:6aff:fxxx:123 :::*                                2377/ntpd
udp6       0      0 ::1:123                 :::*                                2377/ntpd
udp6       0      0 :::123                  :::*                                2377/ntpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;额。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-timesyncd.service.html"&gt;https://www.freedesktop.org/software/systemd/man/systemd-timesyncd.service.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/systemd-timesyncd"&gt;https://wiki.archlinux.org/index.php/systemd-timesyncd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/sbin/atd -f&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;atd - run jobs queued for later execution. atd runs jobs queued by at.&lt;/p&gt;
&lt;p&gt;at and batch read commands from standard input or a specified file which are to be executed at a later time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同于周期性重复执行任务的cron，&lt;code&gt;at&lt;/code&gt; 只会在指定时刻执行一次任务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo &amp;quot;touch /tmp/yolo.txt&amp;quot; | at now + 1 minute
job 1 at Fri Aug 26 10:44:00 2016
$ atq
1       Fri Aug 26 10:44:00 2016 a root
$ sleep 60 &amp;amp;&amp;amp; ls /tmp/yolo.txt
/tmp/yolo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上迄今为止我都没用过它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove at -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/atd.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/atd.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man1/at.1.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man1/at.1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://askubuntu.com/questions/162439/why-does-ubuntu-server-run-both-cron-and-atd"&gt;http://askubuntu.com/questions/162439/why-does-ubuntu-server-run-both-cron-and-atd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/lib/snapd/snapd&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Snappy Ubuntu Core is a new rendition of Ubuntu with transactional updates - a minimal server image with the same libraries as today’s Ubuntu, but applications are provided through a simpler mechanism.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Developers from multiple Linux distributions and companies today announced collaboration on the “snap” universal Linux package format, enabling a single binary package to work perfectly and securely on any Linux desktop, server, cloud or device.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显而易见这是一个简化的deb 包，你可以将所有依赖打进一个Snappy 来分发。&lt;/p&gt;
&lt;p&gt;我从来没在服务器上用Snappy 部署或分发过应用程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove snapd -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.ubuntu.com/en/snappy/"&gt;https://developer.ubuntu.com/en/snappy/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://insights.ubuntu.com/2016/06/14/universal-snap-packages-launch-on-multiple-linux-distros/"&gt;https://insights.ubuntu.com/2016/06/14/universal-snap-packages-launch-on-multiple-linux-distros/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/bin/dbus-daemon&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, D-Bus or DBus is an inter-process communication (IPC) and remote procedure call (RPC) mechanism that allows communication between multiple computer programs (that is, processes) concurrently running on the same machine&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解是桌面环境或者在服务器上运行web 应用才需要这个？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove dbus -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我想知道现在是什么时候，是否和NTP 保持同步。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ timedatectl status
Failed to create bus connection: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;糟糕。应该保留这个的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/D-Bus"&gt;https://en.wikipedia.org/wiki/D-Bus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/lib/systemd/systemd-logind&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd-logind is a system service that manages user logins.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-logind.service.html"&gt;https://www.freedesktop.org/software/systemd/man/systemd-logind.service.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/sbin/cron -f&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;cron - daemon to execute scheduled commands (Vixie Cron)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; Stay in foreground mode, don't daemonize.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以安排cron 周期性的重复执行任务。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;crontab -e&lt;/code&gt;来编辑你的配置，不过我更倾向于使用&lt;code&gt;/etc/cron.hourly&lt;/code&gt;，&lt;code&gt;/etc/cron.daily&lt;/code&gt;等目录。&lt;/p&gt;
&lt;p&gt;你可以用以下方法查看日志文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;grep cron /var/log/syslog&lt;/code&gt; 或者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl _COMM=cron&lt;/code&gt; 甚至&lt;/li&gt;
&lt;li&gt;&lt;code&gt;journalctl _COMM=cron --since="date" --until="date"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可能想保留cron。&lt;/p&gt;
&lt;p&gt;如果不想的话，应该停止和禁用这个服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl stop cron
sudo systemctl disable cron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为如果我们尝试通过&lt;code&gt;apt remove cron&lt;/code&gt;卸载它的话，系统会安装postfix！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt remove cron
The following packages will be REMOVED:
cron
The following NEW packages will be installed:
  anacron bcron bcron-run fgetty libbg1 libbg1-doc postfix runit ssl-cert ucspi-unix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看起来cron 需要通过一个邮件传输代理（MTA）来发送邮件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ apt show cron
Package: cron
Version: 3.0pl1-128ubuntu2
...
Suggests: anacron (&amp;gt;= 2.0-1), logrotate, checksecurity, exim4 | postfix | mail-transport-agent

$ apt depends cron
cron
...
Suggests: anacron (&amp;gt;= 2.0-1)
Suggests: logrotate
Suggests: checksecurity
|Suggests: exim4
|Suggests: postfix
Suggests: &amp;lt;mail-transport-agent&amp;gt;
...
exim4-daemon-heavy
    postfix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://help.ubuntu.com/community/CronHowto"&gt;https://help.ubuntu.com/community/CronHowto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-cron-to-automate-tasks-on-a-vps"&gt;https://www.digitalocean.com/community/tutorials/how-to-use-cron-to-automate-tasks-on-a-vps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://unix.stackexchange.com/questions/212355/where-is-my-logfile-of-crontab"&gt;http://unix.stackexchange.com/questions/212355/where-is-my-logfile-of-crontab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/sbin/rsyslogd -n&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Rsyslogd is a system utility providing support for message logging.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，它产生&lt;code&gt;/var/log&lt;/code&gt;下的日志文件，例如记录了SSH登录的认证消息的&lt;code&gt;/var/log/auth.log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置文件在&lt;code&gt;/etc/rsyslog.d&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;你也可以配置rsyslogd 发送日志到远程服务器，实现集中记录日志。&lt;/p&gt;
&lt;p&gt;你可以在后台脚本里（例如开机启动的脚本）使用&lt;code&gt;logger&lt;/code&gt;命令，把消息记录到&lt;code&gt;/var/log/syslog&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/bin/bash

logger Starting doing something
# NFS, get IPs, etc.
logger Done doing something
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对了，我们已经运行着&lt;code&gt;systemd-journald&lt;/code&gt;，还需要&lt;code&gt;rsyslogd&lt;/code&gt;吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rsyslog and Journal, the two logging applications present on your system, have several distinctive features that make them suitable for specific use cases. In many situations it is useful to combine their capabilities, for example to create structured messages and store them in a file database. A communication interface needed for this cooperation is provided by input and output modules on the side of Rsyslog and by the Journal's communication socke&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，可能需要吧？以防万一我决定留着它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/rsyslogd.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/rsyslogd.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man1/logger.1.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man1/logger.1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/rsyslog"&gt;https://wiki.archlinux.org/index.php/rsyslog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-rsyslog-logstash-and-elasticsearch-on-ubuntu-14-04"&gt;https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-rsyslog-logstash-and-elasticsearch-on-ubuntu-14-04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/s1-interaction_of_rsyslog_and_journal.html"&gt;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/s1-interaction_of_rsyslog_and_journal.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/sbin/acpid&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;acpid - Advanced Configuration and Power Interface event daemon&lt;/p&gt;
&lt;p&gt;acpid is designed to notify user-space programs of ACPI events. acpid should be started during the system boot, and will run as a background process, by default.&lt;/p&gt;
&lt;p&gt;In computing, the Advanced Configuration and Power Interface (ACPI) specification provides an open standard that operating systems can use to perform discovery and configuration of computer hardware components, to perform power management by, for example, putting unused components to sleep, and to do status monitoring.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是我是在虚拟机里，我不打算休眠/恢复。&lt;/p&gt;
&lt;p&gt;我要移除它看看会发生什么。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove acpid -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我能够成功&lt;code&gt;reboot&lt;/code&gt;，但是&lt;code&gt;halt&lt;/code&gt; 之后Digital Ocean任务它还在运行，所以不得不在web 界面上关闭电源。&lt;/p&gt;
&lt;p&gt;所以我应该留着它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/acpid.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/acpid.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface"&gt;https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/bin/lxcfs /var/lib/lxcfs/&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Lxcfs is a fuse filesystem mainly designed for use by lxc containers. On a Ubuntu 15.04 system, it will be used by default to provide two things: first, a virtualized view of some /proc files; and secondly, filtered access to the host’s cgroup filesystems.&lt;/p&gt;
&lt;p&gt;In summary, on a 15.04 host, you can now create a container the usual way, lxc-create ... The resulting container will have “correct” results for uptime, top, etc.&lt;/p&gt;
&lt;p&gt;It’s basically a userspace workaround to changes which were deemed unreasonable to do in the kernel. It makes containers feel much more like separate systems than they would without it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不用LXC 容器？你可以移除它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove lxcfs -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://insights.ubuntu.com/2015/03/02/introducing-lxcfs/"&gt;https://insights.ubuntu.com/2015/03/02/introducing-lxcfs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.stgraber.org/2016/03/31/lxcfs-2-0-has-been-released/"&gt;https://www.stgraber.org/2016/03/31/lxcfs-2-0-has-been-released/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/lib/accountservice/accounts-daemon&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The AccountsService package provides a set of D-Bus interfaces for querying and manipulating user account information and an implementation of these interfaces based on the usermod(8), useradd(8) and userdel(8) commands.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我移除DBus 的时候损坏了&lt;code&gt;timedatectl&lt;/code&gt;，不知道我移除了这个服务之后会损坏什么。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove accountsservice -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间会说明一切。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.linuxfromscratch.org/blfs/view/systemd/gnome/accountsservice.html"&gt;http://www.linuxfromscratch.org/blfs/view/systemd/gnome/accountsservice.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/sbin/mdadm&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;mdadm is a Linux utility used to manage and monitor software RAID devices.&lt;/p&gt;
&lt;p&gt;The name is derived from the md (multiple device) device nodes it administers or manages, and it replaced a previous utility mdctl. The original name was "Mirror Disk", but was changed as the functionality increased.&lt;/p&gt;
&lt;p&gt;RAID is a method of using multiple hard drives to act as one. There are two purposes of RAID: 1) Expand drive capacity: RAID 0. If you have 2 x 500 GB HDD then total space become 1 TB. 2) Prevent data loss in case of drive failure: For example RAID 1, RAID 5, RAID 6, and RAID 10.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以移除它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove mdadm -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Mdadm"&gt;https://en.wikipedia.org/wiki/Mdadm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://help.ubuntu.com/community/Installation/SoftwareRAID"&gt;https://help.ubuntu.com/community/Installation/SoftwareRAID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/mdadm.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/mdadm.8.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/lib/policykit-1/polkitd --no-debug&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;polkitd — PolicyKit daemon&lt;/p&gt;
&lt;p&gt;polkit - Authorization Framework&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解是这像是一个精细的sudo 。你可以允许非特权用户以root 的身份做某些操作。例如重启你的桌面版Linux。&lt;/p&gt;
&lt;p&gt;不过我运行的是一台服务器。你可以移除它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove policykit-1 -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还在考虑这样是不是破坏了某些东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/polkitd.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/polkitd.8.html&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/polkit.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/polkit.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.admin-magazine.com/Articles/Assigning-Privileges-with-sudo-and-PolicyKit"&gt;http://www.admin-magazine.com/Articles/Assigning-Privileges-with-sudo-and-PolicyKit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Polkit#Configuration"&gt;https://wiki.archlinux.org/index.php/Polkit#Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/usr/sbin/sshd -D&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;sshd (OpenSSH Daemon) is the daemon program for ssh.&lt;/p&gt;
&lt;p&gt;-D When this option is specified, sshd will not detach and does not become a daemon. This allows easy monitoring of sshd.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/sshd.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/sshd.8.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;/sbin/iscsid&lt;/h3&gt;
&lt;p&gt;iscsid 是一个运行在后台的daemon（系统服务）进程，用于配置iSCSI 和管理连接。摘自它的主页：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The iscsid implements the control path of iSCSI protocol, plus some management facilities. For example, the daemon could be configured to automatically re-start discovery at startup, based on the contents of persistent iSCSI database.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://unix.stackexchange.com/questions/216239/iscsi-vs-iscsid-services"&gt;http://unix.stackexchange.com/questions/216239/iscsi-vs-iscsid-services&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我从来没听说过iSCSI：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, iSCSI (Listeni/aɪˈskʌzi/ eye-skuz-ee) is an acronym for Internet Small Computer Systems Interface, an Internet Protocol (IP)-based storage networking standard for linking data storage facilities.&lt;/p&gt;
&lt;p&gt;By carrying SCSI commands over IP networks, iSCSI is used to facilitate data transfers over intranets and to manage storage over long distances. iSCSI can be used to transmit data over local area networks (LANs), wide area networks (WANs), or the Internet and can enable location-independent data storage and retrieval.&lt;/p&gt;
&lt;p&gt;The protocol allows clients (called initiators) to send SCSI commands (CDBs) to SCSI storage devices (targets) on remote servers. It is a storage area network (SAN) protocol, allowing organizations to consolidate storage into data center storage arrays while providing hosts (such as database and web servers) with the illusion of locally attached disks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以移除它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove open-iscsi -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;/sbin/agetty --noclear tty1 linux&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;agetty - alternative Linux getty&lt;/p&gt;
&lt;p&gt;getty, short for "get tty", is a Unix program running on a host computer that manages physical or virtual terminals (TTYs). When it detects a connection, it prompts for a username and runs the 'login' program to authenticate the user.&lt;/p&gt;
&lt;p&gt;Originally, on traditional Unix systems, getty handled connections to serial terminals (often Teletype machines) connected to a host computer. The tty part of the name stands for Teletype, but has come to mean any type of text terminal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它可以让你在物理机上登录进你的服务器。在Digital Ocean 上，你可以点击droplet 详情的&lt;code&gt;Console&lt;/code&gt;，记着你应该可以在浏览器中和一个终端交互（认为它其实是一个VNC 连接）。&lt;/p&gt;
&lt;p&gt;以前，你会看到一堆tty 在系统启动时启动（在&lt;code&gt;/etc/inittab&lt;/code&gt;中配置），但是现在它们由Systemd 按需启动。&lt;/p&gt;
&lt;p&gt;为了好玩，我移除了启动和生成&lt;code&gt;agetty&lt;/code&gt;的配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo rm /etc/systemd/system/getty.target.wants/getty@tty1.service
sudo rm /lib/systemd/system/getty@.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当我重启服务器之后，我还能够通过SSH 连接上，不过没法通过Digital Ocean web 终端登录。&lt;br&gt;
&lt;img alt="htop-login" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153446.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/getty.8.html"&gt;http://manpages.ubuntu.com/manpages/xenial/man8/getty.8.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Getty_(Unix)"&gt;https://en.wikipedia.org/wiki/Getty_(Unix)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://0pointer.de/blog/projects/serial-console.html"&gt;http://0pointer.de/blog/projects/serial-console.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://unix.stackexchange.com/questions/56531/how-to-get-fewer-ttys-with-systemd"&gt;http://unix.stackexchange.com/questions/56531/how-to-get-fewer-ttys-with-systemd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;sshd: root@pts/0 &amp;amp; -bash &amp;amp; htop&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sshd: root@pts/0&lt;/code&gt;表示用户&lt;code&gt;root&lt;/code&gt;在#&lt;code&gt;0&lt;/code&gt;号虚拟终端（&lt;code&gt;pts&lt;/code&gt;）上建立了一个SSH 会话。一个虚拟终端模仿一个真正的文本终端。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash&lt;/code&gt; 是我在用的shell。&lt;/p&gt;
&lt;p&gt;为什么开头有一个破折号？Reddit 用户hirnbrot 很好的解释了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There's a dash at the beginning because launching it as "-bash" will make it a login shell. A login shell is one whose first character of argument zero is a -, or one started with the --login option. This will then cause it to read a different set of configuration files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;htop&lt;/code&gt;是一个运行在截图中的交互式进程查看工具。&lt;/p&gt;
&lt;h3&gt;结束之后&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove lvm2 -y --purge
sudo apt remove at -y --purge
sudo apt remove snapd -y --purge
sudo apt remove lxcfs -y --purge
sudo apt remove mdadm -y --purge
sudo apt remove open-iscsi -y --purge
sudo apt remove accountsservice -y --purge
sudo apt remove policykit-1 -y --purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="canyoukillit-after" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153459.png"&gt;&lt;/p&gt;
&lt;p&gt;极限版：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt remove dbus -y --purge
sudo apt remove rsyslog -y --purge
sudo apt remove acpid -y --purge
sudo systemctl stop cron &amp;amp;&amp;amp; sudo systemctl disable cron
sudo rm /etc/systemd/system/getty.target.wants/getty@tty1.service
sudo rm /lib/systemd/system/getty@.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="canyoukillit-after-extreme" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153514.png"&gt;&lt;/p&gt;
&lt;p&gt;我按照我的博客文章&lt;a href="https://peteris.rocks/blog/unattended-installation-of-wordpress-on-ubuntu-server/"&gt;about unattended installation of WordPress on Ubuntu Server &lt;/a&gt;的步骤安装，成功了。&lt;/p&gt;
&lt;p&gt;这是nginx，PHP7 和MySQL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="canyoukillit-after-extreme-wp" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153534.png"&gt;&lt;/p&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;有时候只看&lt;code&gt;strace&lt;/code&gt; 是不够的。 &lt;br&gt;
另外一个找出一个程序到底做了什么是读它的源代码。&lt;br&gt;
首先，我需要找到我们从哪里开始看。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ which uptime
/usr/bin/uptime
$ dpkg -S /usr/bin/uptime
procps: /usr/bin/uptime
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们发现&lt;code&gt;uptime&lt;/code&gt;实际上是位于&lt;code&gt;/usr/bin/uptime&lt;/code&gt;，并且在Ubuntu 上它是&lt;code&gt;proccps&lt;/code&gt; 软件包的一部分。&lt;/p&gt;
&lt;p&gt;你可以到&lt;a href="http://packages.ubuntu.com/"&gt;http://packages.ubuntu.com/&lt;/a&gt; 上搜索这个软件包。&lt;/p&gt;
&lt;p&gt;这是&lt;code&gt;procps&lt;/code&gt;的页面：&lt;a href="http://packages.ubuntu.com/source/xenial/procps"&gt;http://packages.ubuntu.com/source/xenial/procps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你滚动到页面底部，你会看到源代码库的链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debian Package Source Repository git://git.debian.org/collab-maint/procps.git&lt;/li&gt;
&lt;li&gt;Debian Package Source Repository (Browsable) &lt;a href="https://anonscm.debian.org/cgit/collab-maint/procps.git/"&gt;https://anonscm.debian.org/cgit/collab-maint/procps.git/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文件描述符和重定向&lt;/h3&gt;
&lt;p&gt;当你想把标准错误输出(stderr)重定向到标准输出(stdout)，是用&lt;code&gt;2&amp;amp;&amp;gt;1&lt;/code&gt; 还是&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;你可以通过认识到&lt;code&gt;echo something &amp;gt; file&lt;/code&gt;将会写&lt;code&gt;something&lt;/code&gt;到文件&lt;code&gt;file&lt;/code&gt;中来记住&lt;code&gt;&amp;amp;&lt;/code&gt;符号的位置。这和&lt;code&gt;echo something 1&amp;gt; file&lt;/code&gt;一样。现在，&lt;code&gt;echo something 2&amp;gt; file&lt;/code&gt;会把stderr 输出到&lt;code&gt;file&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你写的是&lt;code&gt;echo something 2&amp;gt;1&lt;/code&gt;，意味着你把stderr 重定向到一个叫&lt;code&gt;1``的文件。加个空格看起来更清晰一些：&lt;/code&gt;echo something 2&amp;gt; 1`。&lt;/p&gt;
&lt;p&gt;如果你在&lt;code&gt;1&lt;/code&gt;前面加一个&lt;code&gt;&amp;amp;&lt;/code&gt;，表示&lt;code&gt;1&lt;/code&gt;不是一个文件名而是一个流ID。所以应该是&lt;code&gt;echo something 2&amp;gt;&amp;amp;1&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;PuTTY 的颜色&lt;/h3&gt;
&lt;p&gt;如果你使用PuTTY 的时候，在htop 发现缺少一些彩色元素，下面是解决方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右击标题栏&lt;/li&gt;
&lt;li&gt;点击Change settings...&lt;/li&gt;
&lt;li&gt;跳到Window -&amp;gt; Colours&lt;/li&gt;
&lt;li&gt;选择Both 单选按钮&lt;/li&gt;
&lt;li&gt;点击应用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="putty-settings" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301153557.png"&gt;&lt;/p&gt;
&lt;h3&gt;C 写的Shell&lt;/h3&gt;
&lt;p&gt;让我们用C 写一个非常简单的shell，显示下使用&lt;code&gt;fork&lt;/code&gt;/&lt;code&gt;exec&lt;/code&gt;/&lt;code&gt;wait&lt;/code&gt;系统调用。这是程序&lt;code&gt;shell.c&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Welcome to my shell&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;gt; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// strip \n&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;exit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// shell built-in&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Executing: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;execlp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;waitpid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child exited with %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WEXITSTATUS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;gcc shell.c -o shell
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ./shell
Welcome to my shell
&amp;gt; date
Executing: date
Thu Dec  1 14:10:59 UTC 2016
Child exited with 0
&amp;gt; true
Executing: true
Child exited with 0
&amp;gt; false
Executing: false
Child exited with 1
&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你有没有想过为什么运行一个后台程序的时候，只能在你按下&lt;code&gt;Enter&lt;/code&gt;之后一会才能看到它退出了？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sleep 1 &amp;amp;
[1] 11686
$ # press Enter
[1]+  Done                    sleep 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是因为shell 一直唉等待你的输入。只有当你输入一个命令之后，它才会检查后台程序的状态，如果它们终止了就会显示出来。&lt;/p&gt;
&lt;h2&gt;TODO&lt;/h2&gt;
&lt;p&gt;这是我还想要了解的更加详细的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;process state substatuses (&lt;code&gt;Ss&lt;/code&gt;, &lt;code&gt;Ss+&lt;/code&gt;, &lt;code&gt;R+&lt;/code&gt;, etc.)&lt;/li&gt;
&lt;li&gt;kernel threads&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/pts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;more about memory (&lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;DATA&lt;/code&gt;, &lt;code&gt;SWAP&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;figure out time slices length&lt;/li&gt;
&lt;li&gt;Linux scheduler algorithm&lt;/li&gt;
&lt;li&gt;pinning proceses to cores&lt;/li&gt;
&lt;li&gt;write about manual pages&lt;/li&gt;
&lt;li&gt;cpu/memory colors in bars&lt;/li&gt;
&lt;li&gt;process ID limit &amp;amp; fork bomb&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof&lt;/code&gt;, &lt;code&gt;ionice&lt;/code&gt;, &lt;code&gt;schedtool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新&lt;/h2&gt;
&lt;p&gt;这是文章自发布以来较大的更正和更新列表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Idle time in &lt;code&gt;/proc/uptime&lt;/code&gt; is the sum of all cores (Dec 2, 2016)&lt;/li&gt;
&lt;li&gt;My parent/child &lt;code&gt;printf&lt;/code&gt; in &lt;code&gt;zombie.c&lt;/code&gt; was reversed (Dec 2, 2016)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt remove cron&lt;/code&gt; installs &lt;code&gt;postfix&lt;/code&gt; because of a dependency to an MTA (Dec 3, 2016)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; can load information from other sources (via &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;), not just &lt;code&gt;/etc/passwd&lt;/code&gt; (Dec 3, 2016)&lt;/li&gt;
&lt;li&gt;Describe &lt;code&gt;/etc/shadow&lt;/code&gt; password hash format (Dec 3, 2016)&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;visudo&lt;/code&gt; to edit the &lt;code&gt;/etc/sudoers&lt;/code&gt; file to be safe (Dec 3, 2016)&lt;/li&gt;
&lt;li&gt;Explain &lt;code&gt;MEM%&lt;/code&gt; (Dec 3, 2016)&lt;/li&gt;
&lt;li&gt;Rewrite the section about load averages (Dec 4, 2016)&lt;/li&gt;
&lt;li&gt;Fix: &lt;code&gt;kill 1234&lt;/code&gt; by default sends &lt;code&gt;TERM&lt;/code&gt; not &lt;code&gt;INT&lt;/code&gt; (Dec 7, 2016)&lt;/li&gt;
&lt;li&gt;Explain CPU and memory color bars (Dec 7, 2016)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;如果这篇文章有错误请让我知道！我很乐意更正它。&lt;/p&gt;</content><category term="2017"></category><category term="htop"></category><category term="linux"></category></entry><entry><title>《极客与团队》读书笔记</title><link href="https://fangpsh.github.io/posts/2017/2017-01-28.html" rel="alternate"></link><published>2017-01-28T20:00:30+08:00</published><updated>2017-01-28T20:00:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-01-28:/posts/2017/2017-01-28.html</id><summary type="html">&lt;p&gt;&lt;img alt="team_geek_cover" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302132558.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/21372237/"&gt;《极客与团队》&lt;/a&gt;这本书是在看&lt;a href="https://blog.youxu.info/2015/05/17/tech-lead-1/"&gt;《技术管理猪鸡-1 开篇》&lt;/a&gt;注意到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google 的芝加哥 office 有两个技术领导：Brian Fitzpatrick 和 Ben Collins-Sussman。他们合写了一本书 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="team_geek_cover" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302132558.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/21372237/"&gt;《极客与团队》&lt;/a&gt;这本书是在看&lt;a href="https://blog.youxu.info/2015/05/17/tech-lead-1/"&gt;《技术管理猪鸡-1 开篇》&lt;/a&gt;注意到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google 的芝加哥 office 有两个技术领导：Brian Fitzpatrick 和 Ben Collins-Sussman。他们合写了一本书，叫做 Team Geek。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本书的副标题是“软件工程师的团队生存秘笈”，毕业一年认识到和同事合作、如何更高效的推进工作也十分重要，正如作者在书一开始提到了书的宗旨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本书旨在帮助程序员改进理解他人、与人沟通，以及与人合作的能力，进而使其在编写软件的过程中变的更有效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本书的核心是“HRT”，即“谦虚”，“尊重”，“信任”，不算是什么秘诀，但却非常难做到，一遍读，一遍想着工作中的一幕幕，感慨良多，希望能在阅读完这本书之后，在下一份工作中有更好的表现吧。&lt;br&gt;
把书中的内容要点，以及一些随想简单的记录如下，方便日后查阅。  &lt;/p&gt;
&lt;h2&gt;注重团队合作和分享&lt;/h2&gt;
&lt;p&gt;公开透明和信任可以极大的降低成本，以及强化公车因子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公车因子：：一个项目里，需要有多少个人被公交车撞到才能令其完全瘫痪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩大“公车因子”，避免出现领地感。&lt;/p&gt;
&lt;p&gt;分享协作，然后有良好的文档积累，可以让单个人免于四处救火，想起了&lt;a href="https://book.douban.com/subject/26644070/"&gt;《凤凰项目》&lt;/a&gt;里的超级员工“布伦特”。另外团队合作带来的荣誉感和激励作用也非常大，过去一年的工作所在的团队并没有让我有这种感觉。&lt;/p&gt;
&lt;h2&gt;三支柱（HRT）：谦虚，尊重，信任&lt;/h2&gt;
&lt;p&gt;谦虚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有人是宇宙中心。谁也不是万能的，谁都会犯错。你必须不断地提高自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尊重&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你必须真心实意地关心同事。他们都是活生生的人，他们的能力和成绩都需要得到肯定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;信任&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要相信别人的能力和判断力，在适当的时候懂得放权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="HRT" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171735.png"&gt;&lt;/p&gt;
&lt;h3&gt;HRT 实战&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;放下自负&lt;/li&gt;
&lt;li&gt;学会批评和接受批评&lt;ul&gt;
&lt;li&gt;“别把你的自尊和你的代码等同起来”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速失败；学习；迭代&lt;ul&gt;
&lt;li&gt;“失败是可以接受的”&lt;/li&gt;
&lt;li&gt;“不要等到完美的时候再出来”&lt;/li&gt;
&lt;li&gt;“真正的检讨应该包含有关学到了什么，以及怎么改正等经验教训的详细注解”，为了方便以后查看，和总结积累经验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为学习预留时间&lt;/li&gt;
&lt;li&gt;学习保持耐心&lt;/li&gt;
&lt;li&gt;对影响保持开放的态度&lt;ul&gt;
&lt;li&gt;“你越是容易受影响，你就越能影响别人；你越是示弱，你就越强壮”&lt;/li&gt;
&lt;li&gt;“同事是合作者，不是竞争者”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;团队文化&lt;/h2&gt;
&lt;p&gt;作者在这里说的文化，其实更像一种团队氛围，以及团队内形成的默契，而不是阿里那种强价值观的文化。好的文化可以薰陶新人，让团队健康的运作，最终的目的都是带来更高效的产出。&lt;/p&gt;
&lt;p&gt;“如果你想要优秀的工程师为自己的团队工作，首先的就是雇佣出色的工程师”，优秀的人总是倾向于和优秀的人一起工作，能够保持更好的节奏，也更好沟通，也常常见到劣币驱逐良币的情况。&lt;/p&gt;
&lt;p&gt;优秀的人，大多数都很有主见和想法，可以说是比较难“管理”，一群平庸、溷日子的人好管理，但是毫无战斗力。“基于共识决策的团队”，是让团队成员都有主人翁精神和责任感，这个时候，好的TeamLeader不会担心自己的地位受到威胁，而应该注重团结，和倾听意见。&lt;/p&gt;
&lt;h3&gt;对付害群之马&lt;/h3&gt;
&lt;p&gt;这是第四章的内容，但是作者在团队文化这章提到了，就给总结到一起了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要剔走的是行为本身，而不是人。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;害群之马：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不尊重别人的时间&lt;/li&gt;
&lt;li&gt;自负&lt;/li&gt;
&lt;li&gt;过分索求&lt;/li&gt;
&lt;li&gt;幼稚或者莫名其妙的偏执妄想&lt;/li&gt;
&lt;li&gt;完美主义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转移完美主义者的注意力&lt;/li&gt;
&lt;li&gt;别去搭理挑衅的家伙，无视是最好的办法&lt;/li&gt;
&lt;li&gt;别太感情用事&lt;/li&gt;
&lt;li&gt;抓住重点处理问题&lt;/li&gt;
&lt;li&gt;对付挑衅要不卑不亢&lt;/li&gt;
&lt;li&gt;知道什么应该放弃&lt;/li&gt;
&lt;li&gt;关注长远&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一部分还是需要看书中的详细解释才好回顾，只看这些有些宽泛。&lt;/p&gt;
&lt;h3&gt;沟通&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;“沟通的指导原则之一就是在同步沟通的时候（比如开会），人越少越好。而在异步沟通的时候（比如E-mail），涉及的听众越多越好。”&lt;/strong&gt;&lt;br&gt;
更重要的是，你必须确保文档里的信息要尽可能地让所有人都看到。  &lt;/p&gt;
&lt;p&gt;想起之前一份工作，公司强烈依赖IM 工具，不胜其扰。而且某些领导一点小事就喜欢开个会，“聊一下”，然后一部分人放下手头工作去了之后，只是站了几十分钟，回来还得拿起刚刚放下的事情，非常要命。&lt;/p&gt;
&lt;h3&gt;高层面同步&lt;/h3&gt;
&lt;p&gt;制定任务宗旨，准确定义产品的方向和范围，这样大家知道努力方向，同时出现分歧的时候，结果能够更好的达成一致。&lt;/p&gt;
&lt;p&gt;开会要有效率,开会的五条小贴士&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只邀请一定要参加的人&lt;/li&gt;
&lt;li&gt;开会前要决定好议程，而且要事先通知所有人&lt;/li&gt;
&lt;li&gt;达成目的后应该提早散会&lt;/li&gt;
&lt;li&gt;注意别跑题&lt;/li&gt;
&lt;li&gt;镜像币会议安排在休息时间前后（比如午饭时间，下班前等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;远程团队要多沟通，同时也要勇于见面&lt;/p&gt;
&lt;p&gt;注重文档的编写和积累&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;日常沟通&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;邮件列表&lt;/li&gt;
&lt;li&gt;在线聊天&lt;ul&gt;
&lt;li&gt;尽量群聊&lt;/li&gt;
&lt;li&gt;聊天记录可检索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用Bug 跟踪系统&lt;/h3&gt;
&lt;h3&gt;代码注释&lt;/h3&gt;
&lt;p&gt;“注释应该尽量解释为什么代码要那么写，而不是去解释代码做了什么”，“注释不应该涉及过多细节”，“过犹不及”。&lt;/p&gt;
&lt;h3&gt;代码署名&lt;/h3&gt;
&lt;p&gt;作者不建议在代码中进行署名，更好的方式应该是通过版本控制工具，在里面进行跟踪，例如git。&lt;br&gt;
之前工作中，需要写很多监控脚本，为了以后找到对应的负责人，会在脚本开头署名，不过如果当初大家通过git 协作的话，就没这个必要了。&lt;/p&gt;
&lt;h3&gt;代码审查&lt;/h3&gt;
&lt;p&gt;“代码改动应该尽量短小以保证审查的质量。”&lt;/p&gt;
&lt;h3&gt;测试和发布&lt;/h3&gt;
&lt;p&gt;测试和发布流程应该尽可能的自动化，测试自动化程度越高，“在修复bug 和添加新特性的时候就越自信”，也容易更早得发现问题。发布流程越自动，越流畅快速，可以让产品迭代得越快。&lt;/p&gt;
&lt;h2&gt;团队主管&lt;/h2&gt;
&lt;p&gt;“传统型经理关心的是怎么完成任务，而主管只关心完成了什么任。。。。（并且相信团队能自己想出解决方法）。”，主管只需要负责设定大方向，这也是“信任”的一种表现。&lt;/p&gt;
&lt;h3&gt;仆人式领导&lt;/h3&gt;
&lt;p&gt;“仆人式领导要为团队填补前进道路上的裂缝，并在必要的时候给予建议，同时还要勇于冲到第一线。仆人式领导唯一要做的管理工程师就是对团队的技术和人事健康情况负责。”&lt;/p&gt;
&lt;h3&gt;反模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;雇佣听话的人&lt;/li&gt;
&lt;li&gt;无视表现不佳的人&lt;/li&gt;
&lt;li&gt;无视人际关系&lt;/li&gt;
&lt;li&gt;和谁都是朋友&lt;/li&gt;
&lt;li&gt;降低招聘标准&lt;/li&gt;
&lt;li&gt;把团队当小孩子&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;领袖的处事之道&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;放下自负&lt;ul&gt;
&lt;li&gt;“如果你能鼓励这种提问，你才能有更多的机会听到谏言，这能让你成为一个更好的领袖，团队也会变得更加成功”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;做一个禅师&lt;/li&gt;
&lt;li&gt;保持澹定和冷静&lt;/li&gt;
&lt;li&gt;“工程师来问你建议通常是不是你去解决他的问题，而是要你帮助他解决问题，所以最简单的方法应该是问问题”，“正确的做法是在HRT 的原则下，帮助他解决分析问题，从而达到让他自己解决问题的目的”，“这通常能引导工程师得出答桉，最重要的是，这是他自己想出来的答桉，因为也就回到了本章开头所讲的主人翁精神和责任感。”&lt;/li&gt;
&lt;li&gt;成为催化剂&lt;/li&gt;
&lt;li&gt;引导大家达成共识&lt;/li&gt;
&lt;li&gt;给予团队安全感&lt;/li&gt;
&lt;li&gt;“在遭受失败的时候指责个人则不利团队，而且会从根本上阻碍承担风险的意愿”，“个人的成功可以在众人面前表彰，但个人的失败最好还是私下检讨”，“需要公开批评某一个人的情况几乎是不存在的，绝大多数时候这样做都是很过分，很残忍的。团队里的其他人肯定早就知道这个人把事情办砸了，所以完全没必要重复讲。”，应该抓住机会帮助团队从失败从成长起来。&lt;/li&gt;
&lt;li&gt;当一个导师&lt;/li&gt;
&lt;li&gt;三个条件：&lt;ul&gt;
&lt;li&gt;熟悉团队的流程和系统&lt;/li&gt;
&lt;li&gt;向他人解释事物的能力&lt;/li&gt;
&lt;li&gt;估计被知道的人到底需要多少帮助的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置明确的目标&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;坦诚&lt;ul&gt;
&lt;li&gt;警惕三明治赞美法，即先赞美，再批评，再赞美。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记录团队的快乐程度&lt;ul&gt;
&lt;li&gt;建立信任，建议一对一会议结束的时候问“你还有什么要求吗”，考虑团队成员的诉求。&lt;/li&gt;
&lt;li&gt;“绝对不要以为人人都是工作狂----对别人在工作上能投入的时间不要有不切实际的期望。否则很容易失去别人对你的尊敬，甚至彻底绝望。”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不必事事躬亲，但也不能当甩手掌柜&lt;/li&gt;
&lt;li&gt;寻找接班人&lt;/li&gt;
&lt;li&gt;知道什么时候要做恶人&lt;ul&gt;
&lt;li&gt;不符合团队要求的人，拖的越久，对团队伤害越大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护团队不受溷乱干扰&lt;/li&gt;
&lt;li&gt;帮团队遮风挡雨  &lt;ul&gt;
&lt;li&gt;“在条件允许的情况下，应该尽可能的和团队分享信息，但是也不要把那些不太可能会直接影响到他们的事情告诉他们，这种组织性的溷乱只会让他们分析”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;告诉团队他们干得很好&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;激励&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给工程师一个目标；&lt;/li&gt;
&lt;li&gt;让工程师有机会学习新技术和提高技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;操作组织的艺术&lt;/h2&gt;
&lt;p&gt;这一章作者列了一些工程师遇到具体问题该如何处理，节选几句印象深刻的话。&lt;/p&gt;
&lt;p&gt;“要尽可能确保你的经理以及团队之外的人不但知道你在干嘛，还要知道你干的很棒”&lt;/p&gt;
&lt;p&gt;“在做承诺的时候要谨慎，而干工作的时候要尽最大努力”&lt;/p&gt;
&lt;p&gt;“不管技术债务有多少，团队也永远不应该花超过三分之一甚至一半的时间和精力去做防御性的工作，否则就等于政治自杀”&lt;/p&gt;
&lt;p&gt;写邮件求助要采用“三个论点和一个行动”，绝对不能有其他内容，让他人能在10秒内读完。&lt;/p&gt;
&lt;h2&gt;和用户的关系&lt;/h2&gt;
&lt;p&gt;软件要服务的是用户，最后一章列了一些例如“要多沟通”，“注意第一印象”，“关注用户”，虽然都很有道理，比较杂乱，是一些经验之谈，读完就要用起来非常难。&lt;/p&gt;
&lt;p&gt;整本书的内容都是围绕HRT，不过人和人之间，总是能和HRT 扯上关系。
每章的独立性其实不是很强，作者在讲很多论点的时候，会穿插其他内容。总之，看完也很难记住，只能记住HRT，好好工作，多实践。&lt;/p&gt;</content><category term="2017"></category><category term="teamwork"></category><category term="book"></category></entry><entry><title>Salt Minion ID 变为FQDN 记录的问题</title><link href="https://fangpsh.github.io/posts/2017/2017-01-09.html" rel="alternate"></link><published>2017-01-09T18:31:30+08:00</published><updated>2017-01-09T18:31:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2017-01-09:/posts/2017/2017-01-09.html</id><summary type="html">&lt;p&gt;最近在一台外网机器上起了salt minion ，但是同事发现&lt;code&gt;/etc/salt/minion_id&lt;/code&gt; 不对，之前自动生成的minion_id 都是机器的&lt;code&gt;/etc/hostname&lt;/code&gt;,这回变成了一个奇怪的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近在一台外网机器上起了salt minion ，但是同事发现&lt;code&gt;/etc/salt/minion_id&lt;/code&gt; 不对，之前自动生成的minion_id 都是机器的&lt;code&gt;/etc/hostname&lt;/code&gt;,这回变成了一个奇怪的域名：&lt;code&gt;cncXXXX.XXX.ln.cn&lt;/code&gt;，并且这个域名和使用 &lt;code&gt;hostname --all-fqdns&lt;/code&gt; 返回的结果相同。先查下minion_id 是怎么生成的。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/saltstack/salt/blob/a380c12159a3a6691081d30e33c16e6f534c4482/doc/topics/tutorials/walkthrough.rst"&gt;Github:saltstack/salt/doc/topics/tutorials/walkthrough.rst&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the minion is started, it will generate an id value, unless it has been generated on a previous run and cached (in /etc/salt/minion_id by default). This is the name by which the minion will attempt to authenticate to the master. The following steps are attempted, in order to try to find a value that is not localhost:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Python function socket.getfqdn() is run&lt;/li&gt;
&lt;li&gt;/etc/hostname is checked (non-Windows only)&lt;/li&gt;
&lt;li&gt;/etc/hosts (%WINDIR%\system32\drivers\etc\hosts on Windows hosts) is checked for hostnames that map to anything within 127.0.0.0/8.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If none of the above are able to produce an id which is not localhost, then a sorted list of IP addresses on the minion (excluding any within 127.0.0.0/8) is inspected. The first publicly-routable IP address is used, if there is one. Otherwise, the first privately-routable IP address is used.&lt;/p&gt;
&lt;p&gt;If all else fails, then localhost is used as a fallback.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应该是第一点，通过&lt;code&gt;socket.getfqdn&lt;/code&gt; 拿到的结果，也验证了和上文提到的&lt;code&gt;hostname --all-fqdns&lt;/code&gt; 拿到的结果一样。&lt;/p&gt;
&lt;h2&gt;FQDN是什么?&lt;/h2&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name"&gt;FQDN&lt;/a&gt;全称是"Fully qualified domain name",中文叫&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%95%B4%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1"&gt;完整网域名称&lt;/a&gt;,更细致的介绍看鸟哥的解释&lt;a href="http://linux.vbird.org/linux_server/0350dns.php#fqdn"&gt;完整主机名称： Fully Qualified Domain Name (FQDN)&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;socket.getfqdn()&lt;/h2&gt;
&lt;p&gt;看下这个函数的实现, &lt;a href="https://svn.python.org/projects/python/trunk/Lib/socket.py"&gt;socket.py&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;getfqdn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Get fully qualified domain name from name.&lt;/span&gt;

&lt;span class="sd"&gt;    An empty argument is interpreted as meaning the local host.&lt;/span&gt;

&lt;span class="sd"&gt;    First the hostname returned by gethostbyaddr() is checked, then&lt;/span&gt;
&lt;span class="sd"&gt;    possibly existing aliases. In case no FQDN is available, hostname&lt;/span&gt;
&lt;span class="sd"&gt;    from gethostname() is returned.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0.0.0.0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gethostname&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ipaddrs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gethostbyaddr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;返回结果应该是gethostbyaddr() 这个函数返回的，这个函数的介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gethostbyaddr() -- map an IP number or hostname to DNS info.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到的结果应该就是一个反查IP的时候拿到的&lt;a href="https://en.wikipedia.org/wiki/Reverse_DNS_lookup"&gt;PTR记录&lt;/a&gt;。证实一下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="salt-minion-id-dig-x" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164133.png"&gt;&lt;/p&gt;
&lt;p&gt;看来这个IP 之前有人用过，然后添加了一条PTR 记录，也没办法删了，再继续看看这个gethostbyaddr 的实现和工作原理，看看能怎么解决。&lt;/p&gt;
&lt;p&gt;关于这个函数更详细的介绍，来自&lt;a href="https://docs.python.org/2/library/socket.html#socket.gethostbyaddr"&gt;python.org/2/library/socket&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;socket.gethostbyaddr(ip_address)&lt;/p&gt;
&lt;p&gt;Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). To findthe fully qualified domain name, use the function getfqdn(). gethostbyaddr() supports both IPv4 and IPv6.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个函数的实现：&lt;a href="https://github.com/python/cpython/blob/29ac8f827d040faa37cfbd5b41f3a9891056d7c1/Modules/socketmodule.c"&gt;cpython/socketmodule.c&lt;/a&gt;, 应该是调用了系统的gethostbyaddr_r，不过也有一个自己实现的&lt;a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Modules/getaddrinfo.c"&gt;cpython/getaddrinfo.c)&lt;/a&gt;，Linux 系统提供的gethostbyaddr 的介绍，实现上应该是类似的, &lt;a href="http://man7.org/linux/man-pages/man3/gethostbyaddr.3.html"&gt;GETHOSTBYNAME(3)&lt;/a&gt;, 这个函数依赖了下列三个配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/host.conf
  resolver configuration file

/etc/hosts
  host database file

/etc/nsswitch.conf
  name service switch configuration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;a href="http://man7.org/linux/man-pages/man5/nsswitch.conf.5.html"&gt;nsswitch.conf&lt;/a&gt; 定义了一些C 函数库进行操作搜索的动作，先后顺序。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Name_Service_Switch"&gt;Name Service Switch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The Name Service Switch (NSS) is a facility in Unix-like operating systems that provides a variety of sources for
common configuration databases and name resolution mechanisms. These sources include local operating system files
(such as /etc/passwd, /etc/group, and /etc/hosts), the Domain Name System (DNS), the Network Information Service (NIS), and LDAP.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;nsswith.conf&lt;/code&gt; 文件中指定了hosts 查询的先后顺序：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hosts       Host names and numbers, used by gethostbyname(3) and  related functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前的配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#       dns                     Use DNS (Domain Name Service)
#       files                   Use the local files

#hosts:     db files nisplus nis dns
hosts:      files dns myhostname
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考手册，按照配置的定义，关于hosts，会先查files，而对于hosts，对应的files 是/etc/hosts，然后是dns 查询，最后是看&lt;code&gt;/etc/hostname&lt;/code&gt;。
做下实验，把配置改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hosts:      files 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;socket.getfqdn()&lt;/code&gt; 返回结果为空。&lt;/p&gt;
&lt;p&gt;配置改成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hosts:  myhostname files dns
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;socket.getfqdn()&lt;/code&gt; 返回结果为&lt;code&gt;/etc/hostname&lt;/code&gt; 的内容。&lt;/p&gt;
&lt;p&gt;到这里可以找到解决方法了，把文章开头出问题的这台机器的&lt;code&gt;nsswitch.conf&lt;/code&gt; 如上配置，myhostname 放到前面即可解决问题。&lt;/p&gt;
&lt;h2&gt;hostname --all-fqdns&lt;/h2&gt;
&lt;p&gt;在返回来看看，一开始&lt;code&gt;hostname --all-fqdns&lt;/code&gt; 的结果和&lt;code&gt;socket.getfqdn()&lt;/code&gt; 一样，并再上文更改&lt;code&gt;nsswithc.conf&lt;/code&gt; 的配置过程中，插件结果表现也是一致的。
找Hostname 的&lt;a href="https://packages.debian.org/source/stable/hostname"&gt;源代码&lt;/a&gt;看下，&lt;br&gt;
&lt;img alt="hostname-getnameinfo" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164145.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;getnameinfo  -  address-to-name  translation  in protocol-independent  manner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;getnameinfo() 的功能和 gethostbyaddr() 类似，具体见:&lt;a href="http://man7.org/linux/man-pages/man3/getnameinfo.3.html"&gt;GETNAMEINFO(3) &lt;/a&gt;，也可以通过&lt;code&gt;nsswitch.conf&lt;/code&gt; 配置hosts 的查询顺序。&lt;/p&gt;</content><category term="2017"></category><category term="saltstack"></category><category term="fqdn"></category><category term="dns"></category></entry><entry><title>HAProxy 最佳实践笔记</title><link href="https://fangpsh.github.io/posts/2016/2016-12-09.html" rel="alternate"></link><published>2016-12-09T15:30:00+08:00</published><updated>2016-12-09T15:30:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-12-09:/posts/2016/2016-12-09.html</id><summary type="html">&lt;p&gt;&lt;img alt="haproxy_best_practice" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164657.png"&gt;  &lt;/p&gt;
&lt;p&gt;这篇笔记内容主要来自Haproxy官方团队分享的一个幻灯片:&lt;a href="http://www.slideshare.net/haproxytech/haproxy-best-practice"&gt;《Haproxy best practice》&lt;/a&gt;，介绍了一些常规的配置方式和优化手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要盲目使用文中出现的所有技巧。&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Haproxy 是如何 …&lt;/h2&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="haproxy_best_practice" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164657.png"&gt;  &lt;/p&gt;
&lt;p&gt;这篇笔记内容主要来自Haproxy官方团队分享的一个幻灯片:&lt;a href="http://www.slideshare.net/haproxytech/haproxy-best-practice"&gt;《Haproxy best practice》&lt;/a&gt;，介绍了一些常规的配置方式和优化手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要盲目使用文中出现的所有技巧。&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Haproxy 是如何工作的&lt;/h2&gt;
&lt;p&gt;关于Haproxy 团队介绍，以及一些特性介绍直接看前面几张幻灯片即可。
Haproxy 的主要用作代理请求，工作流程如下：&lt;br&gt;
&lt;img alt="haproxy_proxy_mode" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164706.png"&gt;  &lt;/p&gt;
&lt;p&gt;client 和Haproxy 建立连接，Haproxy 再和对应的后端server 建立连接，然后作为中间人，转发请求。
在Haproxy 配置中，对一个代理，会划分为2层，frontend（前端） 和backend（后端），这和上文说的Haproxy 的工作流程也是对应的。  &lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;配置例（来自幻灯片）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;global
  daemon
defaults
  mode http
  timeout client 10s
  timeout connect 4s
  timeout server 30s

frontend fe
  bind 10.0.0.1:80
  bind 10.0.0.1:443 ssl crt ./my.pem
  default_backend be

backend be
  server s1 10.0.0.101:80 check
  server s2 10.0.0.102:80 check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="haproxy_frontend_backend" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164718.png"&gt;  &lt;/p&gt;
&lt;p&gt;frontend:监听端口、协议代理定义，HTTP认证，后端选择等；&lt;br&gt;
backend:监控server，负载均衡，队列。&lt;br&gt;
可以看出，在frontend 中定义了要绑定的地址和端口，以及证书等，在backend，罗列了后端的IP和端口。不过要把2者合在一起写，也是可以的，使用listen 即可，如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;listen http-in
    bind *:80
    server server1 127.0.0.1:8000 maxconn 32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;A &amp;quot;frontend&amp;quot; section describes a set of listening sockets accepting client
connections.

A &amp;quot;backend&amp;quot; section describes a set of servers to which the proxy will connect
to forward incoming connections.

A &amp;quot;listen&amp;quot; section defines a complete proxy with its frontend and backend
parts combined in one section. It is generally useful for TCP-only traffic.

摘自 http://www.haproxy.org/download/1.4/doc/configuration.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;RTF(W|E|L)M&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;阅读（Warings/Errors/Log）消息。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HAProxy 会向stderr（标准错误输出） 输出配置错误信息；&lt;ul&gt;
&lt;li&gt;当配置文件中出现错误的时候，warning消息会输出到stderr。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当开启日志记录的时候，可以发送消息到syslog&lt;/li&gt;
&lt;li&gt;HAProxy 会提供一条消息，来解释错误，有时候也会提供修复方法。
如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[WARNING] 177/011147 (8652) : Setting tune.ssl.default-dh-param to 1024 by default, if your workload permits it
Configuration file is valid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HAProxy 的日志信息非常丰富，也可以自定义日志格式，对于线上排查故障非常有用。&lt;/p&gt;
&lt;h2&gt;硬件推荐&lt;/h2&gt;
&lt;p&gt;由于HAProxy 的工作机制，需求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU:相对于多核心，更应该看重速度（也就是主频更高），和缓存大小。&lt;/li&gt;
&lt;li&gt;需要足够的内存来处理TCP 连接，HAProxy 的开销以及系统的开销，千万不能忽视大量TCP连接带来的内存开销。&lt;/li&gt;
&lt;li&gt;网卡：intel 是更好的选择。&lt;/li&gt;
&lt;li&gt;硬盘：非必须，除非本地需要日志记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了达到最佳性能，还需要一点调整：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把网卡中断和内核绑定在core 0 上；&lt;/li&gt;
&lt;li&gt;HAProxy 绑定在通一块物理CPU 的下一个核心上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个优化很有道理，也非常必要，特别是HAProxy 如果还是工作在单进程模式下，这样能最大化压榨性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：卸载irqbalance&lt;/strong&gt;，&lt;a href="https://linux.die.net/man/1/irqbalance"&gt;irqbalance&lt;/a&gt; 是一个系统服务，可以在多个核心之间自动平衡中断。&lt;br&gt;
延伸阅读：&lt;a href="http://blog.yufeng.info/archives/2422"&gt;褚霸:《深度剖析告诉你irqbalance有用吗？》&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;避免使用VM 或其他共享资源的云服务。&lt;/p&gt;
&lt;h2&gt;Sysctl 调优&lt;/h2&gt;
&lt;p&gt;最重要的调优：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net.ipv4.ip_local_port_range = "1025 65534"&lt;/li&gt;
&lt;li&gt;net.ipv4.tcp_max_syn_backlog = 100000&lt;/li&gt;
&lt;li&gt;net.core.netdev_max_backlog = 100000&lt;/li&gt;
&lt;li&gt;net.core.somaxconn = 65534&lt;/li&gt;
&lt;li&gt;ipv4.tcp_rmem = "4096 16060 64060"&lt;/li&gt;
&lt;li&gt;ipv4.tcp_wmem = "4096 16384 262144"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调&lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt;，是因为HAProxy 需要充当中间人，开N多端口，连接前后端。调大了&lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt;，前者决定了三次握手之后，还没被HAProxy接收的TCP 连接的排队数量，超过了之后，系统不再接受新的请求，所以得调高这个值。&lt;code&gt;net.core.somaxconn&lt;/code&gt; 是系统端口的监听队列，也得增大。&lt;code&gt;ipv4.tcp_rmem&lt;/code&gt;和&lt;code&gt;ipv4.tcp_wmem&lt;/code&gt;,减小默认值和最大值，防止内存爆了，关于TCP 内存这一块，可以看陶辉的这篇文章，写的很好:&lt;a href="http://blog.csdn.net/russell_tao/article/details/18711023"&gt;《高性能网络编程7--tcp连接的内存使用》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果有长连接，把tcp_slow_start_after_idle 设置为0，即关闭，防止长连接空闲之后，系统降低拥塞窗口，提升性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcp_slow_start_after_idle=0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于iptables 的调优：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net.netfilter.nf_conntrack_max = 131072&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果配置不合理，conntrack 会影响HAProxy 达到高性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：启用iptables，及使用连接跟踪（connection tracking ），会消耗20%的CPU 资源，即使没任何规则。&lt;/strong&gt;&lt;br&gt;
如果线上启用了iptables，特别还是在一些前端流量接入的机器上，例如Nginx，LVS，Haproxy之类，要好好优化一番iptables。&lt;/p&gt;
&lt;h2&gt;HAProxy的多进程模式&lt;/h2&gt;
&lt;p&gt;配置示例（摘自幻灯片）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# **DON&amp;#39;T RUN IN PRODUCTION, THERE ARE NO TIMEOUTS**
global
  nbproc 2
  cpu-map 1 1
  cpu-map 2 2
  stats socket /var/run/haproxy/socket_web process 1
  stats socket /var/run/haproxy/socket_mysql process 2

defaults HTTP
  bind-process 1
  mode http

frontend f_web
  bind 192.168.10.1:9000
  default_backend b_web
backend b_web
  server w1 192.168.10.21:8000 check

defaults MYSQL
  bind-process 2
  mode tcp
frontend f_mysql
  bind 192.168.10.1:3306
  default_backend b_mysql
backend b_mysql
   server m1 192.168.10.11:3306 check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;好处&lt;/h3&gt;
&lt;p&gt;一个进程处理一个任务，例如一个进程用于处理HTTP请求，一个用于MySQL，互相不干扰,见上文配置。&lt;br&gt;
多进程可以绑定到多个核心上（cpu-map），扩展性也更好。另外如果HAProxy 需要进行SSL 卸载的话，多进程非常有用，可以更加充分的利用CPU 资源。&lt;/p&gt;
&lt;h3&gt;坏处&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;每个进程有自己的内存区域&lt;/strong&gt;，带来的一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启debug 模式时，多进程会退出，只启动单个进程；&lt;/li&gt;
&lt;li&gt;frontentd 和 对应的backend 必须运行在通一个进程上；&lt;/li&gt;
&lt;li&gt;和Peers 冲突；（peers 是一个在haproxy 节点之间同步server 列表的功能，具体看&lt;a href="http://www.haproxy.org/download/1.5/doc/configuration.txt"&gt;haproxy 配置peers 一节&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;存储在单个进程内存区域内的信息无法共享给其他进程&lt;ul&gt;
&lt;li&gt;stick table + tracked counters&lt;/li&gt;
&lt;li&gt;statistics（统计信息）&lt;/li&gt;
&lt;li&gt;server's maxconn (queue management)&lt;/li&gt;
&lt;li&gt;connection rate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个HAProxy 进程自行进行监控检查：&lt;/li&gt;
&lt;li&gt;每个service 需要被每个进程检查；&lt;/li&gt;
&lt;li&gt;一个service 在不同进程中，某一刻的状态可能不同；&lt;/li&gt;
&lt;li&gt;简单来说，就是后端的监控检查无法共享，导致资源浪费和状态不一致。&lt;/li&gt;
&lt;li&gt;管理一个多进程的配置更加复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Logging（日志）&lt;/h2&gt;
&lt;p&gt;Haproxy 的日志非常详细（虽然很简短），也非常重要，生产环境中如果条件允许，应该一致打开日志记录。另外日志格式可以自定义（log-format）。
另外也可以对不同的frontend 指定日志记录，将传输日志和事件日志分开，只记录error等等，具体见幻灯片。&lt;/p&gt;
&lt;h2&gt;Timeout（超时）&lt;/h2&gt;
&lt;p&gt;一些timeout解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;timeout client: 客户端不活跃的超时时间&lt;/li&gt;
&lt;li&gt;timeout connect: 和服务端建立TCP 连接的超时时间&lt;/li&gt;
&lt;li&gt;timeout server:&lt;ul&gt;
&lt;li&gt;TCP 模式：服务端不活跃的超时时间&lt;/li&gt;
&lt;li&gt;HTTP 模式：服务端处理响应内容的时间（返回504 状态码）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;timeout client-fin: 客户端处于FIN_WAIT 状态的最长时间&lt;/li&gt;
&lt;li&gt;timeout server-fin: 服务端处于FIN_WAIT 状态的最长时间&lt;/li&gt;
&lt;li&gt;HTTP 模式中最要的一些timeout：&lt;ul&gt;
&lt;li&gt;timouet http-request：客户端发送整个请求到服务端的用时（抵抗slowlowris-live 攻击）&lt;/li&gt;
&lt;li&gt;timeout http-keep-alive：http-keep-alive 时，保持连接，等待下个请求的超时时间&lt;/li&gt;
&lt;li&gt;timeout tunnel：tunnel 模式和websockets 下，连接不活跃的超时时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;timeout queue：一个连接在队列中能待的最长时间&lt;/li&gt;
&lt;li&gt;timeout tarpit：how long the tarpitted connection is maintained（暂时不太理解这个状态）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些超时配置示例，来源幻灯片：&lt;/p&gt;
&lt;p&gt;HTTP 服务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;defaults HTTP
  mode http
  timeout http-request 10s
  timeout client 20s
  timeout connect 4s
  timeout server 30s
  timeout http-keep-alive 4s
  # for websockets:
  timeout tunnel 2m
  timeout client-fin 1s
  timeout server-fin 1s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;TCP 长连接的服务，例如POP、IMAP 之类：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;defaults HTTP
  mode http
  timeout client  1m
  timeout connect 4s
  timeout server  1m
  timeout client-fin 1s
  timeout server-fin 1s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Fetch&lt;/h2&gt;
&lt;p&gt;可以用来获取请求和响应的一些数据，也就是在haproxy 配置中可以使用一些变量，这些变量代表具体请求的一些内容，然后用它们来编写规则，更多细节参看幻灯片，以及官方这个文档：&lt;a href="https://www.haproxy.com/doc/aloha/7.0/haproxy/fetching_data_samples.html"&gt;Fetching data samples&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;ACL&lt;/h2&gt;
&lt;p&gt;可以有匿名或者命名的ACL 规则，使用acl 来给规则起名字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;acl api_path path_beg -i /api/
use_backend bk_api if api_path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;匿名的规则，需要用大括号包起来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;use_backend bk_api if { path_beg -i /api/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多个ACL 规则可以共用一个名字，关系上为逻辑或，即匹配任何一条规则即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;acl myapi path_beg -i /api/
acl myapi hdr_beg(Host) -i api.
use_backend bk_api if myapi

等价馀：

acl api_path path_beg -i /api/
acl api_vhost hdr_beg(Host) -i api.
use_backend bk_api if api_path || api_vhost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;HTTP 规则&lt;/h2&gt;
&lt;p&gt;在HTTP 层，HAProxy 支持规则的定义，可以做下列事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许或禁止某些请求或响应&lt;/li&gt;
&lt;li&gt;转发流量&lt;/li&gt;
&lt;li&gt;篡改header 或者URL&lt;/li&gt;
&lt;li&gt;捕获请求内容&lt;/li&gt;
&lt;li&gt;更新ACL 规则或map 内容等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在HTTP 规则中可以使用上文提到的fetch 变量，编写复杂的规则，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;http-request deny unless { req.hdr(Host) -i www.mydomain.com }
http-request redirect location /%[req.hdr(Host)]%[path] if { path_beg -i /api/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;服务和应用保护&lt;/h2&gt;
&lt;p&gt;HAProxy 有请求队列，可以弊民后端服务被打挂，给server 配置合适的maxconn ，即可把后端服务收到的请求控制住。&lt;br&gt;
HAProxy 团队有另外一份幻灯片，提供了更多HAProxy防DDoS的经验分享：&lt;a href="http://www.slideshare.net/haproxytech/presentation-packetshield-solution-de-protection-contre-les-ddos-rseau"&gt;《Presentation packetshield, solution de protection contre les DDoS réseau》&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;另外可以对不同性能的后端，设置不同的maxconn，转发不同的请求，分流压力：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;frontend f_myapp
  use_backend b_light if { path_beg /api/ /foo/ /bar/ }
  use_backend b_heavy if { path_beg /search /massivefoo /heavybar }
backend b_light
  server s1 server1:80 maxconn 300
backend b_heavy
  server s1 server1:80 maxconn 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;统计页面&lt;/h2&gt;
&lt;p&gt;HAProxy 内部会维护很多计数器，用做统计与展示。统计页面可以配置成一个web 页面，也可以是输出CSV格式的UNIX 的套接字（UNIX socket）。配置示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;listen stats
  bind-process 1
  bind :9010
  stats enable
  stats uri /
  stats auth demo:demo
  stats realm Demo
  stats admin if TRUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果开了多进程（nbproc &amp;gt; 1），我们上文提到的，HAProxy 进程直接的内存内容是不共享的，所以维护者各自的统计计数器，所以需要为每个进程创建一个状态页面或者UNIX socket。&lt;br&gt;
最后提供一个用于Falcon Agent 的HAProxy监控采集脚本：&lt;a href="https://gist.github.com/fangpsh/a0522b4d5657b42ebf14"&gt;30_haproxy_stats.sh&lt;/a&gt;。&lt;/p&gt;</content><category term="2016"></category><category term="haproxy"></category></entry><entry><title>高流量负载下Nginx 调优</title><link href="https://fangpsh.github.io/posts/2016/2016-11-24.html" rel="alternate"></link><published>2016-11-24T14:00:00+08:00</published><updated>2016-11-24T14:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-24:/posts/2016/2016-11-24.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址: &lt;a href="https://blog.martinfjordvald.com/2011/04/optimizing-nginx-for-high-traffic-loads/"&gt;Martin Fjordvald&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;已获得原文作者翻译许可，本文遵循原文许可协议&lt;/li&gt;
&lt;li&gt;原文发表时间：April 27，2011&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我曾经讨论过一些Nginx 最常见的问 …&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;原文地址: &lt;a href="https://blog.martinfjordvald.com/2011/04/optimizing-nginx-for-high-traffic-loads/"&gt;Martin Fjordvald&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;已获得原文作者翻译许可，本文遵循原文许可协议&lt;/li&gt;
&lt;li&gt;原文发表时间：April 27，2011&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我曾经讨论过一些Nginx 最常见的问题，毫无疑问，其中一个问题就是关于如何优化nginx 获得高性能。不必惊讶，因为大多数nginx 新用户都是从Apache 迁移过来，所以他们习惯于调整配置和使用巫术来尽可能让服务器达到最佳性能。&lt;/p&gt;
&lt;p&gt;恩，我得告诉你一些坏消息，你并不能&lt;em&gt;真的&lt;/em&gt;显着优化nginx。没有什么配置能让你的负载降低一半，或让PHP 运行速度快2 倍。谢天谢地，好消息是nginx 不需要任何调优，因为直接使用它时就已经被优化过了。最大的优化发生在当你决定运行通过ape-get install ，yum install 或 make install 安装的nginx。（请注意这些仓库内容常常过期。&lt;a href="https://nginx.org/en/docs/install.html"&gt;Wiki 的安装页面&lt;/a&gt;上通常有最新的仓库。）  &lt;/p&gt;
&lt;p&gt;也就是说，有很多选项会影响nginx 的行为，但是这些选项的默认值并不全都为高流量的情况优化过。另外我们也需要考虑nginx 运行的平台，优化我们的操作系统，因为它们某些地方也会有瓶颈。&lt;/p&gt;
&lt;p&gt;总之，我们没法优化单个连接的加载时间，但是可以确保nginx 处理高流量的情况时有优化过的理想的环境。当然，我所说的高流量是指每秒几百个请求，绝大多数人不需要为这种情况费心思，不过如果你有兴趣或者准备处理这种情况，请继续往下读吧。&lt;/p&gt;
&lt;p&gt;首先我们需要考虑要使用的平台，因为nginx 可以运行在Linux，MacOS，FreeBSD，Solaris，Windows 以及其他专业的系统。他们都实现了高性能的基于事件的轮询方法，可惜的是，nginx 只支持了其中4个。我倾向于喜欢4个中的FreeBSD，但是没什么大的区别，相对于选择最优的系统，选择你最熟悉的系统更加重要。 &lt;/p&gt;
&lt;p&gt;如果你没有猜到，那个不同的系统就是Windows。真的没有任何理由把运行在Windows 上的Nginx 投入生产环境使用。Windows 采用一个不同的处理事件轮询的方法，nginx 的作者选择不支持它。它默认采用低性能的select()，结果性能非常糟糕。  &lt;/p&gt;
&lt;p&gt;大多数人遇到的第二个最大的瓶颈也与你的操作系统有关。打开一个shell，su 到运行nginx 的用户，然后运行这个命令:&lt;code&gt;ulimit -a&lt;/code&gt;。这些数值都是nginx 运行时的瓶颈。大多数系统下的打开文件数默认被限制得很小，我现在检查的这个系统它的值设置为1024。如果nginx运行在这种情况下，当它达到限制的时会记录错误日志（24: Too many open files）和返回一个错误给客户端。nginx 当然可以处理大大超过1024 个文件描述符，你的操作系统同样也可以。所以你可以放心的提高这个值。  &lt;/p&gt;
&lt;p&gt;为此，你可以通过ulimit 设置这个限制，也可以使用&lt;a href="https://nginx.org/en/docs/ngx_core_module.html#worker_rlimit_nofile"&gt;worker rlimit nofile&lt;/a&gt; 来定义你需要的打开文件描述符的限制。（这需要以root 启动nginx，在它dropping  privileges 之前）（译注：nginx 以root 启动之后，会再启动多个worker 进程，worker 进程工作在你配置中&lt;a href="https://nginx.org/en/docs/ngx_core_module.html#user"&gt;user&lt;/a&gt; 指定的普通用户，实现参考&lt;a href="https://github.com/nginx/nginx/blob/b072a6957c97ca7c33a64b1a34f7b66c6e209acf/src/os/unix/ngx_process_cycle.c#L831_L850"&gt;nginx_src/os/unix/ngx_process_cycle.c&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;Nginx 瓶颈&lt;/h2&gt;
&lt;p&gt;关注了OS 的瓶颈之后，是时候深入nginx 自身，看看一些我们可以调整的指标和方法。  &lt;/p&gt;
&lt;h3&gt;Worker 进程&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nginx.org/en/docs/ngx_core_module.html#worker_processes"&gt;worker 进程&lt;/a&gt; 是nginx 的基础，一旦master 进程绑定了指定的IP/端口，它就会根据复制出指定用户的worker 进程，然后它们会处理所有任务。Worker 不是多线程的，所以它们不能在CPU之间分摊每个连接。所以这让运行多个worker 进程有意义，通常一个CPU 核心配一个worker。2-4 个worker 可以应付大多数负载情况，因为在CPU 成为问题之前，nginx 会遇到其他瓶颈，通常情况下你的进程只会处于空闲状态。如果你的nginx 实例在设置4 个worker 之后是CPU Bound（译注：只占用大量CPU资源，相对应的有I/O Bound），希望不需要我告诉你需要怎么做。（译注：作者意指升级CPU 配置即可。）  &lt;/p&gt;
&lt;p&gt;当你在处理有很多阻塞的磁盘IO 的情况时，可以创建更多worker 进程。你需要测试特定的配置下加载静态文件的等待时间，如果这个时间很大的话，尝试增加worker 进程。&lt;/p&gt;
&lt;h3&gt;Worker 连接数&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nginx.org/en/docs/ngx_core_module.html#worker_connections"&gt;Worker 连接数&lt;/a&gt;能有效地限制任一worker 在某一刻可以处理的连接数。这个选项极有可能是设计用来防止失控的进程，万一你的系统配置成允许处理超出硬件能力的负载。正如nginx 开发者Valentine 在&lt;a href="http://mailman.nginx.org/pipermail/nginx/2015-May/047460.html"&gt;邮件列表&lt;/a&gt;中指出，如果达到worker_connections 的限制，nginx 可以关闭keep-alive 连接，所以在这里我们不需要担心keep-alive 值。相反，我们应该关心nginx 可以处理的当前活跃连接的总数。我们可以处理的最大连接数公式如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;worker_processes * worker_connections * (K / average $request_time)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中K 是当前活跃的连接总数。另外，对于K值，我们也需要考虑反向代理，它会多打开一个到你后端服务的连接。  &lt;/p&gt;
&lt;p&gt;在默认的配置文件中&lt;code&gt;worker_connections&lt;/code&gt;  是设置为1024，如果我们考虑浏览器通常会打开2个连接来进行站点资源的管道传输，那么导致我们最多能同时处理512个用户。使用反向代理的情况下，同时能处理的用户数会更低，即使你的后端服务能够尽可能快的响应来释放连接。  &lt;/p&gt;
&lt;p&gt;所有关于worker 连接数的事情应该都搞清楚了，如果你的流量在增长，你最终都需要增加每个worker 的总连接数。2048 对于大多数人来说都适用了，说实话，如果你有这种量级的流量，你应该已经很清楚的知道这个指标得设多高。&lt;/p&gt;
&lt;h3&gt;CPU 亲缘性&lt;/h3&gt;
&lt;p&gt;设置CPU 亲缘性实际上是告诉每个worker 使用哪个CPU 核心，并且他们只会使用那个核心。我不想说太多涉及这部分的内容，除了说明你做这个时候必须&lt;strong&gt;非常&lt;/strong&gt;小心。你操作系统的CPU调度器极有可能比你更擅长处理负载均衡。如果你认为你在CPU 负载方面遇到了问题，想在调度器级别做优化，有可能找到一个可替代的调度器。除非你清晰的知道你在做什么，不然别碰这个。&lt;/p&gt;
&lt;h3&gt;Keep Alive&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_timeout"&gt;Keep alive&lt;/a&gt; 是HTTP 的一个特性，它允许用户客户端和你的服务器保持连接来发送若干请求，直到达到设定的超时时间。实际上这个指标不会大大改善我们的nginx，因为nginx 自身也能处理大量的空闲连接。nginx 的作者声称nginx 处理10,000 个空闲连接只会使用2.5MB内存，在我看来确实如此。&lt;/p&gt;
&lt;p&gt;我在性能指南中设计这点的理由非常简单。Keep alive 能大大改善终端用户感受到的加载时间。这是你能优化的最重要的指标，因为如果你的网站对用户来说加载很快，他们会很开心。Amazon 和其他大型在线零售商研究表明，感官上的加载时间和销量存在直接的关系。&lt;/p&gt;
&lt;p&gt;这可能有一点奇怪，为什么保持持久的连接影响这么大，即你要避免创建所有HTTP 连接，这样影响很大。你可能不需要keep alived 超时时间为65，但是还是很推荐设置为10~20 ，正如前面说的，nginx 处理空闲的请求非常轻松。&lt;/p&gt;
&lt;h3&gt;tcp_nodelay 和 tcp_nopush&lt;/h3&gt;
&lt;p&gt;这两个指标可能是最难理解的，它们在非常底层的网络方面影响着nginx。最简短和浅显的解释是，这些指标决定操作系统如何处理网络缓存和何时刷新缓存传给终端用户。我只能建议你，如果不了解就别乱动。它们不会显着的改善或者改变任何什么，所以最好是让它们保持默认值。&lt;/p&gt;
&lt;h2&gt;硬件瓶颈&lt;/h2&gt;
&lt;p&gt;目前为止我们已经处理了所有源于nginx 可能的瓶颈，是时候弄明白如何最大限度的榨干我们的服务器了。要做到这个我们着眼馀硬件层面，因为这是最有可能找到瓶颈的地方。&lt;/p&gt;
&lt;p&gt;服务器主要三个方面有潜在的瓶颈。CPU，内存和IO层面。nginx 对于CPU使用非常高效，所以我可以直接了当的告诉你，这方面不会成为你的瓶颈。同样地，nginx 在内存使用方面也非常高效，所以也不太可能成为瓶颈。剩馀的IO 是我们服务器瓶颈的罪魁祸首。&lt;/p&gt;
&lt;p&gt;如果你曾经处理过服务器，那么你对这块可能非常熟悉。磁盘驱动器&lt;strong&gt;非常，非常慢&lt;/strong&gt;。从磁盘驱动器中读取内容可能是你在服务器中成本最高的操作了，所以，自然为了避免IO 瓶颈，我们需要减少nginx 对磁盘的读写。&lt;/p&gt;
&lt;p&gt;要做到这个，我们可以更改nginx 的行为，尽可能减少写磁盘，以及确保nginx 的内存限制，来避免对磁盘的访问。&lt;/p&gt;
&lt;h3&gt;访问日志&lt;/h3&gt;
&lt;p&gt;默认情况下，为了日志记录，nginx会往磁盘上的一个文件写入每条请求的记录，你可以依靠它来进行统计分析，安全检查等，但是这会带来很大的IO 开销。所以如果你不需要任何访问日志，你可以直接关闭日志记录，避免写磁盘。然而，如果你需要访问日志，那么考虑把日志保存到内存吧（译注：使用RAM Disk）。这会比写入磁盘快很多，而且可以显着降低IO 开销。（译注：还可以采用memory buffer，以及ratio 之类的参数来优化nginx写日志。）  &lt;/p&gt;
&lt;p&gt;如果你只是使用访问日志来做统计分析，那么可以考虑使用类似Google Analytics 来代替，或只记录请求中的一部分即可。&lt;/p&gt;
&lt;h3&gt;错误日志&lt;/h3&gt;
&lt;p&gt;我内心也在犹豫我是否应该包含这个指标，因为你真的不想要禁用错误日志记录，特别是考虑到实际上错误日志占的存储空间很少。也就是说，关于这个指标有困惑的地方，错误日志等级的参数是你可以指定的，如果设置的太低，它会记录404 错误和其他可能的debug 信息。在生产环境中设置为warn 等级就够了，并且能保持较低的IO。&lt;/p&gt;
&lt;h3&gt;Open File Cache&lt;/h3&gt;
&lt;p&gt;文件系统中的一个读请求包含打开和关闭文件，考虑到这是一个阻塞的操作，这是一个不能忽略的方面。所以，对我们来说缓存打开文件描述符非常有益，这就是&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#open_file_cache"&gt;open file cache&lt;/a&gt;的作用。链接的wiki 对于如何启用和配置有非常详细说明，我建议你读一读。&lt;/p&gt;
&lt;h3&gt;Buffers&lt;/h3&gt;
&lt;p&gt;你需要调优的最重要的一件事是你允许nginx 使用的buffer 大小。如果buffer 设置的太小，nginx 将不得不存储上游(upstreams)的响应到一个临时文件中，这会导致IO 读写增加。流量越大问题越严重。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size"&gt;client_body_buffer_size&lt;/a&gt; 指令用来处理客户端&lt;strong&gt;请求&lt;/strong&gt;的buffer 大小，也就是外部进入的请求体。它被用来处理POST 数据，也就是一些表单提交，文件上传之类的。如果你要处理很多大容量的POST 数据提交，你需要确保这个buffer 足够大。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffer_size"&gt;fastcgi_buffers&lt;/a&gt; 和&lt;a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffering"&gt;proxy_buffers&lt;/a&gt; 指令用来处理你上游服务器的响应，也就是PHP，Apache 或者其他。意思和上文差不多，如果这些buffer 不够大，数据在返回给用户之前会被缓存到磁盘中。注意，在同步传输数据给客户端之前，nginx 能缓存的大小有一个上限，即使是在磁盘上。这个限制是由&lt;code&gt;fastcgi_max_temp_file_size&lt;/code&gt; 和&lt;code&gt;proxy_max_temp_file_size&lt;/code&gt; 指定的。另外你也可以关闭代理连接的缓存，即把&lt;code&gt;proxy_buffering&lt;/code&gt; 设置为&lt;code&gt;off&lt;/code&gt;。（通常不是一个好主意！）&lt;/p&gt;
&lt;h3&gt;彻底去除磁盘IO&lt;/h3&gt;
&lt;p&gt;去除磁盘IO 最好的方法自然是不用磁盘，如果你只有少量数据，你可以把它们都放入内存，然后完全摆脱磁盘IO 的限制。你的操作系统默认会缓存频繁访问过的磁盘扇区，所以你有越多的内存，IO 就越少。也就是说你可以通过买更多的内存来突破这个限制。当然，你的数据越多，需要的内存越大。&lt;/p&gt;
&lt;h3&gt;Network IO&lt;/h3&gt;
&lt;p&gt;为了好玩，我们假设你有足够的内存来缓存你所有的数据，这意味着理论上你读的IO 速度能达到3-6gbps。然而，你并且没有这么快的网络通道。很遗憾，对于我们传输数据需要的网络带宽，能够优化的有限。唯一有用的优化方式就是减少传输的数据，或者压缩数据。&lt;/p&gt;
&lt;p&gt;感谢nginx 有一个&lt;a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip"&gt;gzip 模块&lt;/a&gt;，它可以让我们在传给用户之前压缩数据，这可以显着的降低数据大小。通常来说&lt;code&gt;gzip_comp_level&lt;/code&gt;设置为4~5 就足够了。没有必要进一步增加压缩等级，那样只会消耗CPU 时间。&lt;/p&gt;
&lt;p&gt;你也可以使用各种javascript 和css 压缩器来压缩数据。这些和nginx 无关，我相信你通过Google 可以找到更多信息。&lt;/p&gt;
&lt;h2&gt;Phew&lt;/h2&gt;
&lt;p&gt;到此，这个主题就结束了。如果你还要更多的优化，是时候考虑增加额外的服务器来扩大你的服务规模，而不是把时间浪费在进一步优化nginx 上，这是另外一个话题，我已经研究了一段时间。如果你对这篇文章只有2400 个字感到奇怪，那么请休息一下，进一步探索我的博客吧！&lt;/p&gt;</content><category term="2016"></category><category term="nginx"></category></entry><entry><title>关闭HPKP 和HSTS的方法</title><link href="https://fangpsh.github.io/posts/2016/2016-11-23.html" rel="alternate"></link><published>2016-11-23T11:11:30+08:00</published><updated>2016-11-23T11:11:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-23:/posts/2016/2016-11-23.html</id><summary type="html">&lt;p&gt;大家对于HSTS 一般都比较熟悉了，对HPKP 可能比较陌生,简单来说由于CA 的工作模式,导致别人有可能通过其他CA 签发你网站 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;大家对于HSTS 一般都比较熟悉了，对HPKP 可能比较陌生,简单来说由于CA 的工作模式,导致别人有可能通过其他CA 签发你网站的证书,这个时候你就需要有一条头信息声明你网站的证书的指纹是什么。&lt;br&gt;
关于HSTS 和HPKP 的介绍可以查看Jerry Qu 的这2篇文章:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://imququ.com/post/sth-about-switch-to-https.html"&gt;关于启用 HTTPS 的一些经验分享（一）&lt;/a&gt;:合理使用 HSTS&lt;/li&gt;
&lt;li&gt;&lt;a href="https://imququ.com/post/http-public-key-pinning.html"&gt;HTTP Public Key Pinning 介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HSTS 和HPKP 都是通过头信息传递给浏览器，浏览器都会根据max-age 缓存起来，所以在添加了HSTS 和HPKP 了之后，想要回滚，就没有在服务端回滚程序那么方便了。&lt;/p&gt;
&lt;p&gt;有以下几种情况会遇到要关闭/移除：&lt;/p&gt;
&lt;p&gt;HSTS: 运维同学在刚刚做HTTPS 的时候，开启了HSTS，甚至加了includeSubDomains，某些老客户端访问HTTP的接口的时候跳到HTTS，由于SNI、加密套件兼容性等问题出现故障;&lt;/p&gt;
&lt;p&gt;HPKP: 无论是用根证书、中间证书还是站点证书签发了指纹，虽然HPKP有备份方案，即发送多个pin-sha，但是还是需要准备证书出现故障，要关闭HPKP。另外要记得添加report-uri，这样出错时，服务端能主动的发现上报的信息。&lt;/p&gt;
&lt;p&gt;个人觉得HPKP 和HSTS 在设计上实在太像了，如下例子：&lt;/p&gt;
&lt;p&gt;HSTS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Strict-Transport-Security: max-age=31536000; includeSubDomains
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HPKP:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Public-Key-Pins:
      pin-sha256=&amp;quot;d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=&amp;quot;;
      pin-sha256=&amp;quot;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&amp;quot;;
      pin-sha256=&amp;quot;LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=&amp;quot;;
      max-age=10000; includeSubDomains
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以在关闭，或者说移除HSTS或HPKP的方式上也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即max-age 字段指定为0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看下RFC：&lt;/p&gt;
&lt;p&gt;HTST(&lt;a href="https://tools.ietf.org/html/rfc6797#section-8.1"&gt;RFC6797&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;The max-age value is essentially a &amp;quot;time to live&amp;quot; value relative
to the reception time of the STS header field.

If the max-age header field value token has a value of zero, the
UA MUST remove its cached HSTS Policy information (including the
includeSubDomains directive, if asserted) if the HSTS Host is
known, or the UA MUST NOT note this HSTS Host if it is not yet
known.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HPKP(&lt;a href="https://tools.ietf.org/html/rfc7469#section-2.3.1"&gt;RFC7469&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;The max-age value is essentially a &amp;quot;time to live&amp;quot; value relative to
the time of the most recent observation of the PKP header field.  If
the max-age header field value token has a value of 0, the UA MUST
remove its cached Pinning Policy information (including the
includeSubDomains directive, if asserted) if the Pinned Host is
Known, or, MUST NOT note this Pinned Host if it is not yet Known.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;果然很像。。。居然照抄。&lt;br&gt;
另外includeSubdomains 两者的定义也是一样的。&lt;/p&gt;</content><category term="2016"></category><category term="https"></category></entry><entry><title>改进一下Ping</title><link href="https://fangpsh.github.io/posts/2016/2016-11-20.html" rel="alternate"></link><published>2016-11-20T20:18:30+08:00</published><updated>2016-11-20T20:18:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-20:/posts/2016/2016-11-20.html</id><summary type="html">&lt;p&gt;Ping 是一个非常常用的命令，有2种情况会使用它：&lt;br&gt;
一是会从浏览器的地址栏或者其他人发给我的网址，复制，然后进行ping，带着协议以及一堆 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ping 是一个非常常用的命令，有2种情况会使用它：&lt;br&gt;
一是会从浏览器的地址栏或者其他人发给我的网址，复制，然后进行ping，带着协议以及一堆uri和args，&lt;br&gt;
例如: &lt;code&gt;https://accounts.google.com/AddSession?hl=en...&lt;/code&gt;；&lt;br&gt;
二从Linux 系统的网络地址复制过来IP，进行Ping，带着掩码位数，&lt;br&gt;
例如：&lt;code&gt;192.168.1.1/32&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;以上2种情况，如果直接复制内容到终端，然后ping，会提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ping: cannot resolve ....: Unknown host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很恼人，写一个简单的脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class="c1"&gt;# issue:&lt;/span&gt;
&lt;span class="c1"&gt;#  - http(s)://xxx.xx/xxx/xx?xxx&lt;/span&gt;
&lt;span class="c1"&gt;#  - 192.168.1.1/32&lt;/span&gt;

&lt;span class="nv"&gt;new_args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;sed&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s/http.*\:\/\///&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s/\/[^ ]*//&amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="c1"&gt;#echo ${new_args}&lt;/span&gt;
ping&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;new_args&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把这个脚本命名为pin, 放到 &lt;code&gt;/bin&lt;/code&gt; 之类的目录下面即可（本来想做成alias，没成功），最终效果如下：&lt;br&gt;
&lt;img alt="pin" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145701.jpg"&gt;&lt;/p&gt;</content><category term="2016"></category><category term="shell"></category></entry><entry><title>写一个Pelican 插件：Read More Link</title><link href="https://fangpsh.github.io/posts/2016/2016-11-15.html" rel="alternate"></link><published>2016-11-15T22:00:30+08:00</published><updated>2016-11-15T22:00:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-15:/posts/2016/2016-11-15.html</id><summary type="html">&lt;p&gt;&lt;img alt="another_read_more_link_demo" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165914.png"&gt;&lt;/p&gt;
&lt;p&gt;之前用&lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 搭建博客的时候，用过一个很酷的功能，在文章中插入&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;之后，首页的文章列表只会显示这个标记之前的内容，然 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="another_read_more_link_demo" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301165914.png"&gt;&lt;/p&gt;
&lt;p&gt;之前用&lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 搭建博客的时候，用过一个很酷的功能，在文章中插入&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;之后，首页的文章列表只会显示这个标记之前的内容，然后添加一个类似继续阅读的链接。后来有一段时间切到Wordpress，也有类似的功能，但是在Pelican 上没见到。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Inserting a &amp;lt;!-- more --&amp;gt; comment into your post will prevent the post content
below this mark from being displayed on the index page for the blog posts,
a &amp;quot;Continue →&amp;quot; button links to the full post.  
-- http://octopress.org/docs/blogging/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在&lt;a href="https://github.com/getpelican/pelican-plugins"&gt;Pelica Plugins 列表&lt;/a&gt;里翻了下:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/summary"&gt;summary&lt;/a&gt;，需要添加添加首位2个标记（看了下源代码，只添加&lt;code&gt;&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;&lt;/code&gt; 也可以，就会从头开始算），不过也不能添加继续阅读的链接；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/read_more_link"&gt;read_more_link&lt;/a&gt;，不过这个插件是指定SUMMARY_MAX_LENGTH,也不符合需求。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以觉得不如自己写一个，看了下官方教程&lt;a href="http://docs.getpelican.com/en/3.6.3/plugins.html#how-to-create-plugins"&gt;How to create plugins&lt;/a&gt; 和 read_more_link 这个插件的源代码，就能实现了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;#注册函数，当Pelican 发送all_generators_finalized 信号时候，调用插件&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;register&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;signals&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all_generators_finalized&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run_plugin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;AttributeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;signals&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;content_object_init&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_read_more_link&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Pelican 在首页其实显示的一篇文章的summary，即我们只需要检测文章中是否出现了&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;，如果出现了，就改写文章的summary，再加上继续阅读的链接即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;#对生成的文章对象:article 循环处理&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run_plugin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generators&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;generators&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ArticlesGenerator&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;articles&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;insert_read_more_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;insert_read_more_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="n"&gt;略&lt;/span&gt;

&lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_content&lt;/span&gt;

&lt;span class="n"&gt;marker_location&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;!-- more --&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;marker_location&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;#如果找不到注释标记，先判断文章是否存在summary，如果没有的话，就将summary 设置为全文，然后退出插件&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_summary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_summary&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_content&lt;/span&gt;
        &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;#按照检索到注释标记的位置，截取文章内容作为summary&lt;/span&gt;
    &lt;span class="n"&gt;summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;marker_location&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ANOTHER_READ_MORE_LINK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;read_more_link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;ANOTHER_READ_MORE_LINK_FORMAT&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ANOTHER_READ_MORE_LINK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;summary&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;read_more_link&lt;/span&gt;

&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;summary&lt;/span&gt;
&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_summary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下载插件后，在pelicanconf.py 中配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;PLUGIN_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/home/xxx/blog/xxx/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;other_plugin&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;another_read_more_link&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ANOTHER_READ_MORE_LINK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Continue -&amp;gt;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认添加的链接带有一个&lt;code&gt;another-read-more-link&lt;/code&gt;属性，用来自定义喜欢的样式： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;a class=&amp;quot;another-read-more-link&amp;quot; href=&amp;quot;/{url}&amp;quot; &amp;gt;{text}&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.another-read-more-link {
    background: #eee;
    display: inline-block;
    padding: .4em .4em;
    margin-right: .5em;
    text-decoration: none;
    color: #737373;
    transition: background-color 0.5s;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果见上文图片。&lt;/p&gt;
&lt;p&gt;插件源码：&lt;a href="https://github.com/fangpsh/another_read_more_link"&gt;another_read_more_link&lt;/a&gt; ， &lt;br&gt;
因为新手上路，源码上参考read_more_link，外加功能也类似，所以起了这么一个名字 :P&lt;/p&gt;</content><category term="2016"></category><category term="pelican"></category></entry><entry><title>《软技能-代码之外的生存指南》读书笔记</title><link href="https://fangpsh.github.io/posts/2016/2016-11-08.html" rel="alternate"></link><published>2016-11-08T11:51:30+08:00</published><updated>2016-11-08T11:51:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-08:/posts/2016/2016-11-08.html</id><summary type="html">&lt;p&gt;&lt;img alt="soft_skills.jpg" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171643.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26835090/"&gt;《软技能-代码之外的生产指南》&lt;/a&gt;这本书出来的时候，在Twitter 上收到很大的关注。之前个人对这类书籍是有点不屑的，有点成功学 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="soft_skills.jpg" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171643.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26835090/"&gt;《软技能-代码之外的生产指南》&lt;/a&gt;这本书出来的时候，在Twitter 上收到很大的关注。之前个人对这类书籍是有点不屑的，有点成功学的味道。我之前也是不喜欢做职业规划的，只是希望按照个人的兴趣选择发展。不过毕业一年多，日复一日的上班，让我考虑，得计划一下自己的人生，整理一下了。&lt;/p&gt;
&lt;h2&gt;职业&lt;/h2&gt;
&lt;h3&gt;职业规划和制定目标&lt;/h3&gt;
&lt;p&gt;第2章有一句话：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“其实你和中世纪小镇上开铁匠铺的铁匠没什么区别。”  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者在这里是为了教导我们程序员“把自己当作一个企业去思考”，不要产生是“为某家公司打工”的心态。然后按照这个思路进行思考，改变工作态度、工作计划等等。
顺着这个思路，就会发现程序员现在某些岗位的高薪，其实也就是供需决定的。不少程序员觉得自己很“牛逼”，所以毕业就能拿着高薪。应该要认识到市场会变化，程序员的人数多起来，技术红利就要消散了。&lt;br&gt;
为了在将来有更好的竞争力，作为一个人的公司，我们就应该提升自己的服务水准，和其他同类程序员相比更加出色。虽然这样说，但是我还是喜欢出发点是觉得技术有趣。&lt;strong&gt;作者在书中建议我们提升服务的同时，专注于提供某一特定类型的客户或者服务，成为专家。&lt;/strong&gt;&lt;br&gt;
每年校招季节，常常在&lt;a href="https://v2ex.com"&gt;v2ex&lt;/a&gt; 上看到应届生发帖询问Offer 的选择。Offer 之间有薪酬、岗位、地点等等的差别，其实如果设定自己的目标，有了目标之后，作选择的时候会更加容易吧。&lt;br&gt;
作者在设定目标这件事情上，建议设定目标之后，设定路线，达到若干个小目标，逐渐向大目标前进，并“定期核定自己的目标”，调整计划和方向。  &lt;/p&gt;
&lt;h3&gt;人际交往&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;“别管我，我只想一个人安静地写代码！”
我也曾经这样想，很多程序员都喜欢这样做，自己一个人戴着耳机，安静的写代码，是我们最喜欢做的事情。不过，按照前文的思路，我们是在提供服务，我们需要了解需求，需要和其他人合作，所以人际交往是不可避免的，但是程序员很多时候人际交往能力相比其他岗位的人差一些，我们想更多的时候，是我们更喜欢“安静地写代码”，并不是我们其他的性格缺陷。心态上稍微做些改变，工作会更加顺利。&lt;br&gt;
作者列了以下几个与人打交道的要点，（我不喜欢把他们称为技巧，感觉很虚伪）：  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;“每个人都希望感到自己很重要”&lt;ul&gt;
&lt;li&gt;注意尊重他人，不贬低他人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“永远不要批评”，“用表扬代替批评”&lt;/li&gt;
&lt;li&gt;“换位思考”，“从对方心态出发提出建议”，站在对方的位置和职位上思考问题，不要总觉得产品经理是傻逼XD&lt;/li&gt;
&lt;li&gt;“避免争吵”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这样说，但是如果遇到实在无法相处的人，“苛性碱”的人，不要白费功夫，惹不起就躲吧。&lt;br&gt;
另外作者多次推荐了卡耐基的&lt;a href="https://book.douban.com/subject/1837006/"&gt;《人性的弱点》&lt;/a&gt;。  &lt;/p&gt;
&lt;h3&gt;面试之道&lt;/h3&gt;
&lt;p&gt;作者的思路即在面试之前接触到面试官，例如通过在目标公司的职员的博客下留言交流，或者面试的时候套好感，这招在我看来总觉得有点下作，不过国外的人似乎并不介意，例如国内学生申请海外研究生都喜欢事先和教授套磁，好像还必不可少。&lt;br&gt;
还有作者强调了“内推”的重要性。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统求职方法&lt;ul&gt;
&lt;li&gt;发出一堆简历-&amp;gt; 获得面试机会-&amp;gt; 面试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改进的求职方法&lt;ul&gt;
&lt;li&gt;从期待加入的公司里找到联系人 -&amp;gt; 与该联系人建立紧密关系 -&amp;gt; 获得个人推荐 -&amp;gt; 推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我也觉得内推是很有效的，之前求职也会找师兄朋友内推，不过总之，少一点套路，多一点真诚吧。  &lt;/p&gt;
&lt;p&gt;另外从企业的角度出发，面试的时候“要集中精力证明自己就是无需监督也能自动自发的做好事情的员工”，当然也要证明“在技术上确实胜任工作”，“非常能干，不会被困难阻挡”，希望都能说道做到吧，毕竟技巧都是其次的，实力才是关键。  &lt;/p&gt;
&lt;h3&gt;就业选择&lt;/h3&gt;
&lt;p&gt;作者罗列了作为雇员、独立咨询师和创业者的好处和弊端，还是建议在作出具有风险的选择的时候，有事先的准备。&lt;/p&gt;
&lt;h3&gt;成为细分领域的专家&lt;/h3&gt;
&lt;p&gt;专业化不妨碍技术全面，只是应该先注重深度。不过我个人认为，当选择专业化的方向的时候，除了考虑自己的兴趣，也应该考虑市场需求和以后的发展。  &lt;/p&gt;
&lt;h3&gt;公司选择与晋升&lt;/h3&gt;
&lt;p&gt;“选择小公司或初创公司工作的一个更好的理由是，你喜欢那种快节奏的、令人兴奋的工作环境，也希望构建伟大的产品并见证它的成长”，如果是为期权股票选择小公司，风险太高。&lt;br&gt;
中等规模的公司会更稳定，但是也更加死板，死板会提现在各个方案，例如技术选型、内部流程上等等。大公司的话，则更加注重规范和流程，也会注重创新，但是办公室政治严重。&lt;br&gt;
另外作者提到&lt;strong&gt;程序员最好去以软件开发业务为主的公司，而不是把软件开发作为内部系统或者边缘部门的公司。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于晋升，作者提到两点，“承当更多责任”和“引人注目”，感觉略心机。。。可是现实就是这样。还有就是自学，不断学习提升自身技能水平。&lt;br&gt;
虽然有这么多技巧，最重要是注重自身、提升能力、展现自己，而不是花时间玩弄办公室政治，要洁身自好。&lt;/p&gt;
&lt;h3&gt;专业人士&lt;/h3&gt;
&lt;p&gt;“成为专业人士的全部在于：引入注目，克尽职守，以及不屈服于挫折。”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵守自己的原则&lt;/li&gt;
&lt;li&gt;专注于正确完成工作&lt;/li&gt;
&lt;li&gt;不惧怕承认自己错了，不会文过饰非&lt;/li&gt;
&lt;li&gt;持续稳定，追求品质，高标准&lt;/li&gt;
&lt;li&gt;勇于承担责任&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;自由职业相关&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;“不要贸然辞职，踏上创业之路。”&lt;/strong&gt;&lt;br&gt;
作者介绍了如何做准备，最好计划再辞职，不要贸然行动。以及如何推销自己（邮件、博客、免费的演讲等）和收费定价（总的来说，就是尽量提高，如果对方能接受）。另外找到受众需求再开发产品，而不是反过来。  &lt;/p&gt;
&lt;h3&gt;“假装自己能成功”&lt;/h3&gt;
&lt;p&gt;“不要将这与撒谎混为一谈。我不是建议你向未来的雇主展示自己不具备的技能，声称自己具备尚不具备的能力。相反，我建议你坦率、诚实的面对自己的能力或不足，同事保持“我以前已经克服过那些困难”的心态和姿态，因为你清楚地知道，唯一横亘在“现在的你”和“未来的你”之间的是时间”，总之，就是要自信。&lt;/p&gt;
&lt;h3&gt;简历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设计简历，作者建议请专业的人代写简历&lt;/li&gt;
&lt;li&gt;准备在线的简历，方便分发&lt;/li&gt;
&lt;li&gt;简历绝对不要出现错别字&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;请勿陷入对技术的狂热之中&lt;/h3&gt;
&lt;p&gt;选择Emacs 还是Vim 都好，有激情、热情和狂热是不一样的，后者只会让人变的狭隘，“另一方面，如果你愿意对技术保持开放的心态，而不是固守自己已经了解的技术，声称它是最好的，你会发现有更多的机会为你敞开大门。”&lt;/p&gt;
&lt;h2&gt;自我营销&lt;/h2&gt;
&lt;h3&gt;写博客&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;“需要持之以恒”&lt;/strong&gt;&lt;br&gt;
“自我营销的基本机制是，要想让人们追随、倾听你，你就要带给他们价值：你能为他们的问题提供答案，设置是给他们带去快乐。”&lt;br&gt;
不过我个人写博客，首先还是为了自我积累，自己的学习总结，然后如果这些内容能给别人带来方便，那是最好不过的了。&lt;/p&gt;
&lt;h3&gt;主要目标：为他人增加价值&lt;/h3&gt;
&lt;h3&gt;把工作成果的90% 都做成免费的&lt;/h3&gt;
&lt;h3&gt;演讲&lt;/h3&gt;
&lt;p&gt;演讲和做分享确实能让人出名，不过国内各种大会上的分析者这个目的太明显了，由于目的不纯，分享的内容也就不吸引人，或者水分略大。&lt;/p&gt;
&lt;h3&gt;做培训、写书&lt;/h3&gt;
&lt;p&gt;这一章，某些地方觉得作者嘴脸有点恶心，厚脸皮，充满心机，出发点不单纯。&lt;/p&gt;
&lt;h2&gt;学习&lt;/h2&gt;
&lt;p&gt;持续学习，乐于学习。&lt;br&gt;
十步学习法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;了解全局&lt;/li&gt;
&lt;li&gt;确定范围&lt;/li&gt;
&lt;li&gt;定义目标&lt;/li&gt;
&lt;li&gt;寻找资源&lt;/li&gt;
&lt;li&gt;创建学习计划&lt;/li&gt;
&lt;li&gt;筛选资源&lt;/li&gt;
&lt;li&gt;开始学习，浅尝辄止&lt;/li&gt;
&lt;li&gt;动手操作，边玩边学&lt;/li&gt;
&lt;li&gt;全面掌握，学以致用&lt;/li&gt;
&lt;li&gt;乐为人师，融会贯通&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“聚焦学习范围，关注重点内容”，“自我探索”，“主动学习”；&lt;br&gt;
第1步到第6步，这些步骤只做一次；&lt;br&gt;
第7步到第10步，循环往复。  &lt;/p&gt;
&lt;h3&gt;学位&lt;/h3&gt;
&lt;p&gt;“学位并不是成功的必备条件”，&lt;br&gt;
“没有学位会限制你的选择”。  &lt;/p&gt;
&lt;h2&gt;生产力&lt;/h2&gt;
&lt;h3&gt;专注&lt;/h3&gt;
&lt;h3&gt;对自己负责&lt;/h3&gt;
&lt;h3&gt;多任务并行处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;停止任何并非真正的多任务并行的多任务并行，每天力争在一个时间段内只做一件事。&lt;/li&gt;
&lt;li&gt;一次性批量处理小任务，而不是每天或每周里做很多次&lt;/li&gt;
&lt;li&gt;找出能够真正实现多任务并行的领域。任何不需要耗费脑力的活动都可以跟其他活动结合起来。只要进行任何需要耗费脑力的活动，就将其与体育运动结合起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;时间杀手&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电视&lt;/li&gt;
&lt;li&gt;社交媒体&lt;/li&gt;
&lt;li&gt;开会&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分解任务&lt;/h3&gt;
&lt;h3&gt;任何行动都比不采取行动好&lt;/h3&gt;
&lt;h2&gt;理财&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要有赚多少，花多少的短期思维&lt;/li&gt;
&lt;li&gt;“当你拥有一套房子的时候，本质上你不过就是从自己手里租了一套房子而已”；“如果你的房子的价钱高于你所需要的基本住所的费用，那么房子对你而言就是负债。”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者的建议是增加资产，减少负债，增加股票、图书版权、可供出租的不动产等。&lt;/p&gt;
&lt;h3&gt;薪酬&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获得工作的方式会影响薪酬，内推优于主动投简历，企业主动提供机会优于内推。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;先出价的人出于劣势，千万不要先出价，绕过被问及当前薪酬。&lt;/strong&gt;&lt;br&gt;
如果薪酬不满意，可以还价，不过还价2次之后就不要再继续了。另外弄清公司的薪酬范围，和自身水平也很重要。要求薪资的时候，要说清楚自己为什么值这个价钱，能给公司带来什么好处。谈Offer 时，可以自信但是不要傲慢。&lt;/p&gt;
&lt;h3&gt;债务&lt;/h3&gt;
&lt;p&gt;“真正获得财务成功的唯一方法就是用钱生钱。”  &lt;/p&gt;
&lt;h2&gt;健身&lt;/h2&gt;
&lt;h2&gt;精神&lt;/h2&gt;
&lt;p&gt;乐观，积极面对失败。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这是一本为程序员定制的“成功学指南”，或者说是一本“生活指南”，涉及了理财、饮食、健身等各个方面，书中的道理都来自作者的人生经历，之前一直觉得类似《人性的弱点》、《富爸爸、穷爸爸》这些书籍没啥意义，只是大众读物，现在看来，这种看法是伎术人常见的偏见。&lt;br&gt;
总之，愿勿忘初心的同时应该多学习，接触更多领域的知识，特别是理财、健康营养、人际交往、心理健康等，努力让生活变的更好。  &lt;/p&gt;</content><category term="2016"></category><category term="book"></category></entry><entry><title>《Web 性能权威指南》读书笔记</title><link href="https://fangpsh.github.io/posts/2016/2016-11-01.html" rel="alternate"></link><published>2016-11-01T00:00:00+08:00</published><updated>2016-11-01T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-11-01:/posts/2016/2016-11-01.html</id><summary type="html">&lt;p&gt;&lt;img alt="bookcover" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228164135.png"&gt;&lt;/p&gt;
&lt;p&gt;看&lt;a href="https://book.douban.com/subject/25856314/"&gt;《Web 性能权威指南》&lt;/a&gt;的起因是在看&lt;a href="https://book.douban.com/subject/26869219/"&gt;《HTTPS 权威指南》&lt;/a&gt;的时候，看到优化相关的，然后就延伸到想看一下这本书。&lt;br&gt;
这本书，作者提供了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="bookcover" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228164135.png"&gt;&lt;/p&gt;
&lt;p&gt;看&lt;a href="https://book.douban.com/subject/25856314/"&gt;《Web 性能权威指南》&lt;/a&gt;的起因是在看&lt;a href="https://book.douban.com/subject/26869219/"&gt;《HTTPS 权威指南》&lt;/a&gt;的时候，看到优化相关的，然后就延伸到想看一下这本书。&lt;br&gt;
这本书，作者提供了免费的&lt;a href="https://hpbn.co/"&gt;在线英文版&lt;/a&gt;，建议还是看英文的，中文翻译版有些地方略生硬。&lt;/p&gt;
&lt;h2&gt;TCP 优化&lt;/h2&gt;
&lt;p&gt;这部分从协议出发，讲解了优化的要点。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三次握手带来的延迟使得创建每创建一个新的TCP连接都要付出很大的代价。而这也决定了提高TCP应用性能的关键，在于想办法重用连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到重用连接在后续的HTTP 优化都是重点。&lt;br&gt;
第二章分内容和《HTTPS 权威指南》的9.1 有重合，可以都看下。  &lt;/p&gt;
&lt;h3&gt;把服务器内核升级到最新版本（Linux： 3.2+)&lt;/h3&gt;
&lt;p&gt;新内核能获得更好的性能，例如采用了PRR，比例降速算法。&lt;/p&gt;
&lt;h3&gt;确保cwnd 大小为10；&lt;/h3&gt;
&lt;p&gt;增大拥塞窗口，10表示10个&lt;a href="https://en.wikipedia.org/wiki/Maximum_segment_size"&gt;MSS&lt;/a&gt;，以太网标准的MSS 是1460。&lt;br&gt;
前面提到内核升级也可以带来好处，Linux 3.2+ 的内核，cwnd都是默认10。&lt;br&gt;
&lt;img alt="OS_CWND" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228164224.png"&gt;&lt;br&gt;
图片来源：cdnplanet.com&lt;/p&gt;
&lt;p&gt;关于更改initcwnd、查看系统的initcwnd，可以参考:&lt;br&gt;
&lt;a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/"&gt;Tuning initcwnd for optimum performance&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;这一部分可以再看看火丁笔记的&lt;a href="http://huoding.com/2013/11/21/299"&gt;《浅谈TCP优化》&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;禁用空闲后的慢启动&lt;/h3&gt;
&lt;p&gt;主要是存在长连接的时候，要确保把这个给关了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_slow_start_after_idle&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;确保启动窗口缩放&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_windows_scaling&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;减少传输冗余数据&lt;/h3&gt;
&lt;p&gt;应用程序注意能少发数据就少发，这在后面的移动设备App优化上也是重点，移动网络的启动更加耗时和耗电。&lt;/p&gt;
&lt;h3&gt;压缩要传输的数据&lt;/h3&gt;
&lt;p&gt;例如web server 开启gzip，对js、css 做压缩。&lt;/p&gt;
&lt;h3&gt;把服务器放到离用户近的地方减少往返的时间&lt;/h3&gt;
&lt;p&gt;部署CDN，一方面边缘节点能够缓存文件，直接返回给用户。如果是需要回源的话，边缘节点如果能和回源保持长连接，这样可以降低用户访问整个耗时，因为用户只需要和边缘节点三次握手，距离近，耗时更短。&lt;br&gt;
另外在部署HTTPS 的时候，除了TCP握手，还需要TLS握手，如果让边缘节点提供HTTPS，然后以HTTP向后反代，也是一种优化吧。现在CDN 厂商都支持HTTPS了，配置回源的时候选择HTTP 相比HTTPS 会更快，给源站的压力也更小一些，而且在IDC之间，运营商那台恶心的劫持问题应该少很多吧。&lt;/p&gt;
&lt;h3&gt;尽最大可能重用已经建立的TCP 连接&lt;/h3&gt;
&lt;h2&gt;UDP 优化&lt;/h2&gt;
&lt;p&gt;UDP 这部分，在工作中遇到的少，没太多体会。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Application must tolerate a wide range of Internet path conditions.
Application should control rate of transmission.
Application should perform congestion control over all traffic.
Application should use bandwidth similar to TCP.
Application should back off retransmission counters following loss.
Application should not send datagrams that exceed path MTU.
Application should handle datagram loss, duplication, and reordering.
Application should be robust to delivery delays up to 2 minutes.
Application should enable IPv4 UDP checksum, and must enable IPv6 checksum.
Application may use keepalives when needed (minimum interval 15 seconds).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;TLS 优化&lt;/h2&gt;
&lt;p&gt;关于TLS 优化还可以看《HTTPS 权威指南》的9.2：TLS协议优化。&lt;br&gt;
另外淘宝的这份分析非常不错：&lt;a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf"&gt;《淘宝HTTPS探索》&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;SSL卸载&lt;/h3&gt;
&lt;p&gt;在保证兼容性的情况下，升级到新版的openSSL，可以有更好的性能。&lt;br&gt;
HPBN的在这一章的建议是用物理机，纯CPU计算卸载，举了Google和Facebook为例。不过如果是使用的云服务的话，部分云厂商在负载均衡上都提供了SSL卸载的功能，不过感觉对ALPN这些协议的支持不知如何，所以还没试用过。云服务虚机+Nginx 来做卸载还是有少许压力的，高峰期的时候。Intel之类的硬件，甚至F5 这种，感觉成本有点高，不过性能确实非常好，如果有条件的话，可以上这类设备。不过使用了这些设备之后，算法升级、调优的自由度可能就不大了，需要综合考虑。  &lt;/p&gt;
&lt;p&gt;为了降低压力，可以对加密套件的选择进行优化，参考《HTTPS权威指南》一书的测试结果：&lt;br&gt;
&lt;img alt="TLS_Speed" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228164304.png"&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="TLS_Speed_taobao" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230228164345.png"&gt;  &lt;/p&gt;
&lt;p&gt;建议：优先选择ECDHE，禁用DHE。&lt;/p&gt;
&lt;h3&gt;尽早握手&lt;/h3&gt;
&lt;p&gt;类似TCP的三次握手，TLS的握手过程也可以通过类似CDN的网络进行优化。在距离用户较近的地方搭建代理服务器，然后和后端保持长连接，这样降低用户到服务整个的握手时间。&lt;/p&gt;
&lt;h3&gt;证书优化&lt;/h3&gt;
&lt;p&gt;《HTTPS权威指南》提到的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用尽可能少的证书&lt;/li&gt;
&lt;li&gt;只包含必须的证书&lt;/li&gt;
&lt;li&gt;提供完整的证书链&lt;/li&gt;
&lt;li&gt;使用椭圆曲线证书链&lt;/li&gt;
&lt;li&gt;小心同一张证书绑定过多域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个常见的错误是在证书链里面包含根证书，毫无意义，还加大了传输开销。&lt;/p&gt;
&lt;h3&gt;优化TLS 记录大小&lt;/h3&gt;
&lt;p&gt;TLS 太小会造成浪费，头信息的比例过大。如果太大，会造成延迟，如果万一丢包，会非常糟糕。参考&lt;a href="http://fangpeishi.com/optimizing-tls-record-size.html"&gt;TLS Record Size 优化笔记&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;禁用服务器的TLS压缩，安全性问题，Nginx的话默认是不支持的；&lt;/li&gt;
&lt;li&gt;确保证书链不会超过拥塞窗口大小；&lt;/li&gt;
&lt;li&gt;启用会话缓存和无状态恢复，参考nginx 的 ssl_session_cache，ssl_session_timeout等。&lt;/li&gt;
&lt;li&gt;配置ssl_stapling&lt;/li&gt;
&lt;li&gt;配置ssl_session_tickets&lt;/li&gt;
&lt;li&gt;开启HSTS，这个开启得非常小心&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;无线网络优化&lt;/h2&gt;
&lt;p&gt;这部分内容介绍了很多关于移动网络的基础知识，也是为后面的HTTP优化做铺垫，毕竟现在移动App 非常发达。总的来说，移动设备上一次请求的代价更大，时间上和耗电上，所以减少请求和重用连接非常重要。&lt;/p&gt;
&lt;h2&gt;HTTP 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 1.0 升级到HTTP1.1&lt;/li&gt;
&lt;li&gt;减少DNS查询&lt;/li&gt;
&lt;li&gt;减少HTTP请求&lt;/li&gt;
&lt;li&gt;使用CDN&lt;/li&gt;
&lt;li&gt;添加Expires 头部并配置ETag标签&lt;/li&gt;
&lt;li&gt;Gzip 压缩资源&lt;/li&gt;
&lt;li&gt;避免HTTP 重定向&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用持久连接&lt;/h3&gt;
&lt;h3&gt;HTTP管道&lt;/h3&gt;
&lt;p&gt;消除部分等待时间。&lt;/p&gt;
&lt;h3&gt;域名分区&lt;/h3&gt;
&lt;p&gt;这个使用要适量，不让会适得其反。&lt;/p&gt;
&lt;h3&gt;拼接、压缩静态资源&lt;/h3&gt;
&lt;p&gt;直接参考&lt;a href="https://ngxpagespeed.com"&gt;ngxpagespeed.com&lt;/a&gt; 就可以了。&lt;/p&gt;
&lt;h3&gt;升级到HTTP 2.0&lt;/h3&gt;
&lt;p&gt;要注意不要把在HTTP 1.1 上的优化手段用到HTTP 2.0 上，会适得其反。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;书中还有大量其他内容，一些关于TCP、HTTP的基础介绍，以及移动网络、XMLHttpRequest、WebSocket、WebRTC等内容。&lt;/p&gt;</content><category term="2016"></category><category term="web"></category><category term="http"></category><category term="https"></category><category term="book"></category></entry><entry><title>Nginx 加载配置的顺序分析</title><link href="https://fangpsh.github.io/posts/2016/2016-10-14.html" rel="alternate"></link><published>2016-10-14T13:59:30+08:00</published><updated>2016-10-14T13:59:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-10-14:/posts/2016/2016-10-14.html</id><summary type="html">&lt;h2&gt;问题背景&lt;/h2&gt;
&lt;p&gt;在部署HTTPS 的时候，2台Nginx 下都部署了多个域名的证书，即NginxA 部署了证书a.com 和b.com 的证书，NginxB 也部署了证书a.com 和b …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;问题背景&lt;/h2&gt;
&lt;p&gt;在部署HTTPS 的时候，2台Nginx 下都部署了多个域名的证书，即NginxA 部署了证书a.com 和b.com 的证书，NginxB 也部署了证书a.com 和b.com ，域名a.com 指向NginxA，域名b.com 指向NginxB。&lt;br&gt;
在用&lt;a href="https://www.ssllabs.com"&gt;SSL LABS&lt;/a&gt; 检测的时候，发现b.com 会出现“This site works only in browsers with SNI support.”，而a.com 不会。&lt;br&gt;
&lt;img alt="SNI" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164029.png"&gt;  &lt;/p&gt;
&lt;h3&gt;SNI 介绍&lt;/h3&gt;
&lt;p&gt;关于&lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication"&gt;SNI&lt;/a&gt; 的简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Nginx 中可以通过指定不同的 server_name 来配置多个站点。HTTP/1.1 协议请求头中的 Host 字段可以标识出当前请求属于哪个站点。但是对于 HTTPS 网站来说，要想发送 HTTP 数据，必须等待 SSL 握手完成，而在握手阶段服务端就必须提供网站证书。对于在同一个 IP 部署不同 HTTPS 站点，并且还使用了不同证书的情况下，服务端怎么知道该发送哪个证书？&lt;br&gt;
Server Name Indication，简称为 SNI，是 TLS 的一个扩展，为解决这个问题应运而生。有了 SNI，服务端可以通过 Client Hello 中的 SNI 扩展拿到用户要访问网站的 Server Name，进而发送与之匹配的证书，顺利完成 SSL 握手。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;引用来源：&lt;a href="https://imququ.com/post/sth-about-switch-to-https-2.html"&gt;关于启用 HTTPS 的一些经验分享（二）&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用OpenSSL 测试NginxA，NginxB，不指定Host 头，NginxA 返回的是a.com 的证书，NginxB 返回的也是a.com 的证书。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;openssl s_client -connect nginx_ip:443 -showcerts &amp;lt; /dev/null 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Nginx 源码分析&lt;/h2&gt;
&lt;p&gt;基本确定是配置加载的顺序问题。在NginxA 和NginxB 中先加载的都是a.com。
在nginx.conf 中，我用 include 指令 引入了 某目录下的所有conf 结尾的配置:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;include /home/xxxxx/*.conf;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;怀疑Nginx include 是按照字典顺序，即a-z 的顺序。看下源代码，参考的Nginx 代码版本是1.11.0。&lt;br&gt;
先找到include 指定相关的函数:  &lt;/p&gt;
&lt;h3&gt;ngx_conf_file.c&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#/src/core/ngx_conf_file.c&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ngx_command_t&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ngx_conf_commands&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ngx_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;include&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NGX_ANY_CONF&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;NGX_CONF_TAKE1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ngx_conf_include&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ngx_null_command&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;继续查看&lt;code&gt;ngx_conf_include&lt;/code&gt; 函数，略去部分片段:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#/src/core/ngx_config_file.c&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;ngx_conf_include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ngx_conf_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ngx_command_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ngx_glob_t&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;....&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ngx_open_glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NGX_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;ngx_conf_log_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NGX_LOG_EMERG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ngx_errno&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;ngx_open_glob_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt; failed&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NGX_CONF_ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NGX_CONF_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ngx_read_glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ngx_close_glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;ngx_open_glob&lt;/code&gt; 这个函数有点眼熟，glob 是一个熟悉的名字，在Python 和其他语言中常常看到相关的库，用来做文件路径搜索和匹配。继续找&lt;code&gt;ngx_open_glob&lt;/code&gt; 这个函数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#/src/os/unix/ngx_files.c

ngx_int_t
ngx_open_glob(ngx_glob_t *gl)
{
    int  n;

    n = glob((char *) gl-&amp;gt;pattern, 0, NULL, &amp;amp;gl-&amp;gt;pglob);

    if (n == 0) {
        return NGX_OK;
    }

#ifdef GLOB_NOMATCH

    if (n == GLOB_NOMATCH &amp;amp;&amp;amp; gl-&amp;gt;test) {
        return NGX_OK;
}

#endif

    return NGX_ERROR;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;ngx_conf_include&lt;/code&gt; 在后续拿到匹配的文件路径，循环调用&lt;code&gt;ngx_read_glob&lt;/code&gt; 进行读取解析。&lt;br&gt;
&lt;code&gt;ngx_open_glob&lt;/code&gt; 中调用了系统的&lt;code&gt;glob.h&lt;/code&gt; 中的&lt;code&gt;glob&lt;/code&gt; 函数进行路径匹配。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;glob, globfree - find pathnames matching a pattern, free memory from glob()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;glob.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;errfunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;epath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eerrno&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;glob_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pglob&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;globfree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glob_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pglob&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;继续搞清楚返回顺序的问题，&lt;code&gt;glob&lt;/code&gt; 函数的传参第二个是flags。&lt;br&gt;
flags 可以设置为&lt;code&gt;GLOB_NOSORT&lt;/code&gt;，要求对返回的结果不进行排序，也就是说默认是排序的。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GLOB_NOSORT
Don&amp;#39;t sort the returned pathnames.  The only reason to do this
is to save processing time.  By default, the returned
pathnames are sorted.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code&gt;ngx_open_glob&lt;/code&gt; 中调用&lt;code&gt;glob&lt;/code&gt;是传的&lt;code&gt;flags&lt;/code&gt; 是&lt;code&gt;int 0&lt;/code&gt;。在GLOB 的手册中没找到关于flags 设置为0 的说明。继续翻代码。  &lt;/p&gt;
&lt;p&gt;参考&lt;a href="http://man7.org/linux/man-pages/man3/glob.3.html"&gt;glob(3) &lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;glob.c&lt;/h3&gt;
&lt;p&gt;上github 搜了下posix 的glob 实现，  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#https:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/lattera/glibc/blob/master/posix/glob.h&lt;/span&gt;

&lt;span class="cm"&gt;/* Bits set in the FLAGS argument to `glob&amp;#39;.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_ERR    (1 &amp;lt;&amp;lt; 0)&lt;/span&gt;&lt;span class="cm"&gt;/* Return on read errors.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_MARK    (1 &amp;lt;&amp;lt; 1)&lt;/span&gt;&lt;span class="cm"&gt;/* Append a slash to each name.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_NOSORT    (1 &amp;lt;&amp;lt; 2)&lt;/span&gt;&lt;span class="cm"&gt;/* Don&amp;#39;t sort the names.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_DOOFFS    (1 &amp;lt;&amp;lt; 3)&lt;/span&gt;&lt;span class="cm"&gt;/* Insert PGLOB-&amp;gt;gl_offs NULLs.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_NOCHECK    (1 &amp;lt;&amp;lt; 4)&lt;/span&gt;&lt;span class="cm"&gt;/* If nothing matches, return the pattern.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_APPEND    (1 &amp;lt;&amp;lt; 5)&lt;/span&gt;&lt;span class="cm"&gt;/* Append to results of a previous call.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_NOESCAPE    (1 &amp;lt;&amp;lt; 6)&lt;/span&gt;&lt;span class="cm"&gt;/* Backslashes don&amp;#39;t quote metacharacters.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define    GLOB_PERIOD    (1 &amp;lt;&amp;lt; 7)&lt;/span&gt;&lt;span class="cm"&gt;/* Leading `.&amp;#39; can be matched by metachars.  */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;GLOB 的手册中有一句话：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The argument flags is made up of the bitwise OR of zero or more the following symbolic constants.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说可以flag 可以设置为多个，例如:&lt;code&gt;GLOB_APPEND|GLOB_NOSORT&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;在&lt;code&gt;glob.c&lt;/code&gt; 中 不少&lt;code&gt;if(!(flags &amp;amp; GLOB_DOOFFS))&lt;/code&gt; 这样的语句，就明白了，通过与操作，可以在flags 这样一个变量上存储和提取多个组合配置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#https:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/lattera/glibc/blob/master/posix/glob.c#L1243&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GLOB_NOSORT&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* Sort the vector.  */&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pglob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gl_pathv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;oldcount&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;pglob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gl_pathc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pglob&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gl_offs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;oldcount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;collated_compare&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;ngx_open_glob&lt;/code&gt;中的flags 是&lt;code&gt;int 0&lt;/code&gt;，即&lt;code&gt;(!(flags &amp;amp; GLOB_NOSORT))&lt;/code&gt;的结果为&lt;code&gt;True&lt;/code&gt;，即默认进行排序，&lt;code&gt;qsort&lt;/code&gt; 的比较函数是&lt;code&gt;collated_compare&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#https:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/lattera/glibc/blob/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/posix/glob.c#L1283&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;collated_compare&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strcoll&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;strcoll&lt;/code&gt; 函数会根据本地环境变量LC_COLLATE 的设置，来进行对比,细节不太清楚。不过一般的英文环境下，按照ASCII 表，如果s1 大于 s2，则返回值大于0，反之小于0，一样的话返回值为0。
&lt;code&gt;collated_compare&lt;/code&gt; 函数比较结果中，如果小于0，&lt;code&gt;qsort&lt;/code&gt; 会把第一个参数s1 排在s2 前面。在ASCII表中，0~9，a-Z的值是从小到大。  &lt;/p&gt;
&lt;p&gt;参考资料: &lt;a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcoll.htm"&gt;C library function - strcoll()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;code&gt;glob&lt;/code&gt; 函数在默认情况下，返回的结果是按照字母表排序的。即同时存在a.com.conf 和b.com.conf 两份配置，在同时include 的话，a.com.conf 会比b.com.conf 先加载。  &lt;/p&gt;
&lt;p&gt;最后，我把NginxA上的a.com.conf 改成 00-a.com.conf ，把NginxB 上的b.com.conf 改成 00-b.com.conf ，控制了他们的加载顺序。  &lt;/p&gt;
&lt;p&gt;题外话，想起了在用SySV Init 的时候，/etc/rcX.d 下那些 S01XXX，K02XXX 之类的文件，用来控制服务的起停顺序。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="sysv_init_rcx.d" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301164044.png"&gt;&lt;/p&gt;
&lt;p&gt;图片&lt;a href="http://www.jianshu.com/p/b4c38f44c4ea"&gt;来源网络&lt;/a&gt; ，现在手头已经找不到用SySV 做Init 的机器了，冏。&lt;/p&gt;
&lt;h2&gt;Changeset 4943:1e2d5d3f9f6b&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://trac.nginx.org/nginx/changeset/4943/nginx"&gt;Changeset 4943:1e2d5d3f9f6b in nginx&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Message:
Core: removed GLOB_NOSORT glob option.
This will result in alphabetical sorting of included files if
the &amp;quot;include&amp;quot; directive with wildcards is used.

Note that the behaviour is now different from that on Windows, where
alphabetical sorting is not guaranteed for FindFirsFile?()/FindNextFile?()
(used to be alphabetical on NTFS, but not on FAT).

Approved by Igor Sysoev, prodded by many.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2016"></category><category term="nginx"></category><category term="glob"></category></entry><entry><title>TLS Record Size 优化笔记</title><link href="https://fangpsh.github.io/posts/2016/2016-10-10.html" rel="alternate"></link><published>2016-10-10T17:39:55+08:00</published><updated>2016-10-10T17:39:55+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-10-10:/posts/2016/2016-10-10.html</id><summary type="html">&lt;h2&gt;从淘宝说起&lt;/h2&gt;
&lt;p&gt;从&lt;a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf"&gt;《淘宝全站HTTPS实践》&lt;/a&gt;开始说：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="taobao-https" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160434.png"&gt;&lt;/p&gt;
&lt;p&gt;怎么优化呢，调大还是调小。&lt;br&gt;
视频：17min分钟左右:  &lt;/p&gt;
&lt;p&gt;&lt;embed src='http://player.youku.com/player.php/sid/XMTM0MTUzMTk1Mg==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;p&gt;提到Google 动态调，然后一般设置4k，恩,到底怎样。&lt;/p&gt;
&lt;p&gt;看看野狗 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;从淘宝说起&lt;/h2&gt;
&lt;p&gt;从&lt;a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf"&gt;《淘宝全站HTTPS实践》&lt;/a&gt;开始说：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="taobao-https" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301160434.png"&gt;&lt;/p&gt;
&lt;p&gt;怎么优化呢，调大还是调小。&lt;br&gt;
视频：17min分钟左右:  &lt;/p&gt;
&lt;p&gt;&lt;embed src='http://player.youku.com/player.php/sid/XMTM0MTUzMTk1Mg==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;p&gt;提到Google 动态调，然后一般设置4k，恩,到底怎样。&lt;/p&gt;
&lt;p&gt;看看野狗的文章&lt;a href="https://blog.wilddog.com/?p=210"&gt;《扒一扒HTTPS网站的内幕》&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TLS Record Size
服务器在建立TLS连接时，会为每个连接分配Buffer，这个Buffer叫TLS Record Size。这个Size是可调。

Size值如果过小，头部负载比重就会过大，最高可达6%。

Size值如果过大，那单个Record在TCP层会被分成多个包发送。浏览器必须等待这些全部达到后，才能解密，一旦出现丢包、拥塞、重传、甚至重新建立的情况，时延就会被相应增加。

那TLS Record Size值如何选择呢？有两个参数可参考。

首先，TLS Record Size要大于证书链和OCSP Stapling响应大小，证书链不会分成多个record；

其次，要小于初始拥塞窗口值，保证服务器在通信之初可以发送足够数据而不需要等待浏览器确认

一般来说，从根CA机构申请的证书为2-3KB左右，级数越多，证书链越大，ocsp响应为2KB左右，所以TLS Record Size是需要根据你的实际情况设置，Google的值5KB。WildDog当前的值是6KB。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看下大神怎么说：&lt;a href="https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/"&gt;《Optimizing TLS Record Size &amp;amp; Buffering Latency》&lt;/a&gt;，有详细的介绍，TLS Record过大和过小的缺点。&lt;/p&gt;
&lt;p&gt;Nginx 在1.5.9 之后加了ssl_buffer_size，不用硬改源代码了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Syntax:    ssl_buffer_size size;
Default:
ssl_buffer_size 16k;
Context:    http, server
This directive appeared in version 1.5.9.
Sets the size of the buffer used for sending data.

By default, the buffer size is 16k, which corresponds to minimal overhead when sending big responses. To minimize Time To First Byte it may be beneficial to use smaller values, for example:
   ssl_buffer_size 4k;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大神的一个issue：&lt;br&gt;
https://github.com/nodejs/node-v0.x-archive/issues/6889&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;That said, exposing a config flag to set a smaller / static record size is also suboptimal as it introduces an inherent tradeoff between latency and throughput – smaller records are good for latency, but hurt server throughput by adding bytes and CPU overhead. It would be great if we could implement a smarter strategy in node... Some background on how Google servers handle this:

new connections default to small record size
      each record fits into a TCP packet
      packets are flushed at record boundaries
server tracks number of bytes written since reset and timestamp of last write
      if bytes written &amp;gt; {configurable byte threshold) then boost record size to 16KB
      if last write timestamp &amp;gt; now - {configurable time threshold} then reset sent byte count

In other words, start with small record size to optimize for delivery of
small/interactive objects (bulk of HTTP traffic). Then, if large file is
being transferred bump record size to 16KB and continue using that until
the connection goes idle.. when communication resumes, start with small
record size and repeat. Overall, this is aimed to optimize delivery of
small files where incremental delivery is a priority, and also for large
downloads where overall throughput is a priority.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;恩，不能一味的设置那么小，要动态。&lt;/p&gt;
&lt;p&gt;看下书&lt;a href="https://book.douban.com/subject/26869219/"&gt;《 HTTPS 权威指南》&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;16.17 TLS 缓冲区调优
从1.5.9版本开始,Nginx允许使用ssl_buffer_size指令自定义TLS缓冲区的大小。默认值是 16 KB,但是这个值不一定是最优化的,尤其是你希望首字节数据被尽早发送时,有报告显示使 用1400字节的配置可以显著减少延迟。
# 减少TLS缓冲区大小,可以显著减少首字节时间 ssl_buffer_size 1400;
需要注意的是,减少TLS缓冲区大小有可能会降低连接的吞吐量,特别是当你需要发送大量 的数据时。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;继续看下Nginx邮件组的讨论：&lt;br&gt;
&lt;a href="http://mailman.nginx.org/pipermail/nginx/2013-December/041556.html"&gt;http://mailman.nginx.org/pipermail/nginx/2013-December/041556.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后是cloudflare的：Dynamic TLS Records in NGINX:&lt;br&gt;
&lt;a href="https://blog.cloudflare.com/optimizing-tls-over-tcp-to-reduce-latency/"&gt;Optimizing TLS over TCP to reduce latency&lt;/a&gt;,&lt;br&gt;
相关的Nginx Patch: &lt;a href="https://github.com/cloudflare/sslconfig/blob/master/patches/nginx__dynamic_tls_records.patch"&gt;nginx__dynamic_tls_records.patch&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;直接用cloudflare 的patch；&lt;br&gt;
如果做不到动态，先适当调小。&lt;/p&gt;</content><category term="2016"></category><category term="TLS"></category><category term="HTTPS"></category><category term="Nginx"></category></entry><entry><title>监控所有NameServer的SOA 记录的序列号</title><link href="https://fangpsh.github.io/posts/2016/2016-07-31.html" rel="alternate"></link><published>2016-07-31T19:49:30+08:00</published><updated>2016-07-31T19:49:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-07-31:/posts/2016/2016-07-31.html</id><summary type="html">&lt;p&gt;&lt;a href="/posts/2016/2016-05-11.html"&gt;Bind DLZ With MySQL &lt;/a&gt;或者其他方式搭建了权威DNS，为了高可用的话，肯定会有多组NameServer。
除了常规的监控外，还需要监控所有SLave 的NS 的SOA …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/posts/2016/2016-05-11.html"&gt;Bind DLZ With MySQL &lt;/a&gt;或者其他方式搭建了权威DNS，为了高可用的话，肯定会有多组NameServer。
除了常规的监控外，还需要监控所有SLave 的NS 的SOA 序列号（Serial Number）是否和Master 一致，如果落后的话需要报警，有时候也有可能Master NS生成的记录有错，无法同步到Slave NS，也有可能是权限方面出错等等，总之，这个监控非常有必要。  &lt;/p&gt;
&lt;p&gt;关于SOA 记录的介绍可以参考:&lt;a href="https://support.microsoft.com/zh-tw/kb/163971"&gt;DNS SOA 记录的结构&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@   IN  SOA     nameserver.place.dom.  postmaster.place.dom. (
                           1            ; serial number
                           3600         ; refresh   [1h]
                           600          ; retry     [10m]
                           86400        ; expire    [1d]
                           3600 )       ; min TTL   [1h]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用dig 命令向特定NameServer 查询特定域名的SOA 记录:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;dig&lt;span class="w"&gt; &lt;/span&gt;@NS_IP&lt;span class="w"&gt; &lt;/span&gt;domain&lt;span class="w"&gt; &lt;/span&gt;soa
&amp;gt;&amp;gt;dig&lt;span class="w"&gt; &lt;/span&gt;@114.114.114.114&lt;span class="w"&gt; &lt;/span&gt;google.com&lt;span class="w"&gt; &lt;/span&gt;soa

&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;dig&lt;span class="w"&gt; &lt;/span&gt;@NS_IP&lt;span class="w"&gt; &lt;/span&gt;domain&lt;span class="w"&gt; &lt;/span&gt;soa&lt;span class="w"&gt; &lt;/span&gt;+short&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;#返回简短的结果&lt;/span&gt;
&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;dig&lt;span class="w"&gt; &lt;/span&gt;@8.8.8.8&lt;span class="w"&gt; &lt;/span&gt;google&lt;span class="w"&gt; &lt;/span&gt;soa&lt;span class="w"&gt; &lt;/span&gt;+short
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img alt="dns_soa_serial_number" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301171412.png"&gt;&lt;/p&gt;
&lt;p&gt;一个OpenFalcon 的监控脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class="c1"&gt;#author: fangpsh&lt;/span&gt;
&lt;span class="c1"&gt;#check whether NSs have same SOA serial&lt;/span&gt;
&lt;span class="nv"&gt;DATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;date&lt;span class="w"&gt; &lt;/span&gt;+%s&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nv"&gt;HOST&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;cat&lt;span class="w"&gt; &lt;/span&gt;/etc/hostname&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="c1"&gt;#your domain&lt;/span&gt;
&lt;span class="nv"&gt;DOMAIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#master name server&lt;/span&gt;
&lt;span class="nv"&gt;MASTER_NS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#slave NSs, a space separated list&lt;/span&gt;
&lt;span class="nv"&gt;SLAVE_NS_SET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;

q_serial&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
dig&lt;span class="w"&gt; &lt;/span&gt;@&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;DOMAIN&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;soa&lt;span class="w"&gt; &lt;/span&gt;+short&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;dns_s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;q_serial&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;${MASTER_NS}&amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;


&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[{\&amp;quot;metric\&amp;quot;: \&amp;quot;NS_Serial\&amp;quot;, \&amp;quot;endpoint\&amp;quot;: \&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;HOST&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;, \&amp;quot;tags\&amp;quot;: \&amp;quot;host=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;MASTER_NS&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;, &amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\&amp;quot;value\&amp;quot;: 0,&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; \&amp;quot;timestamp\&amp;quot;: &lt;/span&gt;&lt;span class="nv"&gt;$DATE&lt;/span&gt;&lt;span class="s2"&gt;, \&amp;quot;counterType\&amp;quot;: \&amp;quot;GAUGE\&amp;quot;, \&amp;quot;step\&amp;quot;: 60}&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ns&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;SLAVE_NS_SET&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;ns_s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;q_serial&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;ns&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,{\&amp;quot;metric\&amp;quot;: \&amp;quot;NS_Serial\&amp;quot;, \&amp;quot;endpoint\&amp;quot;: \&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;HOST&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;, \&amp;quot;tags\&amp;quot;: \&amp;quot;host=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;ns&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;, &amp;quot;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;dns_s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;ns_s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\&amp;quot;value\&amp;quot;: 0,&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;#ok&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\&amp;quot;value\&amp;quot;: 1,&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;#error&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; \&amp;quot;timestamp\&amp;quot;: &lt;/span&gt;&lt;span class="nv"&gt;$DATE&lt;/span&gt;&lt;span class="s2"&gt;, \&amp;quot;counterType\&amp;quot;: \&amp;quot;GAUGE\&amp;quot;, \&amp;quot;step\&amp;quot;: 60}&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2016"></category><category term="DNS"></category></entry><entry><title>Haproxy 作为Shadowsocks 中继遇到的一个问题</title><link href="https://fangpsh.github.io/posts/2016/2016-07-27.html" rel="alternate"></link><published>2016-07-27T14:57:00+08:00</published><updated>2016-07-27T14:57:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-07-27:/posts/2016/2016-07-27.html</id><summary type="html">&lt;p&gt;之前用Haproxy 来转发Shadowsocks 的流量时遇到一个问题，现象是在使用Slack 的时候（聊天使用了Websocket），频繁重连。凭直觉是由于Haproxy 的某一项timeout …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前用Haproxy 来转发Shadowsocks 的流量时遇到一个问题，现象是在使用Slack 的时候（聊天使用了Websocket），频繁重连。凭直觉是由于Haproxy 的某一项timeout 设置的不合理导致的。&lt;br&gt;
Websocket 协议可以分为2个阶段，先用HTTP 握手，然后建立长连接，通过ws 协议进行通信。将Haproxy 作为中继时，在建立长连接之后，Haproxy 就转入&lt;a href="http://blog.haproxy.com/2011/07/29/layer-4-load-balancing-tunnel-mode/"&gt;tunnel 模式&lt;/a&gt;：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TUN：tunnel（option http-tunnel）：这是 1.0 ~ 1.5-dev21 的默认模式，类似于隧道，HAProxy 仅处理第一个请求和响应，剩余的报文将直接转发而不进行处理。尽量不要使用这个模式，因为它在日志记录和 HTTP 处理上有很多问题。 --来源：liaoph.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;涉及到的timeout 见下图：&lt;br&gt;
&lt;img alt="timeout_websocket" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301163942.png"&gt;&lt;br&gt;
图片来源：www.yuangguo.info&lt;/p&gt;
&lt;p&gt;我们遇到的需要频繁重连的情况，其实是由于timeout tunnel 设置不合理导致的。官方给的关于&lt;a href="https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20tunnel"&gt;timeout tunnel&lt;/a&gt; 的解释： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Set the maximum inactivity time on the client and server side for tunnels.&lt;/p&gt;
&lt;p&gt;The tunnel timeout applies when a bidirectional connection is established
between a client and a server, and the connection remains inactive in both
directions. This timeout supersedes both the client and server timeouts once
the connection becomes a tunnel. In TCP, this timeout is used as soon as no
analyser remains attached to either connection (eg: tcp content rules are
accepted). &lt;strong&gt;In HTTP, this timeout is used when a connection is upgraded (eg:
when switching to the WebSocket protocol, or forwarding a CONNECT request
to a proxy), or after the first response when no keepalive/close option is
specified&lt;/strong&gt;......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外官方给出了一个配置示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;defaults http
    option http-server-close
    timeout connect 5s
    timeout client 30s
    timeout client-fin 30s
    timeout server 30s
    timeout tunnel  1h    # timeout to use with WebSocket and CONNECT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把中继的Haproxy 的这项值设为1h，解决了Slack 会频繁重连的问题。&lt;/p&gt;
&lt;p&gt;参考：
 - &lt;a href="https://github.com/shadowsocks/shadowsocks/wiki/Setup-a-Shadowsocks-relay"&gt;Setup a Shadowsocks relay&lt;/a&gt;
 - &lt;a href="http://www.yangguo.info/2014/06/25/haproxy实现websocket负载均衡/"&gt;Haproxy之websocket的负载均衡方案&lt;/a&gt;
 - &lt;a href="http://liaoph.com/haproxy-tutorial/"&gt;HAProxy 反向代理的使用&lt;/a&gt;&lt;/p&gt;</content><category term="2016"></category><category term="haproxy"></category><category term="websocket"></category></entry><entry><title>ElasticSearch 用于日志记录</title><link href="https://fangpsh.github.io/posts/2016/elasticsearch-for-logging_zh.html" rel="alternate"></link><published>2016-06-15T11:40:00+08:00</published><updated>2016-06-15T11:40:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-06-15:/posts/2016/elasticsearch-for-logging_zh.html</id><summary type="html">&lt;p&gt;&lt;img alt="EdgeofSanity" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302133726.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://edgeofsanity.net/article/2012/12/26/elasticsearch-for-logging.html"&gt;原文地址&lt;/a&gt;：&lt;ul&gt;
&lt;li&gt;http://edgeofsanity.net/article/2012/12/26/elasticsearch-for-logging.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;已获得原文作者翻译许可，本文遵循原文许可协议。&lt;/li&gt;
&lt;li&gt;原文发表时间：2012-12-26&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我工作中，我们在Web …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="EdgeofSanity" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302133726.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://edgeofsanity.net/article/2012/12/26/elasticsearch-for-logging.html"&gt;原文地址&lt;/a&gt;：&lt;ul&gt;
&lt;li&gt;http://edgeofsanity.net/article/2012/12/26/elasticsearch-for-logging.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;已获得原文作者翻译许可，本文遵循原文许可协议。&lt;/li&gt;
&lt;li&gt;原文发表时间：2012-12-26&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我工作中，我们在Web 前端搜索上使用&lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt;。性能至关重要，对我们而言，大多数的数据是静态的。&lt;br&gt;
我们每天更新搜索索引，不过用旧的索引跑几个星期也没问题。这个集群大部分的流量是搜索；这是一个“重读”的集群。一开始的时候我们有一些性能上的小问题，&lt;br&gt;
不过我们通过和ElasticSearch 的Shay Bannon 密切合作解决了这些问题。现在我们的前端集群非常可靠，灵活，和快速。  &lt;/p&gt;
&lt;p&gt;我目前的工作是部署一个符合规范，同时也非常有用的中心化的日志基础服务。这个日志基础服务的目标是尽可能的实现Splunk 的功能。我&lt;a href="http://edgeofsanity.net/article/2012/06/17/central-logging-with-open-source-software.html"&gt;之前写的一篇关于日志记录的文章&lt;/a&gt;解释了我们为什么决定不用&lt;a href="http://splunk.com/"&gt;Splunk&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;评估了一些选择之后，我决定使用ElasticSearch 作为这个系统的后端存储。这个集群的类型和我们之前部署的用于大量搜索的集群&lt;em&gt;非常不同&lt;/em&gt;。  &lt;/p&gt;
&lt;p&gt;译文&lt;br&gt;
由&lt;a href="http://www.everycloudtech.com"&gt;EveryCloud&lt;/a&gt; 贡献的一篇&lt;a href="http://www.everycloudtech.com/elasticsearch-for-logging"&gt;俄语译文&lt;/a&gt;。  &lt;/p&gt;
&lt;h2&gt;索引设计&lt;/h2&gt;
&lt;p&gt;两个流行的开源日志分发系统是&lt;a href="http://graylog2.org/"&gt;Graylog2&lt;/a&gt; 和&lt;a href="http://logstash.net/"&gt;LogStash&lt;/a&gt;。在写这篇文章的时候，&lt;em&gt;稳定&lt;/em&gt;版本的Graylog2 只支持从单一的索引读/写。正如送之前文章中指出的，Graylog2 存在&lt;em&gt;很多&lt;/em&gt;严重的问题。0.10.0 版的Graylog2 将包含联合多个索引的能力。然而，我已经在LogStash 的索引上有了一些经验，因为之前它是唯一的选择。  &lt;/p&gt;
&lt;p&gt;为了尽可能得充分利用ElasticSearch 用来做日志记录，你需要使用多个索引。当你滚动更新索引的时候有非常多种方式，不过LogStash 默认的每天滚动更新的方式是最合理的。这样，你会看到下列内容：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;logstash-2012.12.19&lt;/li&gt;
&lt;li&gt;logstash-2012.12.20&lt;/li&gt;
&lt;li&gt;logstash-2012.12.21&lt;/li&gt;
&lt;li&gt;logstash-THE_WORLD_HAS_ENDED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以跟踪每个索引中有多少个文本。在百万或者千万个文本之后滚动更新，或者其他你随意设定的数值之后，但是这样你会给你自己以后带来更多的工作内容。在某些少见的情况下其他的索引方式可能会更高效，但是对于大多数用户来说，一天一个索引是最简单的，也能最有效的利用你的资源。  &lt;/p&gt;
&lt;!-- more --&gt;

&lt;h2&gt;认真点，不然就回家待着&lt;/h2&gt;
&lt;p&gt;LogStash 和Graylog2 都附带内置的ElasticSearch。这对示范演示和开发来说非常方便。&lt;em&gt;用于真正用途的时候不要使用内置的服务器！&lt;/em&gt;我非常惊奇有大量的LogStash 和Graylog2 用户使用了内置的ElasticSearch 存储引擎，最后在irc.freenode.org 的 #elasticsearch 频道里对服务崩溃感到奇怪。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;请运行一个独立的ElasticSearch 集群！&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;你将需要为集群划划分硬件。像LogStash和ElasticSearch 这样的Java 应用是内存和磁盘缓存密集型的。保证一批硬件是用来作为日志处理的箱子，然后划分这些箱子给ElasticSearch 集群。Java 有一些奇怪的内存问题。我们发现你不会想把超过32GB内存给ElasticSearch，预留至少8GB 给操作系统的文件系统缓存。  &lt;/p&gt;
&lt;p&gt;在我的开发环境中，我的集群每天处理大约60GB 的日志资料，集群一共有三个搜索节点，每个节点24GB 内存，毫无压力。这引发下一个问题，&lt;strong&gt;我的集群需要多少台服务器？&lt;/strong&gt;开始先在你的ElasticSearch 集群中部署3台服务器。这样你可以灵活的关闭一台服务器，维持你的集群能充分得被使用。你可以随时添加更多的硬件！  &lt;/p&gt;
&lt;h2&gt;安装ElasticSearch&lt;/h2&gt;
&lt;p&gt;我不打算覆盖安装ElasticSearch 的所有内容，你可以在文档站点上&lt;a href="http://www.elasticsearch.org/guide/reference/setup/installation.html"&gt;读到更多关于这方面的内容&lt;/a&gt;。你可能决定通过&lt;a href="https://github.com/Aethylred/puppet-elasticsearch"&gt;Puppet&lt;/a&gt; 或&lt;a href="https://github.com/karmi/cookbook-elasticsearch"&gt;Chef&lt;/a&gt; 利用 .deb 包或&lt;a href="https://github.com/tavisto/elasticsearch-rpms"&gt;rpm&lt;/a&gt; 包的方式创建一份ElasticSearch 的部署脚本。关于安装我会说的唯一一件事是，无论有多不爽，最好还是用&lt;a href="http://www.java.com/en/download/index.jsp"&gt;Sun JVM&lt;/a&gt; 运行ElasticSearch。这是ElasticSearch 的开发人员运行ElasticSearch 的方式，所以你也应该这样。  &lt;/p&gt;
&lt;h2&gt;ElasticSearch 配置：OS 和 Java&lt;/h2&gt;
&lt;p&gt;主机系统上有一些地方你&lt;strong&gt;真的&lt;/strong&gt;需要配置一下。我假定你的主机系统上运行的是Linux 系统。你应该使用非特权用户来运行ElasticSearch。我们的集群是用'elasticsearch' 用户来运行的，另外我们调整了&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;中内核对进程和内存上的限制：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Ensure ElasticSearch can open files and lock memory!
elasticsearch   soft    nofile          65536
elasticsearch   hard    nofile          65536
elasticsearch   -       memlock         unlimited
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你也应该把ElasticSearch 最小和最大的内存池设置为&lt;strong&gt;一样的值&lt;/strong&gt;。这样使得启动时就能分配到总内存，这样线程需要更多的内存的时候不需要等待内核分配。我在一个RedHat 系统上部署了ElasticSearch，&lt;code&gt;/etc/sysconfig/elasticsearch&lt;/code&gt;中的配置会在daemon 进程启动时设置好环境变量：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Allocate 14 Gigs of RAM
ES_MIN_MEM=14g
ES_MAX_MEM=&amp;quot;$ES_MIN_MEM&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这份文件由Puppet 管理，并设置内存大小等于50% 的RAM 大小，写2遍。这没什么难的，在&lt;em&gt;每份&lt;/em&gt;ElasticSearch 优化指南中都会提到。  &lt;/p&gt;
&lt;h2&gt;ElasticSearch 配置：elasticsearch.yml&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;elasticsearch.yml&lt;/code&gt; 文件中有一些调优的事情我们可以做，可以极大的改进重写的节点的性能。首先是设置&lt;code&gt;bootstrap.mlockall&lt;/code&gt; 为 true。这会强制JVM 立即分配所有的&lt;code&gt;ES_MIN_MEM&lt;/code&gt;。这意味着Java 在启动时就有了所有所需的内存！重写的集群的另外一个让人担心的点是indexing/bulk 引擎分配内存时不均衡的问题。  &lt;/p&gt;
&lt;p&gt;ElasticSearch 是假定你将大量使用搜索，所以分配了大部分的内存用于保障搜索。这不是我的集群的使用情况，所以调整&lt;code&gt;indices.memory.index_buffer_size&lt;/code&gt;到50%，从而恢复在我们使用方式下内存分配的平衡。在我的设置里，我还提高了刷新间隔和日志刷新的传输总数。否则，ElasticSearch 将需要接近每分钟都刷新传输日志。  &lt;/p&gt;
&lt;p&gt;另外一个需要我们调整以避免灾难性的失败的地方是线程池的设置。ElasticSearch 会做它认为能获得最好性能的事情。我们发现，在生产环境中，这意味着生成成千上万的线程来处理传入的请求。在高负载下，你的集群很快会被压垮。为了避免这种情况，我们分别设置了search,index 和bulk 线程池的最大值。我们主要的操作是bulk，所以给bulk 设置了60个线程，其他的操作设置了20个线程。我们也设置了bulk 队列能处理的最大请求数为200，其他的各为100。这样一来，如果集群过载，它会拒绝新的请求，不过它会留给你足够的文件描述数和PID 来ssh 到主机中找出问题所在。  &lt;/p&gt;
&lt;p&gt;总结以上内容，这是我的&lt;a href="https://gist.github.com/reyjrar/4364063#file-elasticsearch-yml"&gt;配置文件&lt;/a&gt;：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;##################################################################&lt;/span&gt;
&lt;span class="c1"&gt;# /etc/elasticsearch/elasticsearch.yml&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Base configuration for a write heavy cluster&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;

&lt;span class="c1"&gt;# Cluster / Node Basics&lt;/span&gt;
&lt;span class="nt"&gt;cluster.name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;logng&lt;/span&gt;

&lt;span class="c1"&gt;# Node can have abritrary attributes we can use for routing&lt;/span&gt;
&lt;span class="nt"&gt;node.name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;logsearch-01&lt;/span&gt;
&lt;span class="nt"&gt;node.datacenter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;amsterdam&lt;/span&gt;

&lt;span class="c1"&gt;# Force all memory to be locked, forcing the JVM to never swap&lt;/span&gt;
&lt;span class="nt"&gt;bootstrap.mlockall&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;

&lt;span class="c1"&gt;## Threadpool Settings ##&lt;/span&gt;

&lt;span class="c1"&gt;# Search pool&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.search.type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;fixed&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.search.size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;20&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.search.queue_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;100&lt;/span&gt;

&lt;span class="c1"&gt;# Bulk pool&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.bulk.type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;fixed&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.bulk.size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;60&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.bulk.queue_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;300&lt;/span&gt;

&lt;span class="c1"&gt;# Index pool&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.index.type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;fixed&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.index.size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;20&lt;/span&gt;
&lt;span class="nt"&gt;threadpool.index.queue_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;100&lt;/span&gt;

&lt;span class="c1"&gt;# Indices settings&lt;/span&gt;
&lt;span class="nt"&gt;indices.memory.index_buffer_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;30%&lt;/span&gt;
&lt;span class="nt"&gt;indices.memory.min_shard_index_buffer_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;12mb&lt;/span&gt;
&lt;span class="nt"&gt;indices.memory.min_index_buffer_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;96mb&lt;/span&gt;

&lt;span class="c1"&gt;# Cache Sizes&lt;/span&gt;
&lt;span class="nt"&gt;indices.fielddata.cache.size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;15%&lt;/span&gt;
&lt;span class="nt"&gt;indices.fielddata.cache.expire&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;6h&lt;/span&gt;
&lt;span class="nt"&gt;indices.cache.filter.size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;15%&lt;/span&gt;
&lt;span class="nt"&gt;indices.cache.filter.expire&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;6h&lt;/span&gt;

&lt;span class="c1"&gt;# Indexing Settings for Writes&lt;/span&gt;
&lt;span class="nt"&gt;index.refresh_interval&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;30s&lt;/span&gt;
&lt;span class="nt"&gt;index.translog.flush_threshold_ops&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;50000&lt;/span&gt;

&lt;span class="c1"&gt;# Minimum nodes alive to constitute an operational cluster&lt;/span&gt;
&lt;span class="nt"&gt;discovery.zen.minimum_master_nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;2&lt;/span&gt;

&lt;span class="c1"&gt;# Unicast Discovery (disable multicast)&lt;/span&gt;
&lt;span class="nt"&gt;discovery.zen.ping.multicast.enabled&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;false&lt;/span&gt;
&lt;span class="nt"&gt;discovery.zen.ping.unicast.hosts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logsearch-01&amp;quot;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logsearch-02&amp;quot;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logsearch-03&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;ElasticSearch 配置: 索引模板&lt;/h2&gt;
&lt;p&gt;一开始的时候，我是基于LogStash 来部署集群，由于那时Graylog2 部署上的缺点。这一节内容主要关于“logstash”，但同样也适用于Graylog2 或其他自定义的索引映射（译注：&lt;a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html"&gt;Mapping&lt;/a&gt;）。  &lt;/p&gt;
&lt;p&gt;因为我们决定一天创建一个索引，这就有两种方式配置每个索引的映射和特性。我们可以按照我们的需求配置明确得生成索引，也可以使用一个包含我们需要的配置和特性的模板来生成每个索引！模板在这种情况下最方便，我们可以在运行的集群上创建它们！  &lt;/p&gt;
&lt;p&gt;我的&lt;a href="https://gist.github.com/reyjrar/4364225#file-logstash-template-json"&gt;模板配置&lt;/a&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;template&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;logstash-*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;settings&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index.number_of_shards&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index.number_of_replicas&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index.query.default_field&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;@message&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index.routing.allocation.total_shards_per_node&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index.auto_expand_replicas&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;mappings&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;_default_&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;_all&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;enabled&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;_source&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;compress&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;dynamic_templates&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;fields_template&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;mapping&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;path_match&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;@fields.*&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;tags_template&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;mapping&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;path_match&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;@tags.*&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;properties&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@fields&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;object&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;dynamic&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;full&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@source&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@source_host&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@source_path&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@timestamp&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;index&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not_analyzed&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;@message&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;analyzer&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;whitespace&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要在集群上应用配置，我们可以通过一个PUT 来创建和更新模板：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;curl -XPUT &amp;#39;http://localhost:9200/_template/template_logstash/&amp;#39; -d @logstash-template.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将模板设置为&lt;code&gt;logstash-*&lt;/code&gt; ，意味着配置将应用到所以'logstash-' 开头新建的索引。我通过禁用对&lt;code&gt;_all&lt;/code&gt; 字段进行搜索并将默认的属性修改为&lt;code&gt;@message&lt;/code&gt;，覆盖了原来的默认搜索行为（译注：默认会对全部字段进行搜索，作者禁用了这种行为，修改为只对message 字段进行搜索）。这个字段（译注：指message 字段）将包含原生的syslog 消息。这也是唯一一个禁止分析的字段。不要不安。这能节省空间和建立索引的时间。这意味着搜索文档中其他字段时只能使用精确搜索，而不能使用模糊搜索，不过这是OK 的。我们依然可以对&lt;code&gt;@message&lt;/code&gt; 字段进行模糊搜索！这将极大的降低存储空间。  &lt;/p&gt;
&lt;p&gt;在之前的文章中，ElasticSearch 0.19 之前，你可能见过设置了&lt;code&gt;"_source": { "compress": true }&lt;/code&gt; 。这对日志类的数据是不推荐的。这个属性决定了每份文档（日志消息）是否进行压缩存储。由于这些文件往往非常小，压缩并不能真正的节省很多的空间。在进行索引和检索的时，这会带来额外的时间成本。对记录日志的集群来说最好禁用压缩。我们&lt;code&gt;elasticsearch.yml&lt;/code&gt;中启用的压缩是使用块级别的压缩方式，更加高效。&lt;/p&gt;
&lt;h3&gt;索引配置&lt;/h3&gt;
&lt;p&gt;这份索引的配置是为一个3个节点的集群调优的。我们可以修改配置中的任何项，但是如果我们需要扩容或者缩容时，&lt;code&gt;index.number_of_shards&lt;/code&gt;需要立即修改。这份配置不是绝对完美的，因为我们有时最后会有一些孤儿（未分配）的分片。通过&lt;a href="http://www.elasticsearch.org/guide/reference/api/admin-cluster-reroute.html"&gt;ElasticSearch API&lt;/a&gt; 来移动分片可以很方便的纠正这些错误。  &lt;/p&gt;
&lt;p&gt;我们随着添加节点而提升存储能力，而不是复制整个索引到整个集群。这样我们有一个类似“RAID” 的分配分片的设置。我有一个三个节点的集群，每个索引我创建3个分片。这意味着主分片或者“写”分片可以分摊到每一个节点。为了冗余，我设置副本数为一。这意味着每个索引有6个分片。每个节点只需要有每个索引的2个分片。  &lt;/p&gt;
&lt;p&gt;你需要进行实验来找到你需要的配置。在失去功能前，考虑一下损失多少个节点是你能够承受的。你需要基于这个调整副本数量。我采用了一个简单的做法，即用1个分片备份。这意味着我一次只能从集群中下掉一个节点。到目前为止，我发现&lt;code&gt;number_of_replicas&lt;/code&gt; 等于 (2/3 * 节点数) -1 是一个不错的数字，每个人的情况可能不同。  &lt;/p&gt;
&lt;h3&gt;自动扩充副本&lt;/h3&gt;
&lt;p&gt;最好也禁用ElasticSearch 默认会基于集群中有多少节点就扩充多少个副本的行为。我们假定手工管理这个能提高性能，特别是当我们需要停止或重启一个集群中的节点时。自动扩充是一个很不错的特性，对于重搜索的、有着小到中量的数据的索引来说。无需配置，添加一个几点就能提高性能。然而，如果你的索引有着大量的数据，并启用了这个特性，当一个节点重启时，将会发生下列事情：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一切正常。副本(replica)数 = 1&lt;/li&gt;
&lt;li&gt;节点A 关闭&lt;/li&gt;
&lt;li&gt;集群注意到节点下线，状态变成黄色（译注：elasticsearch 集群健康状态用三种颜色表示，红、黄、绿，具体可参考&lt;a href="http://chrissimpson.co.uk/elasticsearch-yellow-cluster-status-explained.html"&gt;Elasticsearch "Yellow" cluster status explained&lt;/a&gt;）  &lt;ul&gt;
&lt;li&gt;副本数 = 0, 期望值为1&lt;/li&gt;
&lt;li&gt;目前节点数为1&lt;/li&gt;
&lt;li&gt;目前副本数期望 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集群健康状态上升为绿色，一切完美&lt;/li&gt;
&lt;li&gt;节点A 重新上线&lt;/li&gt;
&lt;li&gt;集群发送期望的副本数和实际的索引个数&lt;/li&gt;
&lt;li&gt;节点A 它的副本是不必要的，于是删除了数据&lt;/li&gt;
&lt;li&gt;集群增加了节点数，期望的副本数 = 1，实际 = 0&lt;/li&gt;
&lt;li&gt;节点A 被通知它的副本数不满足要求&lt;/li&gt;
&lt;li&gt;节点A 通过网络复制所有副本加到它的索引中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如你看到的，这不太理想，特别是在一个非常繁忙的集群里。请小心你的生产环境中的操作，当你从集群中添加/删除节点时请注意你的网络设备监控图。如果你看到尖峰，你可能需要手动进行处理。你失去了一些魔法，不过你可能发现这些是黑魔法。禁用副本的自动扩充，会出现下列情况：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一切正常&lt;/li&gt;
&lt;li&gt;节点A 关闭&lt;/li&gt;
&lt;li&gt;集群注意到节点下线，状态变成黄色&lt;/li&gt;
&lt;li&gt;集群健康状态未恢复，期望的副本数 != 实际副本数&lt;/li&gt;
&lt;li&gt;节点A 重新上线&lt;/li&gt;
&lt;li&gt;集群发送期望的副本数和实际上所有的索引个数&lt;/li&gt;
&lt;li&gt;节点A 通知集群它有分片的拷贝&lt;/li&gt;
&lt;li&gt;集群期望和实际上的副本数相等，健康状态变绿&lt;/li&gt;
&lt;li&gt;集群校验分片，和复制任何过期的分片给节点A&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这才是大多数人民期望集群默认该做的，但是判定集群状态之间的逻辑关系让这很难实现。再说一次，&lt;code&gt;auto_expand_replicas&lt;/code&gt;的魔法动作在大多数情况下是有用的，不过不适用与我们的情况。  &lt;/p&gt;
&lt;h2&gt;维护和监控&lt;/h2&gt;
&lt;p&gt;我为工作在生产环境中的ElasticSearch写了&lt;a href="https://github.com/reyjrar/es-utils"&gt;一些脚本&lt;/a&gt; 。它包含传送标准值给Graphite 和Cacti。这儿也有一份Nagios 的监控检测脚本，非常容易配置。我们使用这些工具来跟踪我们多个集群的性能和健康状态，包括日志记录集群。过几天，我会更新一下，将包含我们logstash 索引维护的脚本。  &lt;/p&gt;
&lt;p&gt;当你将数据写入日志集群时，ElasticSearch 同时在后台创建Lucence 索引。收到的文档有一个缓冲区，基于你的设置，数据会被刷新到一个Lucene 索引。Lucene 索引新建/更新 的成本非常高，但是搜索非常&lt;em&gt;快&lt;/em&gt;。这意味这单个分片可能包含上百个Lucence 索引，常常被称为段。这些段可以被很快速的搜索，但是每个段只能被一个线程处理。这可能对性能有负面影响。我们已经观察到20多个段的索引，有10%的性能下降。  &lt;/p&gt;
&lt;p&gt;幸运的是，ElasticSearch 提供了&lt;a href="http://www.elasticsearch.org/guide/reference/api/admin-indices-optimize.html"&gt;一个API 优化Lucene段&lt;/a&gt;。你不应该优化一个正在索引数据的索引。在这些分片上，新数据将会生成更多的段。那么我们如何知道已经写完一个索引了呢？如果你还记得，我建议按天建立索引。这意味着，你可以运行一个每天的cron 任务（或每小时）来检查昨天或者更久之前的索引，确保他们已经被优化（或&lt;code&gt;max_num_segments = 1&lt;/code&gt;）。如果你已经为创建索引的名字选择了一些其他模式，那么你刚刚给自己增加加了很多工作。&lt;/p&gt;
&lt;h2&gt;未来的探索&lt;/h2&gt;
&lt;p&gt;这篇文章比我想象的长很多。我只是对设计和实践用于日志记录的ElasticSearch 集群做了表面的研究。我的集群很快会从开发环境迁移到生产环境（尽管它正在提供生产环境的功能）。当我这样做的时候，我将面对更多的挑战，我有一个笔记本写满了关于如何构建索引的方法，关于集群如何处理负载，和其他当你突然提供简单、快速的访问大量的数据时候出现的一些隐私相关的问题。&lt;/p&gt;</content><category term="2016"></category><category term="elasticsearch"></category><category term="graylog"></category><category term="logstash"></category></entry><entry><title>记一个退出终端进程不退出的问题</title><link href="https://fangpsh.github.io/posts/2016/2016-05-23.html" rel="alternate"></link><published>2016-05-23T15:25:30+08:00</published><updated>2016-05-23T15:25:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-05-23:/posts/2016/2016-05-23.html</id><summary type="html">&lt;p&gt;某一天开发同学问了一个问题，他们在线上跑一个job，没用screen，nohup，把iTerm 窗口关了，job 没挂。再登录进去看，PPID 变成1，即进程被init …&lt;/p&gt;</summary><content type="html">&lt;p&gt;某一天开发同学问了一个问题，他们在线上跑一个job，没用screen，nohup，把iTerm 窗口关了，job 没挂。再登录进去看，PPID 变成1，即进程被init 进程接管。&lt;br&gt;
在对应机器上执行&lt;code&gt;shopt&lt;/code&gt;, 发现：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
gnu_errfmt      off
histappend      off
histreedit      off
histverify      off
hostcomplete    on
huponexit       off
interactive_comments    on
lastpipe        off
lithist         off
login_shell     on
mailwarn        off
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意CentOS 7 默认将&lt;code&gt;huponexit&lt;/code&gt; 设为&lt;code&gt;off&lt;/code&gt; 了，这样在用户将Shell 退出结束会话时，系统不会发送 SIGHUP 给所有进程，这效果其实类似使用了nohup，nohup 的作用就是忽略HUP 信号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;huponexit
  If set, bash will send SIGHUP to all jobs when an interactive login shell exits.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2016"></category><category term="shell"></category><category term="linux"></category></entry><entry><title>豆瓣FM 红心歌曲导入网易云音乐</title><link href="https://fangpsh.github.io/posts/2016/2016-05-16.html" rel="alternate"></link><published>2016-05-16T12:08:30+08:00</published><updated>2016-05-16T12:08:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-05-16:/posts/2016/2016-05-16.html</id><summary type="html">&lt;p&gt;&lt;img alt="NeteaseMusic" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306155230.png"&gt;&lt;/p&gt;
&lt;p&gt;从豆瓣FM 转用网易云音乐的几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版权大战，豆瓣FM 里面的歌曲大部分都播放不了了；&lt;/li&gt;
&lt;li&gt;豆瓣FM 音质太烂，相比QQ，网易，虾 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="NeteaseMusic" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306155230.png"&gt;&lt;/p&gt;
&lt;p&gt;从豆瓣FM 转用网易云音乐的几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版权大战，豆瓣FM 里面的歌曲大部分都播放不了了；&lt;/li&gt;
&lt;li&gt;豆瓣FM 音质太烂，相比QQ，网易，虾米之类；&lt;/li&gt;
&lt;li&gt;豆瓣FM 在OS X 下无官方客户端，网页版又依赖Flash，多年后的新版才弃用了；&lt;/li&gt;
&lt;li&gt;豆瓣FM iOS App 常常需要重复登录，有时是在升级之后，简直不能忍；&lt;/li&gt;
&lt;li&gt;豆瓣FM 在北京移动的宽带环境下常常播放卡顿，给豆瓣官方help 邮箱发邮件反馈，跑过他们的测试脚本，不了了之；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网易云音乐的iOS App 和OS X App 都做的不错，不过私人FM 的歌曲推荐相比豆瓣FM 还是差一大节，怀疑是红心歌曲和垃圾歌曲标注的不够，所以产生将豆瓣FM 红心歌曲导入网易云音乐的想法。&lt;br&gt;
记得网易云音乐一开始推出的时候，可以直接从豆瓣FM 和虾米音乐导入歌单，目前已经不可用，所以只能自己动手了。  &lt;/p&gt;
&lt;p&gt;第一步，拉取豆瓣FM 红心歌曲列表，新版的接口好像变了，直接用旧版的接口，登录豆瓣FM 网页版本，&lt;br&gt;
打开&lt;code&gt;https://douban.fm/mine/#!type=liked&lt;/code&gt;, Inspect 看一下网络请求接口，找出类似：&lt;br&gt;
&lt;code&gt;http://douban.fm/j/play_record?ck=&amp;amp;spbid=&amp;amp;type=liked&amp;amp;start=&lt;/code&gt;&lt;br&gt;
的请求，Copy As cURL，得到Cookie 之类的，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/usr/bin/env bash
#Convert DoubanFM liked songs into KWL list.
#require:
#  jq: https://stedolan.github.io/jq/

COUNT=#liked songs number#

for i in `seq 0 15 ${COUNT}`;do
    songs=`curl -s &amp;#39;http://douban.fm/j/play_record?ck=&amp;amp;spbid=&amp;amp;type=liked&amp;amp;start=&amp;#39;$i\
           -H &amp;#39;Host: douban.fm&amp;#39; -H &amp;#39;User-Agent: &amp;#39;\
           -H &amp;#39;Accept: text/plain, */*; q=0.01&amp;#39;\
           -H &amp;#39;Accept-Language: en-US,en;q=0.5&amp;#39;\
           -H &amp;#39;DNT: 1&amp;#39; \
           -H &amp;#39;X-Requested-With: XMLHttpRequest&amp;#39;\
           -H &amp;#39;Referer: http://douban.fm/mine/&amp;#39;\
           -H &amp;#39;Cookie: &amp;#39;\
           -H &amp;#39;Connection: keep-alive&amp;#39;\
           |jq &amp;#39;.songs&amp;#39;`
    for s in `seq 0 14`;do
        song=`echo $songs | jq .[$s]`
        title=`echo $song | jq .title`
        artist=`echo $song | jq .artist`
        echo $title $artist
        echo &amp;quot;&amp;lt;so name=&amp;quot;$title &amp;quot;artist=&amp;quot;$artist&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;&amp;quot; &amp;gt;&amp;gt; Douban_FM.kwl
    done
    sleep 10
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于歌曲总数不一定是15 的倍数，所以最后可能会几项是NULL ，手动删除一下就好了。&lt;br&gt;
生成的DoubanFM.kwl 是酷我的歌曲列表，上传地址：&lt;a href="http://music.163.com/#/import/kuwo"&gt;http://music.163.com/#/import/kuwo&lt;/a&gt;，导入即可。&lt;br&gt;
.kwl 内容片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;so&amp;gt;
&amp;lt;so name=&amp;quot;とんちんかんちん一休さん&amp;quot; artist=&amp;quot;相内恵 / ヤングフレッシュ&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;岛人ぬ宝&amp;quot; artist=&amp;quot;BEGIN&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;美丽的梭罗河&amp;quot; artist=&amp;quot;黄秋生&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;雨&amp;quot; artist=&amp;quot;小果&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Paradise&amp;quot; artist=&amp;quot;Coldplay&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Broken&amp;quot; artist=&amp;quot;Jake Bugg&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;A Step You Can&amp;#39;t Take Back&amp;quot; artist=&amp;quot;Keira Knightley&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Tokyo&amp;quot; artist=&amp;quot;California Wives&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;痴人&amp;quot; artist=&amp;quot;痴人 / 痴人&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;I Cried For You&amp;quot; artist=&amp;quot;Katie Melua&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Counting Stars&amp;quot; artist=&amp;quot;OneRepublic&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
....
&amp;lt;so name=&amp;quot;I Have Nothing&amp;quot; artist=&amp;quot;Whitney Houston&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Sometimes When We Touch&amp;quot; artist=&amp;quot;Rod Stewart&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;From The Bottom Of My Broken Heart&amp;quot; artist=&amp;quot;Britney Spears&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Because I Love You&amp;quot; artist=&amp;quot;Shakin Stevens&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;Rhythm Of The Rain&amp;quot; artist=&amp;quot;Jason Donovan / The Cascades&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;so name=&amp;quot;织梦行云&amp;quot; artist=&amp;quot;骆集益&amp;quot;&amp;gt;&amp;lt;/so&amp;gt;
&amp;lt;/so&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;导入网易云音乐之后会生成一个和kwl文件同名的歌单，再在App 内操作导入到&lt;code&gt;我喜欢的音乐&lt;/code&gt; ，批量加红心即可。目前看来导入之后，隔几天，网易私人FM 的推荐稍微好了一些。&lt;/p&gt;
&lt;p&gt;另外这次导入操作，豆瓣FM 歌曲下架的情况可以让人非常吃惊：&lt;br&gt;
&lt;strong&gt;我的豆瓣FM红心歌曲总计1741 首，能播放的只有421 首，将其导入网易云音乐能播放的有1271首&lt;/strong&gt;。&lt;/p&gt;</content><category term="2016"></category><category term="douban"></category><category term="bash"></category></entry><entry><title>Bind DLZ With MySQL</title><link href="https://fangpsh.github.io/posts/2016/2016-05-11.html" rel="alternate"></link><published>2016-05-11T10:49:30+08:00</published><updated>2016-05-11T10:49:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-05-11:/posts/2016/2016-05-11.html</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;要做好运维自动化，内网域名的自动化管理不可少，得提供丰富的API 供其他内部系统调用。&lt;br&gt;
之前在网易杭研实习，见过 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;要做好运维自动化，内网域名的自动化管理不可少，得提供丰富的API 供其他内部系统调用。&lt;br&gt;
之前在网易杭研实习，见过他们管理内部的域名，还是手工编辑bind 的zone 文件，苦不堪言，改一个得反复检查和找人Review，因为zone 如果出现一丝错误，会导致大量域名解析出错。一个方式是用DNSPod，CloudXNS等，这些服务商一般都有完善的API 支持，但是这样内网域名就暴露在公网，可被人暴力遍历，为渗透之类的提供信息，所以内网自己搭建一个权威DNS 服务器是更好的选择。  &lt;/p&gt;
&lt;p&gt;Name server 的选择上，有很多选择，如&lt;a href="https://www.isc.org/downloads/bind/"&gt;Bind&lt;/a&gt;, &lt;a href="https://www.powerdns.com"&gt;PowerDNS&lt;/a&gt;, &lt;a href="http://www.nlnetlabs.nl/projects/nsd/"&gt;NSD&lt;/a&gt; 等。PowerDNS 对MySQL 有原生支持，
性能上相对&lt;a href="http://bind-dlz.sourceforge.net"&gt;Bind DLZ&lt;/a&gt; MySQL 会强很多，并且有非常多开源的&lt;a href="https://github.com/PowerDNS/pdns/wiki/WebFrontends"&gt;WebFrontend&lt;/a&gt; 支持。不过我最终还是选择了Bind DLZ，性能的问题可以通过后文提到的架构解决掉，并且还可以省去对
MySQL 之类的优化工作，另外自己写一个对数据库的CRUD 操作的Web 界面并不困难，工作量也并不大。  &lt;/p&gt;
&lt;h2&gt;性能与架构&lt;/h2&gt;
&lt;p&gt;Bind DLZ 官方提供了一份&lt;a href="http://bind-dlz.sourceforge.net/perf_tests.html"&gt;Performance Tests&lt;/a&gt;，虽然是比较老的测试了，但是还是有不少参考价值。&lt;br&gt;
&lt;img alt="bind-dlz-perf-tests" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301163634.png"&gt;&lt;/p&gt;
&lt;p&gt;我自己使用queryperf 压测，结果与上图中类似，基本来说Bind DLZ MySQL 相比Bind 原生的方式，QPS 差20倍左右，因为MySQL 只能跑在单线程下。由于这个原因，建议采用Bind DLZ 作为Master，Bind 作为Slave的方式。多个Slave 结合LVS 做高可用和负载均衡，
Master可以另外针对Bind DLZ 和MySQL 做高可用，这样的设计，可以发挥Bind 原生的高性能，也可以利用Bind DLZ 的灵活性。&lt;br&gt;
&lt;strong&gt;但是这样会带来一个问题，在Master 上修改完记录之后，可能不会立即同步到Slave，会带来不一致的问题。不过这个问题可以通过自动发送Notify 来解决掉。&lt;/strong&gt;&lt;br&gt;
&lt;img alt="bind-dlz" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301163644.png"&gt;  &lt;/p&gt;
&lt;p&gt;另外可参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bind-dlz.sourceforge.net/best_practices.html"&gt;Best Practices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bind-dlz.sourceforge.net/worst_practices.html"&gt;Worst Practices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS 查询走UDP 协议，前端转发这块一般用LVS + Keepalived 之类的做高可用，当然用最近出的&lt;a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html"&gt;Nginx UDP Stream&lt;/a&gt; 也可以，不过性能上差很多。&lt;br&gt;
同时也需要优化一下服务器网络UDP 相关的参数。  &lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3&gt;pnotify.pl&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/jodrell/pnotify"&gt;pnotify&lt;/a&gt; - A simple, portable Perl script for sending DNS NOTIFY packets with TSIG support.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用&lt;a href="https://github.com/jodrell/pnotify"&gt;这个脚本&lt;/a&gt;，在每次对域名记录做更改之后都对几台Slave发送一下notify 请求。&lt;/p&gt;
&lt;h3&gt;/etc/resolv.conf&lt;/h3&gt;
&lt;p&gt;把内网NS 加入到&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 之前需要注意一些事情，一般来说resolv.conf 会有多个nameserver，默认情况下会从上到下发送域名解析请求，当然可以配置成轮询（options:rotate)。建议是多个ns slave 为一组，一组有一个lvs 做高可用，将多个lvs的vip 分成多行写到resolv.conf 中，然后配置options: rotate，开启轮询。&lt;br&gt;
另外需要设置一下一次查询的超时时间，默认是5s。如果某个服务处理过程中涉及到大量的域名查询，如果resolv.conf 中某一个nameserver 异常，默认的30s 超时将会导致请求大量堆积。建议改小timeout 的值，特别NS 在同一个内网的情况下。&lt;br&gt;
更多配置细节请参考：&lt;a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html"&gt;resolv.conf - resolver configuration file&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;安装配置&lt;/h2&gt;
&lt;p&gt;Bind 的版本选择上，建议使用官方推荐的stable 版本。DLZ 需要自行编译安装，官方的Bind 源码包里已带DLZ 的相关代码，编译时开启对应选项即可。MySQL 的表设计直接参考&lt;a href="http://bind-dlz.sourceforge.net/mysql_driver.html"&gt;官网内容&lt;/a&gt;，和&lt;a href="http://bind-dlz.sourceforge.net/mysql_example.html"&gt;MySQL_Example&lt;/a&gt;。&lt;br&gt;
建议设置一下MySQL 的trigger，自动更新SOA 记录的serial 字段的值。  &lt;/p&gt;
&lt;p&gt;作为Slave 的Bind 强烈建议使用包管理系统直接安装。如果出现安全问题，Slave 是直接对外提供服务的，需要快速修复，直接 aptitude|yum 更新会方便和快速很多（相信上游仓库打包者的速度）。  &lt;/p&gt;
&lt;p&gt;另外在投入使用之前，搭建者应该已经阅读过官方的手册，&lt;a href="https://kb.isc.org/article/AA-01031"&gt;BIND 9 Documentation&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;安装配置好之后，如果NS 要开放在公网访问，推荐使用&lt;a href="http://www.intodns.com"&gt;intoDNS&lt;/a&gt; 进行检测，可以发现一些细节问题。另外还可以使用&lt;a href="https://dnsspy.io"&gt;DNS Spy&lt;/a&gt; 对安全性做一番检查。&lt;/p&gt;
&lt;p&gt;开发的Web 前端在数据输入上必须做好校验，空格和异常字符等要检测和处理掉，域名需要符合规范（只能包含数字，字母，连接符，点号等，细节可以Google下），不然某条记录出错，依然可能导致大量域名无法解析。&lt;/p&gt;
&lt;h3&gt;安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关注官方的&lt;a href="https://kb.isc.org/category/74"&gt; Security Advisories&lt;/a&gt;，RSS订阅；&lt;/li&gt;
&lt;li&gt;隐藏版本：options 中自定义 version；&lt;/li&gt;
&lt;li&gt;chroot，另外使用非root 账户跑bind 服务；&lt;/li&gt;
&lt;li&gt;限制请求，利用ACL 限制查询来源，如果开放在公网最好关闭递归查询，防止被用于DNS 放大攻击；&lt;/li&gt;
&lt;li&gt;控制好域传送，配置allow-transfer；&lt;/li&gt;
&lt;li&gt;控制好allow-notify；&lt;/li&gt;
&lt;li&gt;控制好allow-update；&lt;/li&gt;
&lt;li&gt;使用DNSSEC；&lt;/li&gt;
&lt;li&gt;等等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;备份&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 备份；&lt;/li&gt;
&lt;li&gt;Slave 的zone 文件备份，方便快速恢复；&lt;/li&gt;
&lt;li&gt;全部域名记录可以选择定期备份到DNSPod 或者CloudXN 之类的，以防万一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监控&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Bind 进程监控；&lt;/li&gt;
&lt;li&gt;Bind 端口监控；&lt;/li&gt;
&lt;li&gt;Bind 解析功能监控；&lt;/li&gt;
&lt;li&gt;Bind 各类请求量和响应监控等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nagios 有一个开源的插件可以使用：&lt;a href="https://exchange.nagios.org/directory/Plugins/Network-Protocols/DNS/check_bind-2Esh/details"&gt;check_bind.sh&lt;/a&gt;，不过很老了，可能需要自己改改，使用rndc 这个命令来获取Bind 的状态，采点绘图。&lt;br&gt;
上面的脚本简单改改，可用于OpenFalcon，Bind9.9 版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/usr/bin/env bash

#check bind status for falcon agent
#fork from https://exchange.nagios.org/directory/Plugins/Network-Protocols/DNS/check_bind-2Esh/details
#author: fangpeishi

ST_OK=0
ST_WR=1
ST_CR=2
ST_UK=3
path_pid=&amp;quot;&amp;quot;
name_pid=&amp;quot;named.pid&amp;quot;
path_rndc=&amp;quot;&amp;quot;
path_stats=&amp;quot;&amp;quot;
path_tmp=&amp;quot;&amp;quot;
pid_check=1
HOST=`hostname`
DATE=`date +%s`


check_pid() {
    if [ -f &amp;quot;$path_pid/$name_pid&amp;quot; ]
    then
        retval=0
    else
        retval=1
    fi
}

trigger_stats() {
    if [ -n &amp;quot;$path_chroot&amp;quot; ]
    then
        sudo chroot $path_chroot $path_rndc/rndc stats
    else
        sudo $path_rndc/rndc -c /named/etc/rndc.conf stats
    fi
}

copy_to_tmp() {
    tac $path_stats/named_stats.txt | awk &amp;#39;/--- \([0-9]*\)/{p=1} p{print} /\+\+\+ \([0-9]*\)/{p=0;if (count++==1) exit}&amp;#39; &amp;gt; $path_tmp/named.stats.tmp
    }

get_vals() {
    succ_1st=`grep &amp;#39;resulted in successful answer&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    succ_2nd=`grep &amp;#39;resulted in successful answer&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    ref_1st=`grep &amp;#39;resulted in referral&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    ref_2nd=`grep &amp;#39;resulted in referral&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    nxrr_1st=`grep &amp;#39;resulted in nxrrset&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    nxrr_2nd=`grep &amp;#39;resulted in nxrrset&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    nxdom_1st=`grep &amp;#39;resulted in NXDOMAIN&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    nxdom_2nd=`grep &amp;#39;resulted in NXDOMAIN&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    rec_1st=`grep &amp;#39;caused recursion&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    rec_2nd=`grep &amp;#39;caused recursion&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    fail_1st=`grep &amp;#39;resulted in SERVFAIL&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    fail_2nd=`grep &amp;#39;resulted in SERVFAIL&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`
    dup_1st=`grep &amp;#39;duplicate queries received&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | grep -m1 &amp;#39;&amp;#39;`
    dup_2nd=`grep &amp;#39;duplicate queries received&amp;#39; $path_tmp/named.stats.tmp | awk &amp;#39;{ print $1 }&amp;#39; | sort -n | grep -m1 &amp;#39;&amp;#39;`

    if [ &amp;quot;$succ_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        success=0
    else
        success=`expr $succ_1st - $succ_2nd`
    fi
    if [ &amp;quot;$ref_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        referral=0
    else
        referral=`expr $ref_1st - $ref_2nd`
    fi
    if [ &amp;quot;$nxrr_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        nxrrset=0
    else
        nxrrset=`expr $nxrr_1st - $nxrr_2nd`
    fi
    if [ &amp;quot;$nxdom_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        nxdomain=0
    else
        nxdomain=`expr $nxdom_1st - $nxdom_2nd`
    fi
    if [ &amp;quot;$rec_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        recursion=0
    else
        recursion=`expr $rec_1st - $rec_2nd`
    fi
    if [ &amp;quot;$fail_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        failure=0
    else
        failure=`expr $fail_1st - $fail_2nd`
    fi
    if [ &amp;quot;$dup_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        duplicate=0
    else
        duplicate=`expr $dup_1st - $dup_2nd`
    fi
    if [ &amp;quot;$drop_1st&amp;quot; == &amp;#39;&amp;#39; ]
    then
        dropped=0
    else
        dropped=`expr $drop_1st - $drop_2nd`
    fi
}

falcon() {
    echo -n &amp;quot;{\&amp;quot;metric\&amp;quot;: \&amp;quot;$1\&amp;quot;, \&amp;quot;endpoint\&amp;quot;: \&amp;quot;$HOST\&amp;quot;, \&amp;quot;tags\&amp;quot;: \&amp;quot;\&amp;quot;, &amp;quot;
    echo -n &amp;quot;\&amp;quot;value\&amp;quot;: $2,&amp;quot;
    echo -n &amp;quot; \&amp;quot;timestamp\&amp;quot;: $DATE, \&amp;quot;counterType\&amp;quot;: \&amp;quot;GAUGE\&amp;quot;, \&amp;quot;step\&amp;quot;: 60}&amp;quot;
}

get_perfdata() {
    echo -n &amp;quot;[&amp;quot;
    falcon &amp;quot;caused_recursion&amp;quot; $recursion
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;duplicate_queries_received&amp;quot; $duplicate
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;failure_responses&amp;quot; $failure
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;nxdomain_responses&amp;quot; $nxdomain
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;nxrrset_responses&amp;quot; $nxrrset
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;referral_responses&amp;quot; $referral
    echo -n &amp;quot;,&amp;quot;
    falcon &amp;quot;success_responses&amp;quot; $success
}

if [ ${pid_check} == 1 ]
then
    check_pid
    if [ &amp;quot;$retval&amp;quot; = 1 ]
    then
        echo -n &amp;quot;[&amp;quot;
        falcon &amp;quot;check_bind&amp;quot; 1
        echo -n &amp;quot;]&amp;quot;
        exit $ST_CR
    fi
fi

trigger_stats
copy_to_tmp
get_vals
get_perfdata

echo -n &amp;quot;,&amp;quot;
falcon &amp;quot;check_bind&amp;quot; 0
echo -n &amp;quot;]&amp;quot;

Exit $ST_OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2016"></category><category term="dns"></category><category term="bind"></category></entry><entry><title>Pelican 文章生成目录</title><link href="https://fangpsh.github.io/posts/2016/2016-04-25.html" rel="alternate"></link><published>2016-04-25T17:22:30+08:00</published><updated>2016-04-25T17:22:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-04-25:/posts/2016/2016-04-25.html</id><summary type="html">&lt;p&gt;最近翻译了一篇 &lt;a href="/posts/2016/2016-04-13.html"&gt;Google风格编程指南&lt;/a&gt;，发现章节一多，没有目录非常不友好。文章是用Markdown 写成的，手写html 代码加目录太不方便了。&lt;br&gt;
Pelican 有一个生成 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近翻译了一篇 &lt;a href="/posts/2016/2016-04-13.html"&gt;Google风格编程指南&lt;/a&gt;，发现章节一多，没有目录非常不友好。文章是用Markdown 写成的，手写html 代码加目录太不方便了。&lt;br&gt;
Pelican 有一个生成目录的插件：&lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/extract_toc"&gt;extract_toc&lt;/a&gt;，试用了一下，发现使用三个反引号标注的代码块乱掉了，这个插件似乎调用的pandoc，而pandoc 支持的markdown 语法不包含试用三个反引号标注代码块，所以悲剧了。  &lt;/p&gt;
&lt;p&gt;改变思路，在文章页面使用JavaScript 解析DOM 树，生成目录表格。&lt;br&gt;
Google 了下，Stackoverflow 看到一问题：&lt;br&gt;
&lt;a href="http://stackoverflow.com/questions/187619/is-there-a-javascript-solution-to-generating-a-table-of-contents-for-a-page"&gt;Is there a JavaScript solution to generating a “table of contents” for a page?&lt;/a&gt;，&lt;br&gt;
参考答案直接拿来用：  &lt;/p&gt;
&lt;p&gt;toc.js&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;onload&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;article-content&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;innerHTML&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;article-content&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;innerHTML&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="sr"&gt;/&amp;lt;h([\d])&amp;gt;([^&amp;lt;]+)&amp;lt;\/h([\d])&amp;gt;/gi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;titleText&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;closeLevel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;closeLevel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="nx"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;ul&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="nx"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;/ul&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;parseInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;anchor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;titleText&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/ /g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;_&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;li&amp;gt;&amp;lt;a href=\&amp;quot;#&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;anchor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\&amp;quot;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;titleText&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;h&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;openLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;lt;a name=\&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;anchor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\&amp;quot;&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;titleText&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;/a&amp;gt;&amp;lt;/h&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;closeLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="nx"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;/ul&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;toc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;innerHTML&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;toc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改pelican 主题 的base.html 之类模板文件的，引入这个JavaScript 文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;{{ SITEURL }}/theme/static/js/toc.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改pelican 主题的生成文章的html 模板，加一个div，另外还需要给文章内容的div 加一个&lt;code&gt;id="contents"&lt;/code&gt;：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;toc&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;article-content&amp;quot; class=&amp;quot;entry-content&amp;quot;&amp;gt;
{{ article.content }}
  &amp;lt;/div&amp;gt;&amp;lt;!-- /.entry-content --&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大功告成，效果如下：&lt;br&gt;
&lt;img alt="pelican_toc" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301170301.png"&gt;&lt;/p&gt;</content><category term="2016"></category><category term="pelican"></category></entry><entry><title>Google Shell 编程风格指南</title><link href="https://fangpsh.github.io/posts/2016/2016-04-13.html" rel="alternate"></link><published>2016-04-13T00:00:00+08:00</published><updated>2016-04-13T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-04-13:/posts/2016/2016-04-13.html</id><summary type="html">&lt;p&gt;google shell编程风格指南翻译&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;原文：&lt;a href="https://google.github.io/styleguide/shell.xml"&gt;https://google.github.io/styleguide/shell.xml&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;修订版：1.26&lt;/li&gt;
&lt;li&gt;作者：Paul Armstrong 等&lt;/li&gt;
&lt;li&gt;注：代码片段内的注释未翻译，怕影响美观。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;h3&gt;使用哪种Shell&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Bash&lt;/code&gt; 是唯一被允许用于编写可执行文件的Shell 脚本语言（译注：存在多种Shell语言，可参考&lt;a href="https://en.wikipedia.org/wiki/Unix_shell）"&gt;Wikipedia:Unix_Shell&lt;/a&gt;。&lt;/strong&gt;&lt;br&gt;
可执行文件必须以&lt;code&gt;#!/bin/bash&lt;/code&gt; 开始（译注：&lt;a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"&gt;Wikipedia:Shebang&lt;/a&gt;），并且使用最小数量的执行选项(译注：&lt;a href="https://www.chainsawonatireswing.com/2012/02/02/find-out-what-your-unix-shells-flags-are-then-change-them//?from=@"&gt;Find out what your UNIX shell’s flags are &amp;amp; then change them&lt;/a&gt;, &lt;a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"&gt;The Set Builtin&lt;/a&gt;）。&lt;br&gt;
使用&lt;code&gt;set&lt;/code&gt;设置shell 执行选项，以便用&lt;code&gt;bash &amp;lt;脚本名&amp;gt;&lt;/code&gt; 的方式调用脚本时候不会破坏执行选项的功能。&lt;br&gt;
限制所有的可执行shell 脚本统一使用bash 使得我们在机器上能统一安装一种shell 。 
唯一的例外，你正在编写的项目强制你使用其他shell 语言。例如Solaris SVR4 软件包要求包内的任何脚本用纯Bourne shell 编写（译注：即sh，参考&lt;a href="https://en.wikipedia.org/wiki/Bourne_shell"&gt;Wikipedia:Bourne_shell&lt;/a&gt;）。  &lt;/p&gt;
&lt;h3&gt;什么时候使用Shell&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Shell 应该只用于编写小工具或者简单的包装脚本（译注：wrapper scripts，&lt;a href="http://tldp.org/LDP/abs/html/wrapper.html"&gt;Shell Wrappers&lt;/a&gt;）。&lt;/strong&gt;&lt;br&gt;
尽管shell 脚本不是一种开发语言，但在Google 内部它被用于编写各种各样的工具性脚本。在广泛的开发部署中，遵循这份编程风格指南是一种共识，而不是一个建议。  &lt;/p&gt;
&lt;p&gt;一些准则： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你主要是调用其他工具和做相对少量的数据处理，使用shell 来完成任务是合适的选择。&lt;/li&gt;
&lt;li&gt;如果你在意性能，请使用其他工具来代替shell。&lt;/li&gt;
&lt;li&gt;任何情况下，如果你发现需要使用数组（译注：&lt;a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html"&gt;Bash:Array variables&lt;/a&gt;），并且不是使用&lt;code&gt;${PIPESTATUS}&lt;/code&gt;（译注：PIPESTATUS 保存着管道中各命令的返回值），你应该使用Python。&lt;/li&gt;
&lt;li&gt;如果你要编写一份超过一百行的Shell 脚本，你应该尽量使用Python 来编写。记住，随着Shell脚本行数的增长，尽早使用其他语言来重写你的脚本，以免将来重写的时候浪费更多的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2&gt;Shell文件和解释器调用&lt;/h2&gt;
&lt;h3&gt;文件扩展名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可执行文件应该不带扩展名（强烈建议）或者使用&lt;code&gt;.sh&lt;/code&gt; 的扩展名。 库文件应该带一个&lt;code&gt;.sh&lt;/code&gt;的扩展名，并且不应该是可执行的。&lt;/strong&gt;&lt;br&gt;
当我们执行一个程序的时候不需要知道它是用什么语言写的，并且shell 也不要求脚本必须带扩展名。所以我们不希望一个可执行文件带着扩展名。&lt;br&gt;
然而，对于库文件来说知道是什么语言写的却非常重要，有时需要使用不同的语言编写类似的库文件。使用代表语言的文件名后缀（即扩展名），就可以让使用不同语言编写的具有同样功能的库件有着相同的名字。  &lt;/p&gt;
&lt;h3&gt;SUID/SGID&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;禁止在Shell 脚本中使用SUID 或SGID （译注：&lt;a href="http://thegeekdiary.com/what-is-suid-sgid-and-sticky-bit/"&gt;What is SUID, SGID and Sticky bit ?&lt;/a&gt;）&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;shell 存在太多的安全问题，以至于允许SUID/SGID 后几乎不可能保证shell 的安全。虽然bash 让运行 SUID 变得困难，但是在某些平台上还是有可能，所以我们明确禁止使用它。&lt;br&gt;
当你需要提权的时候，使用&lt;code&gt;sudo&lt;/code&gt;（译注：&lt;a href="https://en.wikipedia.org/wiki/Sudo"&gt;Wikipedia:sudo&lt;/a&gt;）。  &lt;/p&gt;
&lt;h2&gt;环境&lt;/h2&gt;
&lt;h3&gt;STDOUT vs STDERR&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;所有的错误信息应该传入STDERR（译注：标准错误输出，延伸阅读：&lt;a href="http://www.tldp.org/LDP/abs/html/io-redirection.html"&gt;I/O Redirection&lt;/a&gt;）&lt;/strong&gt;
这使得从实际问题中区分正常状态变得容易。&lt;br&gt;
推荐使用一个函数来专门打印错误信息和其他状态信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;err() {
  echo &amp;quot;[$(date +&amp;#39;%Y-%m-%dT%H:%M:%S%z&amp;#39;)]: $@&amp;quot; &amp;gt;&amp;amp;2
}

if ! do_something; then
  err &amp;quot;Unable to do_something&amp;quot;
  exit &amp;quot;${E_DID_NOTHING}&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;注释&lt;/h2&gt;
&lt;h3&gt;文件头&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;每个文件的开头必须有一段关于它内容的概述&lt;/strong&gt;&lt;br&gt;
每个文件必须在开头部分包含一段关于其内容的概述的注释。也可以选择添加版权声明和作者信息。&lt;br&gt;
例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/bin/bash
#
# Perform hot backups of Oracle databases.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;函数注释&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;除了简短、明确的函数之外，任何一个函数都必须写注释。库文件的中的任何一个函数必须写注释，无论其长短和复杂性。&lt;/strong&gt;&lt;br&gt;
他人应该能够在不阅读源码的情况下通过阅读注释（和帮助信息，如果有提供的话），从而学会使用你的程序或者库文件中的函数。&lt;br&gt;
所有函数的注释都应该包含：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对函数的描述；&lt;/li&gt;
&lt;li&gt;会使用或修改的全局变量；&lt;/li&gt;
&lt;li&gt;函数传参；&lt;/li&gt;
&lt;li&gt;返回值，不是运行的最后一条命令默认的退出状态码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/bin/bash
#
# Perform hot backups of Oracle databases.

export PATH=&amp;#39;/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin&amp;#39;

#######################################
# Cleanup files from the backup dir
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
# Returns:
#   None
#######################################
cleanup() {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实现的注释&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;代码中使用了技巧，或晦涩难懂，或有趣，或十分重要的部分你都应该添加注释。&lt;/strong&gt;&lt;br&gt;
这里要遵循Google 代码注释的通用惯例。不要任何东西都添加注释。如果是一个复杂的算法，或者你在做一些与众不同的事情，加一段简短的注释。  &lt;/p&gt;
&lt;h3&gt;TODO 注释&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对临时性的代码，或短期的解决方案，或足够好但是不够完美的代码等添加TODO 注释。&lt;/strong&gt;&lt;br&gt;
这和&lt;a href="https://google.github.io/styleguide/cppguide.html#TODO_Comments"&gt;C++ Guide&lt;/a&gt; 中的做法约定一致。&lt;br&gt;
TODO 注释都应该在开头包含大写的TODO，跟着是一对小括号，中间注明你的用户名。冒号是可选的。最好也在TODO 条目末尾添加bug/ticket 号码。&lt;br&gt;
例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# TODO(mrmonkey): Handle the unlikely edge cases (bug ####)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;格式&lt;/h2&gt;
&lt;p&gt;修改代码的时候应该遵循现存代码风格，任何新代码都应该遵循下列规范。&lt;/p&gt;
&lt;h3&gt;缩进&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用两个空格做缩进，不要使用tabs。&lt;/strong&gt;&lt;br&gt;
在代码块之间使用空行提提高可读性。缩进是两个空格。无论如何都不要使用tabs。对于已经存在的文件，如实的保留已经存在的缩进。  &lt;/p&gt;
&lt;h3&gt;行宽和长字符串&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;行宽最大为80 个字符。&lt;/strong&gt;&lt;br&gt;
如果不得不写超过80 个字符的字符串，你应该尽可能的使用here 文档（译注：&lt;a href="https://zh.wikipedia.org/wiki/Here文档"&gt;Wikipedia:Here文档&lt;/a&gt;）或者嵌入新行。如果有超过80 个字符的字符串并且不能被分割，这是可以的，但是强烈建议找到一个合适的方法让它变短。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# DO use &amp;#39;here document&amp;#39;s
cat &amp;lt;&amp;lt;END;
I am an exceptionally long
string.
END

# Embedded newlines are ok too
long_string=&amp;quot;I am an exceptionally
  long string.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;管道&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果一行写不下整条管道，那么应该一行一个管段的进行分割。&lt;/strong&gt;&lt;br&gt;
如果一行能写下一条管道，那么就应该写到一行。 &lt;br&gt;
如果写不下，就应该将管道分割为一个管段一行，以2个空格作为缩进。这个规范适用与使用“|” 链接起来的组合命令以及使用“||” 和“&amp;amp;&amp;amp;”的组合逻辑语句。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# All fits on one line
command1 | command2

# Long commands
command1 \
  | command2 \
  | command3 \
  | command4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;循环&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;; do&lt;/code&gt;, &lt;code&gt;; then&lt;/code&gt; 与 &lt;code&gt;while&lt;/code&gt;,&lt;code&gt;for&lt;/code&gt; 或&lt;code&gt;if&lt;/code&gt; 应置于同一行。&lt;/strong&gt;&lt;br&gt;
Shell 中的循环有一点特别,但是我们遵循和声明函数时大括号的相同的准则。即&lt;code&gt;; then&lt;/code&gt; 和 &lt;code&gt;; do&lt;/code&gt; 应该和 if/for/while 语句写在同一行。&lt;code&gt;else&lt;/code&gt; 应该独占一行，结束声明也应该独占一行，并且和开始声明垂直对齐。  &lt;/p&gt;
&lt;p&gt;例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;for dir in ${dirs_to_cleanup}; do
  if [[ -d &amp;quot;${dir}/${ORACLE_SID}&amp;quot; ]]; then
    log_date &amp;quot;Cleaning up old files in ${dir}/${ORACLE_SID}&amp;quot;
    rm &amp;quot;${dir}/${ORACLE_SID}/&amp;quot;*
    if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
      error_message
    fi
  else
    mkdir -p &amp;quot;${dir}/${ORACLE_SID}&amp;quot;
    if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
      error_message
    fi
  fi
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Case 声明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以选择2个空格作为缩进。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匹配行右括号后面和&lt;code&gt;;;&lt;/code&gt;前面都需要加一个空格。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匹配模式，操作和&lt;code&gt;;;&lt;/code&gt; 应该分成不同的行。长的语句或者多命令组合语句应该切割成多行。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匹配表达式应该比&lt;code&gt;case&lt;/code&gt;和&lt;code&gt;esac&lt;/code&gt; 缩进一级。多行操作应该再缩进一级。一般情况下，不需要给匹配表达式加引号。匹配模式前面不应该有左括号。避免使用&lt;code&gt;;&amp;amp;&lt;/code&gt; 和&lt;code&gt;;;&amp;amp;&lt;/code&gt;这些标记。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;case &amp;quot;${expression}&amp;quot; in
  a)
    variable=&amp;quot;...&amp;quot;
    some_command &amp;quot;${variable}&amp;quot; &amp;quot;${other_expr}&amp;quot; ...
  ;;
  absolute)
    actions=&amp;quot;relative&amp;quot;
    another_command &amp;quot;${actions}&amp;quot; &amp;quot;${other_expr}&amp;quot; ...
  ;;
  *)
    error &amp;quot;Unexpected expression &amp;#39;${expression}&amp;#39;&amp;quot;
  ;;
esac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;按优先级排序：和已存的风格一致；给你的变量加引号；推荐使用"${var}"而不是"$var"，但是视具体而定。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;这些仅仅是指南，因为这个主题内容作为强制规定似乎是有争议的。&lt;br&gt;
以下按照优先级排列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和现存代码的风格保持一致。&lt;/li&gt;
&lt;li&gt;给变量加引号，参考「加引号」一节。&lt;/li&gt;
&lt;li&gt;如果不是绝对必要或为了避免歧义，不要用大括号把单个字符的shell 变量或 特殊参数（译注：指$?,$$,$@,$*等这类参数，&lt;a href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html"&gt;Special Parameters&lt;/a&gt;）或位置参数（译注：&lt;a href="https://www.gnu.org/software/bash/manual/html_node/Positional-Parameters.html"&gt; Positional Parameters&lt;/a&gt;）。推荐将其他所有变量都用大括号括起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Section of recommended cases.

# Preferred style for &amp;#39;special&amp;#39; variables:
echo &amp;quot;Positional: $1&amp;quot; &amp;quot;$5&amp;quot; &amp;quot;$3&amp;quot;
echo &amp;quot;Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \$=$$ ...&amp;quot;

# Braces necessary:
echo &amp;quot;many parameters: ${10}&amp;quot;

# Braces avoiding confusion:
# Output is &amp;quot;a0b0c0&amp;quot;
set -- a b c
echo &amp;quot;${1}0${2}0${3}0&amp;quot;

# Preferred style for other variables:
echo &amp;quot;PATH=${PATH}, PWD=${PWD}, mine=${some_var}&amp;quot;
while read f; do
  echo &amp;quot;file=${f}&amp;quot;
done &amp;lt; &amp;lt;(ls -l /tmp)

# Section of discouraged cases

# Unquoted vars, unbraced vars, brace-quoted single letter
# shell specials.
echo a=$avar &amp;quot;b=$bvar&amp;quot; &amp;quot;PID=${$}&amp;quot; &amp;quot;${1}&amp;quot;

# Confusing use: this is expanded as &amp;quot;${1}0${2}0${3}0&amp;quot;,
# not &amp;quot;${10}${20}${30}
set -- a b c
echo &amp;quot;$10$20$30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;加引号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;包含变量的字符串，命令替换，空格和shell 元字符都必须加引号，除了一定要仔细得处理表达式，不加引号。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐给包含单词的字符串加引号（不包括命令选项或路径名）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要给字面上的整数加引号。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仔细处理&lt;code&gt;[[&lt;/code&gt;中匹配模式的引号。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;坚持使用"$@"，除非你有原因要使用 $* 。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# &amp;#39;Single&amp;#39; quotes indicate that no substitution is desired.
# &amp;quot;Double&amp;quot; quotes indicate that substitution is required/tolerated.

# Simple examples
# &amp;quot;quote command substitutions&amp;quot;
flag=&amp;quot;$(some_command and its args &amp;quot;$@&amp;quot; &amp;#39;quoted separately&amp;#39;)&amp;quot;

# &amp;quot;quote variables&amp;quot;
echo &amp;quot;${flag}&amp;quot;

# &amp;quot;never quote literal integers&amp;quot;
value=32
# &amp;quot;quote command substitutions&amp;quot;, even when you expect integers
number=&amp;quot;$(generate_number)&amp;quot;

# &amp;quot;prefer quoting words&amp;quot;, not compulsory
readonly USE_INTEGER=&amp;#39;true&amp;#39;

# &amp;quot;quote shell meta characters&amp;quot;
echo &amp;#39;Hello stranger, and well met. Earn lots of $$$&amp;#39;
echo &amp;quot;Process $$: Done making \$\$\$.&amp;quot;

# &amp;quot;command options or path names&amp;quot;
# ($1 is assumed to contain a value here)
grep -li Hugo /dev/null &amp;quot;$1&amp;quot;

# Less simple examples
# &amp;quot;quote variables, unless proven false&amp;quot;: ccs might be empty
git send-email --to &amp;quot;${reviewers}&amp;quot; ${ccs:+&amp;quot;--cc&amp;quot; &amp;quot;${ccs}&amp;quot;}

# Positional parameter precautions: $1 might be unset
# Single quotes leave regex as-is.
grep -cP &amp;#39;([Ss]pecial|\|?characters*)$&amp;#39; ${1:+&amp;quot;$1&amp;quot;}

# For passing on arguments,
# &amp;quot;$@&amp;quot; is right almost everytime, and
# $* is wrong almost everytime:
#
# * $* and $@ will split on spaces, clobbering up arguments
#   that contain spaces and dropping empty strings;
# * &amp;quot;$@&amp;quot; will retain arguments as-is, so no args
#   provided will result in no args being passed on;
#   This is in most cases what you want to use for passing
#   on arguments.
# * &amp;quot;$*&amp;quot; expands to one argument, with all args joined
#   by (usually) spaces,
#   so no args provided will result in one empty string
#   being passed on.
# (Consult &amp;#39;man bash&amp;#39; for the nit-grits ;-)

set -- 1 &amp;quot;2 two&amp;quot; &amp;quot;3 three tres&amp;quot;; echo $# ; set -- &amp;quot;$*&amp;quot;; echo &amp;quot;$#, $@&amp;quot;)
set -- 1 &amp;quot;2 two&amp;quot; &amp;quot;3 three tres&amp;quot;; echo $# ; set -- &amp;quot;$@&amp;quot;; echo &amp;quot;$#, $@&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;特性和坑&lt;/h2&gt;
&lt;h3&gt;命令替换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;$(command)&lt;/code&gt; 代替反引号。&lt;/strong&gt;&lt;br&gt;
嵌套的反引号需要在内部使用&lt;code&gt;\&lt;/code&gt; 转义。嵌套的&lt;code&gt;$(command)&lt;/code&gt; 不需要改变格式，可读性也更好。&lt;br&gt;
例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# This is preferred:
var=&amp;quot;$(command &amp;quot;$(command1)&amp;quot;)&amp;quot;

# This is not:
var=&amp;quot;`command \`command1\``&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Test, [ 和 [[&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;推荐使用&lt;code&gt;[[ ... ]]&lt;/code&gt;代替 &lt;code&gt;[&lt;/code&gt;,&lt;code&gt;test&lt;/code&gt; 和&lt;code&gt;/usr/bin/[&lt;/code&gt;&lt;/strong&gt;  &lt;br&gt;
&lt;code&gt;[[ ... ]]&lt;/code&gt; 可以降低错误，因为在 &lt;code&gt;[[&lt;/code&gt; 和&lt;code&gt;]]&lt;/code&gt;  直接不会发生路径扩展或单词分割，并且&lt;code&gt;[[ ... ]]&lt;/code&gt; 允许正则表达式而&lt;code&gt;[ ... ]&lt;/code&gt;不允许。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# This ensures the string on the left is made up of characters in the
# alnum character class followed by the string name.
# Note that the RHS should not be quoted here.
# For the gory details, see
# E14 at http://tiswww.case.edu/php/chet/bash/FAQ
if [[ &amp;quot;filename&amp;quot; =~ ^[[:alnum:]]+name ]]; then
  echo &amp;quot;Match&amp;quot;
fi

# This matches the exact pattern &amp;quot;f*&amp;quot; (Does not match in this case)
if [[ &amp;quot;filename&amp;quot; == &amp;quot;f*&amp;quot; ]]; then
  echo &amp;quot;Match&amp;quot;
fi

# This gives a &amp;quot;too many arguments&amp;quot; error as f* is expanded to the
# contents of the current directory
if [ &amp;quot;filename&amp;quot; == f* ]; then
  echo &amp;quot;Match&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;检测字符串&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果可能的话，使用引号而不是过滤字符串。&lt;/strong&gt;&lt;br&gt;
检测字符串时候，Bash能够智能的处理空字符串。所以，为了让代码可读性更好，应用空或非空字符串测试，而不是过滤字符串。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Do this:
if [[ &amp;quot;${my_var}&amp;quot; = &amp;quot;some_string&amp;quot; ]]; then
  do_something
fi

# -z (string length is zero) and -n (string length is not zero) are
# preferred over testing for an empty string
if [[ -z &amp;quot;${my_var}&amp;quot; ]]; then
  do_something
fi

# This is OK (ensure quotes on the empty side), but not preferred:
if [[ &amp;quot;${my_var}&amp;quot; = &amp;quot;&amp;quot; ]]; then
  do_something
fi

# Not this:
if [[ &amp;quot;${my_var}X&amp;quot; = &amp;quot;some_stringX&amp;quot; ]]; then
  do_something
fi  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为避免对你检测的目的感到困惑，请直接使用&lt;code&gt;-z&lt;/code&gt;或&lt;code&gt;-n&lt;/code&gt;。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Use this
if [[ -n &amp;quot;${my_var}&amp;quot; ]]; then
  do_something
fi

# Instead of this as errors can occur if ${my_var} expands to a test
# flag
if [[ &amp;quot;${my_var}&amp;quot; ]]; then
  do_something
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;文件名的通配符扩展&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当对文件名使用通配符的时候，请使用准确的路径。&lt;/strong&gt;&lt;br&gt;
因为文件名可以以&lt;code&gt;-&lt;/code&gt;为开头，所以使用&lt;code&gt;./*&lt;/code&gt; 代替&lt;code&gt;*&lt;/code&gt;会更安全。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Here&amp;#39;s the contents of the directory:
# -f  -r  somedir  somefile

# This deletes almost everything in the directory by force
psa@bilby$ rm -v *
removed directory: `somedir&amp;#39;
removed `somefile&amp;#39;

# As opposed to:
psa@bilby$ rm -v ./*
removed `./-f&amp;#39;
removed `./-r&amp;#39;
rm: cannot remove `./somedir&amp;#39;: Is a directory
removed `./somefile&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Eval&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;应该避免使用&lt;code&gt;eval&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
当用于给变量赋值时，eval 可以解析输入，设置变量，但是不能检查这些变量是什么。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# What does this set?
# Did it succeed? In part or whole?
eval $(set_my_variables)

# What happens if one of the returned values has a space in it?
variable=&amp;quot;$(eval some_function)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;管道导入While&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;相比管道导入while，更推荐使用程序替换（译注：&lt;a href="http://tldp.org/LDP/abs/html/process-sub.html"&gt;Process Substitution&lt;/a&gt;）或 for 循环。在 一个while 循环中修改的变量是不能传递给父进程的，因为循环命令是允许在一个子shell 中。&lt;/strong&gt;&lt;br&gt;
管道导入while 循环中隐藏的子shell 让追踪bug 变得困难。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;last_line=&amp;#39;NULL&amp;#39;
your_command | while read line; do
  last_line=&amp;quot;${line}&amp;quot;
done

# This will output &amp;#39;NULL&amp;#39;
echo &amp;quot;${last_line}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你确定输入不包含空格或者特殊字符串（通常，这意味着不是用户输入的内容），请使用 for 循环。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;total=0
# Only do this if there are no spaces in return values.
for value in $(command); do
  total+=&amp;quot;${value}&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用进程替换可以重定向输出，但是请将命令放置在一个显式的子shell 中，而不是为while 循环创建的隐式子shell。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;total=0
last_file=
while read count filename; do
  total+=&amp;quot;${count}&amp;quot;
  last_file=&amp;quot;${filename}&amp;quot;
done &amp;lt; &amp;lt;(your_command | uniq -c)

# This will output the second field of the last line of output from
# the command.
echo &amp;quot;Total = ${total}&amp;quot;
echo &amp;quot;Last one = ${last_file}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当不需要传递非常的结果给父shell 的时候可以使用while 循环，通常情况下更多的结果需要复杂的“解析”。另外注意一些简单的例子通过类似aws 这样的工具解决起来更容易。这个特性在你特别不希望改变父进程域的变量的时候也是有用的。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Trivial implementation of awk expression:
#   awk &amp;#39;$3 == &amp;quot;nfs&amp;quot; { print $2 &amp;quot; maps to &amp;quot; $1 }&amp;#39; /proc/mounts
cat /proc/mounts | while read src dest type opts rest; do
  if [[ ${type} == &amp;quot;nfs&amp;quot; ]]; then
    echo &amp;quot;NFS ${dest} maps to ${src}&amp;quot;
  fi
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;命名习惯&lt;/h2&gt;
&lt;h3&gt;函数名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用小写字母，用下划线分隔单词。使用&lt;code&gt;::&lt;/code&gt;分隔库文件。函数名后面必须有小括号。关键词&lt;code&gt;function&lt;/code&gt; 是可选的，但在项目中应该保持一致。&lt;/strong&gt;&lt;br&gt;
如果你在写一个简单的函数，请用小写字母和下划线分隔单词。如果你在写一个包，包名请用&lt;code&gt;::&lt;/code&gt; 分隔。左大括号必须和函数名在同一行（和Google 内的其他语言规范一样），并且在函数名和小括号直接不能有空格。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Single function
my_func() {
  ...
}

# Part of a package
mypackage::my_func() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当函数名后面带"()" 的时候，关键词&lt;code&gt;function&lt;/code&gt; 是多余的，但是它提高了函数的辨识度。  &lt;/p&gt;
&lt;h3&gt;变量名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;和函数名规范一致。&lt;/strong&gt;&lt;br&gt;
循环内的变量名应该和其他变量名一样命名。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;for zone in ${zones}; do
  something_with &amp;quot;${zone}&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;常量名和环境变量名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;全部都应该大写，用下划线分隔，在文件顶部声明。&lt;/strong&gt;&lt;br&gt;
常量和任何导出到环境的元素都应该大写。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Constant
readonly PATH_TO_FILES=&amp;#39;/some/path&amp;#39;

# Both constant and environment
declare -xr ORACLE_SID=&amp;#39;PROD&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有些元素在初始设置时就成了常量（例如通过getopts，（译注：&lt;a href="http://wiki.bash-hackers.org/howto/getopts_tutorial"&gt;Small getopts tutorial&lt;/a&gt;））。所以可以在getops 中或在某种情况中设置变量，但是应该在设置之后马上将其设置成只读。注意在函数内部&lt;code&gt;declare&lt;/code&gt; 不会对全局变量进行操作，所以推荐使用&lt;code&gt;readonly&lt;/code&gt;或&lt;code&gt;export&lt;/code&gt;来代替。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;VERBOSE=&amp;#39;false&amp;#39;
while getopts &amp;#39;v&amp;#39; flag; do
  case &amp;quot;${flag}&amp;quot; in
    v) VERBOSE=&amp;#39;true&amp;#39; ;;
  esac
done
readonly VERBOSE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;源文件名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;全小写，如果有必要的话应该用下划线分隔单词。&lt;/strong&gt;&lt;br&gt;
这和Google 内部的其他代码风格一致：&lt;code&gt;maketemplate&lt;/code&gt;或&lt;code&gt;make_template&lt;/code&gt;是可以的，但不可以是&lt;code&gt;make-template&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;只读变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;readonly&lt;/code&gt;或&lt;code&gt;declare -r&lt;/code&gt;来确保它们是只读的。&lt;/strong&gt;&lt;br&gt;
因为全局变量在shell 中被广泛使用，所以在使用它们的时候捕获错误是非常重要的。当你声明变量的时如果打算让它们只读，那就明确的设置一下。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;zip_version=&amp;quot;$(dpkg --status zip | grep Version: | cut -d &amp;#39; &amp;#39; -f 2)&amp;quot;
if [[ -z &amp;quot;${zip_version}&amp;quot; ]]; then
  error_message
else
  readonly zip_version
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;使用局部变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;local&lt;/code&gt;声明函数内的变量。声明和赋值应该在不同行。&lt;/strong&gt;&lt;br&gt;
通过使用&lt;code&gt;local&lt;/code&gt; 声明局部变量来确保它们只作用于函数和子函数内部。这样做避免污染全局命名空间，和避免不经意之间设置了一个对于函数外部十分重要的变量。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;my_func2() {
  local name=&amp;quot;$1&amp;quot;

  # Separate lines for declaration and assignment:
  local my_var
  my_var=&amp;quot;$(my_func)&amp;quot; || return

  # DO NOT do this: $? contains the exit code of &amp;#39;local&amp;#39;, not my_func
  local my_var=&amp;quot;$(my_func)&amp;quot;
  [[ $? -eq 0 ]] || return

  ...
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;函数位置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;将所有函数一起放在常量下方。不要在函数之间挟藏可执行代码。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;如果存在函数，请将它们一起放在文件的开头。只有includes，&lt;code&gt;set&lt;/code&gt; 声明和常量设置有可能出现在函数上面。&lt;br&gt;
不要在函数之间挟藏可执行代码。如果这样做会导致在debug 的时候，代码难以跟踪和出现意想不到的执行结果。&lt;/p&gt;
&lt;h3&gt;main&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;至少包含一个函数的脚本，如果足够长的话，都应该有一个叫&lt;code&gt;main&lt;/code&gt; 的函数。&lt;/strong&gt;&lt;br&gt;
为了方便找到程序开始执行的地方，应该在所有函数的底部放一个叫&lt;code&gt;main&lt;/code&gt;的主函数，包含主要的程序调用。这使得其他的代码保持一致性，也允许你使用&lt;code&gt;local&lt;/code&gt;定义更多的变量（如果主代码不是一个函数是做不到的）。文件最后一行非注释的内容应该是调用&lt;code&gt;main&lt;/code&gt;：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;main &amp;quot;$@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然，对于顺序执行的简短代码，加'main' 函数是适得其反的，并不需要。&lt;/p&gt;
&lt;h2&gt;调用命令&lt;/h2&gt;
&lt;h3&gt;检查返回值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总是检查返回值，并给出具体解释信息。&lt;/strong&gt;&lt;br&gt;
对于非管道的命令，可以简单的使用&lt;code&gt;$?&lt;/code&gt; 或使用&lt;code&gt;if&lt;/code&gt; 语句直接检查返回值。&lt;br&gt;
例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;if ! mv &amp;quot;${file_list}&amp;quot; &amp;quot;${dest_dir}/&amp;quot; ; then
  echo &amp;quot;Unable to move ${file_list} to ${dest_dir}&amp;quot; &amp;gt;&amp;amp;2
  exit &amp;quot;${E_BAD_MOVE}&amp;quot;
fi

# Or
mv &amp;quot;${file_list}&amp;quot; &amp;quot;${dest_dir}/&amp;quot;
if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
  echo &amp;quot;Unable to move ${file_list} to ${dest_dir}&amp;quot; &amp;gt;&amp;amp;2
  exit &amp;quot;${E_BAD_MOVE}&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Bash 也有一个&lt;code&gt;PIPESTATUS&lt;/code&gt; 的变量，可以通过它检查管道中各部分的返回值。如果你仅仅需要检查整条管道的执行成功或失败，可以参考下列做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tar -cf - ./* | ( cd &amp;quot;${dir}&amp;quot; &amp;amp;&amp;amp; tar -xf - )
if [[ &amp;quot;${PIPESTATUS[0]}&amp;quot; -ne 0 || &amp;quot;${PIPESTATUS[1]}&amp;quot; -ne 0 ]]; then
  echo &amp;quot;Unable to tar files to ${dir}&amp;quot; &amp;gt;&amp;amp;2
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然而，当你执行其他命令后&lt;code&gt;PIPESTATUS&lt;/code&gt;就会被覆盖，如果你需要根据管道中不同部分发生的错误执行不同的动作，你需要在执行完命令之后立即将&lt;code&gt;PIPESTATUS&lt;/code&gt; 赋值给一个变量（不要忘记 &lt;code&gt;[&lt;/code&gt; 也是一个命令，抹除&lt;code&gt;PIPESTATUS&lt;/code&gt;的内容）。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tar -cf - ./* | ( cd &amp;quot;${DIR}&amp;quot; &amp;amp;&amp;amp; tar -xf - )
return_codes=(${PIPESTATUS[*]})
if [[ &amp;quot;${return_codes[0]}&amp;quot; -ne 0 ]]; then
  do_something
fi
if [[ &amp;quot;${return_codes[1]}&amp;quot; -ne 0 ]]; then
  do_something_else
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;内建命令 vs 外部命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在选择调用内建命令还是外部程序时，选择内建命令。&lt;/strong&gt;&lt;br&gt;
我们推荐使用&lt;a href="http://linux.die.net/man/1/bash"&gt;bash(1)&lt;/a&gt;中「Parameter Expansion」部分提到的内建命令，因为内建命令更加可靠和可移植（特别是和sed 之类的命令相比）。&lt;br&gt;
例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Prefer this:
addition=$((${X} + ${Y}))
substitution=&amp;quot;${string/#foo/bar}&amp;quot;

# Instead of this:
addition=&amp;quot;$(expr ${X} + ${Y})&amp;quot;
substitution=&amp;quot;$(echo &amp;quot;${string}&amp;quot; | sed -e &amp;#39;s/^foo/bar/&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;始终遵循常识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请花几分钟阅读&lt;a href="https://google.github.io/styleguide/cppguide.html"&gt;C++ Guide&lt;/a&gt; 底部的Parting Words 部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;临别赠言&lt;/p&gt;
&lt;p&gt;始终遵循常识。&lt;/p&gt;
&lt;p&gt;当你编码时，花几分钟阅读一下其他代码，并熟悉它的风格。如果他们在if 条件从句中使用空格，那么你也应该这样做。如果他们的注释由星号组成的盒子围着，那么你也应该这样做。  &lt;/p&gt;
&lt;p&gt;编程风格指南是为了提供一个通用的编程规范，以便人们可以集中精力在编码实现上，而不是考虑代码形式上。我们展示了整体上的风格规范，另外局部的风格也同样重要。如果你在一个文件
中添加的代码的风格和原来的风格差异巨大，当阅读这份代码时，整体的韵味就被破坏了。请尽量避免这样做。&lt;/p&gt;
&lt;p&gt;好了，关于编程风格指南写的够多了，代码本身更加有趣。尽情享受吧！&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="2016"></category><category term="Shell"></category></entry><entry><title>集群的NTP 对时问题</title><link href="https://fangpsh.github.io/posts/2016/2016-04-03.html" rel="alternate"></link><published>2016-04-03T22:55:30+08:00</published><updated>2016-04-03T22:55:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-04-03:/posts/2016/2016-04-03.html</id><summary type="html">&lt;h2&gt;NTP 简单介绍&lt;/h2&gt;
&lt;p&gt;NTP 是互联网上设备之间进行对时的协议，如下图所表示，有多层NTP 服务器，下游服务器向上游进行对时（可以了 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;NTP 简单介绍&lt;/h2&gt;
&lt;p&gt;NTP 是互联网上设备之间进行对时的协议，如下图所表示，有多层NTP 服务器，下游服务器向上游进行对时（可以了解一下stratum 值）。&lt;br&gt;
&lt;img alt="NTP" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301163444.png"&gt;&lt;/p&gt;
&lt;p&gt;我们假设上游的服务器时间是可靠的，我们所要做的就是尽量使本地计算机时间和上游服务器时间一致，原理如下图（图片来自wikipedia）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="NTP-Algorithm" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301163455.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t0 是客户端发送请求包时的客户端时间戳；&lt;/li&gt;
&lt;li&gt;t1 是服务端收到请求包时的服务端时间戳；&lt;/li&gt;
&lt;li&gt;t2 是服务端发送响应包时的服务端时间戳；&lt;/li&gt;
&lt;li&gt;t3 是客户端收到响应包时的客户端时间戳。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们假设数据包传输来回所花的时间一样（注意：这是主要的误差原因），并且客户端和服务端处理数据包的时间一致，
那么客户端和服务端的时间差就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(t1-t0)+(t2-t3)/2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;简单推导下公式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;设服务端-客户端时间差为：offset
设请求包在网络上的传输时间为：s0
设响应包在网络上的传输时间为: s1

按条件得：
t0 + s0 = t1 - offset  =&amp;gt; offset = t0 + s0 -t1
t2 + s1 = t3 + offset  =&amp;gt; offset = t3 - t2 -s1

=&amp;gt; offset = (t0 - t1 + t3 - t2 + s0 - s1)/2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果s0 - s1 = 0，即来回传输包所话的时间相等，那么对时的误差会相对来说小一点，但是在一些糟糕的网络环境下，例如移动网络，这个传输时间差常常很大，几百毫秒都有可能，所以在选择
移动端对时的方案时需注意这个问题。  &lt;/p&gt;
&lt;p&gt;服务端和客户端传输来回所花的时间为：&lt;code&gt;( t3 - t0 ) - (t2 - t1)&lt;/code&gt;。&lt;br&gt;
这个时间在ntpd server 选择上游ntpd 服务器的算法中可作为重要的考察指标。我们知道如果来回传输总的延时增大，来回传输数据包所花时间差值增大的概率也随之增加。&lt;br&gt;
关于NTP 协议的详细介绍可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Network_Time_Protocol"&gt;Wikipedia:NTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.eecis.udel.edu/~mills/ntp/html/warp.html"&gt;How NTP Works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;服务器对时设置&lt;/h2&gt;
&lt;p&gt;首先需要考虑的是服务器整个集群时间一致性的问题，然后才是服务器时间和标准时间误差的问题。  &lt;/p&gt;
&lt;p&gt;我们知道集群内网的环境一般都比较好，即可以减少上文中的 （s1 -s0） 的差，所以最好的选择是在内网搭建NTP Server，供集群内的所有服务器使用，这样可以保证整个集群内的时间一致。&lt;br&gt;
&lt;strong&gt;注意：NTP Server 没必要情况下不要暴露在外网，如果需要给外网访问，做好授权，避免被作为NTP 反射攻击的工具。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;这台NTP Server 也需要上游同步时间。这里有一个&lt;strong&gt;坑&lt;/strong&gt;，Linux 常用的ntpd 程序只会在ntpd 启动时去解析上游服务器的域名，如果这些上游的服务器宕机了，或者更改IP 了，下游是无法主动发现的。&lt;br&gt;
对于这个问题，首先是配置多几个&lt;strong&gt;优质&lt;/strong&gt;的上游服务器，ntpd 本身对于上游服务器有一个选择策略，可以避免某几个上游宕机而同步不到时间。对于上游的这些服务器最好选择ntp.org 官方的，或者知名厂商或者组织的，总之就是求稳定和可靠，恶意的NTP 数据包影响不是小事。土豪可以自己上硬件授时的工具了，23333。  &lt;br&gt;
国内常见的NTP 服务器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;阿里：
time1~7.aliyun.com
分别位于阿里北上深杭青不同的机房，上游据说是GPS 还是北斗授时，相对可靠。

ntp.org:
cn.pool.ntp.org, 0.asia.pool.ntp.org, 1.asia.pool.ntp.org
更多请查看 http://www.pool.ntp.org

上海交大：
ntp.sjtu.edu.cn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外一个措施是&lt;strong&gt;定期重启内网NTP Server 的进程&lt;/strong&gt;。&lt;br&gt;
集群内的其他机器的ntp 进程，ntp.conf 设置优先从内网NTP Server 对时。另外需要设置为开机启动，并对进程状态做好监控，同时也记得控制好这些ntp 进程的安全，禁止外网的查询请求。这些机器的ntp.conf 内的上游服务器可以配置成和内网NTP Server 一致，防止内网NTP Server 长时间宕机。。。  &lt;/p&gt;
&lt;p&gt;其他参考质料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://linux.die.net/man/5/ntp.conf"&gt;man:ntp.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://haibing.org/64/%e7%94%9f%e4%ba%a7%e4%b8%8a%e7%9a%84ntp%e9%85%8d%e7%bd%aentp-conf/"&gt;生产上的NTP配置ntp.conf&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;</content><category term="2016"></category><category term="linux"></category><category term="ntp"></category></entry><entry><title>使用Systemd 的Linux 的启动过程</title><link href="https://fangpsh.github.io/posts/2016/2016-03-15.html" rel="alternate"></link><published>2016-03-15T11:55:30+08:00</published><updated>2016-03-15T11:55:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2016-03-15:/posts/2016/2016-03-15.html</id><summary type="html">&lt;p&gt;这篇文章是回答知乎上一个朋友的问题：&lt;a href="https://www.zhihu.com/question/20880224"&gt;Systemd 的详细启动过程是怎样的&lt;/a&gt; 。&lt;br&gt;
回答这个问题前需要了解一下计算机的启动过程 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这篇文章是回答知乎上一个朋友的问题：&lt;a href="https://www.zhihu.com/question/20880224"&gt;Systemd 的详细启动过程是怎样的&lt;/a&gt; 。&lt;br&gt;
回答这个问题前需要了解一下计算机的启动过程和Linux 的启动过程，才能完整串起来。
关于计算机的启动，可以先阅读一下阮一峰的文章：&lt;a href="http://www.ruanyifeng.com/blog/2013/02/booting.html"&gt;计算机是如何启动的？&lt;/a&gt;，这篇文章在系统启动部分，大概提到了Linux 系统的启动，
不过不是十分详细，可以再看他的另一篇文章：&lt;a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html"&gt;Linux 的启动过程&lt;/a&gt;，文章所介绍的Init 程序是传统的Sysv。
而使用Systemd 的Linux 系统的差别就是在 Init 程序这一阶段。&lt;br&gt;
在加载内核之前的阶段，这篇文章讲的挺细，可以顺便读一读：&lt;a href="http://chrinux.blog.51cto.com/6466723/1192004"&gt;详解linux系统的启动过程及系统初始化&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;然后可以读一下这篇文章，对Systemd 的基础介绍，非常不错：&lt;a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html"&gt;浅析 Linux 初始化 init 系统，第 3 部分: Systemd&lt;/a&gt;，感觉IBM developerworks 的文章质量都挺不错的。  &lt;/p&gt;
&lt;p&gt;虚拟文件系统Initrd，启动到这一步之后，通过Switch-root 转到 Init 程序，即Systemd（也可以是Sysv 之类的），后面就是Systemd 如何启动服务进程的问题。&lt;br&gt;
Initrd 这一步，Systemd 其实也可以接管，具体参考：&lt;a href="https://www.freedesktop.org/software/systemd/man/bootup.html#Bootup%20in%20the%20Initial%20RAM%20Disk%20(initrd)"&gt;initrd with systemd&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在传统的Sysv 中，有Runlevel（启动级别）的概念，在Systemd 里面有Target 的概念，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="runlevel" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161756.png"&gt;&lt;/p&gt;
&lt;p&gt;Systemd 有个单元文件（Unit）的概念，可以理解成一个单元文件就是一个服务单元，有很多类型的单元文件，Mount、Device、Service、Path、Timer 等，最常见的就是Service 单元：&lt;/p&gt;
&lt;p&gt;例：/usr/lib/systemd/system/named.service，具体的解释请看官方文档：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=Berkeley Internet Name Domain (DNS)
Wants=nss-lookup.target
Wants=named-setup-rndc.service
Before=nss-lookup.target
After=network.target
After=named-setup-rndc.service

[Service]
Type=forking
EnvironmentFile=-/etc/sysconfig/named
Environment=KRB5_KTNAME=/etc/named.keytab
PIDFile=/run/named/named.pid

ExecStartPre=/usr/sbin/named-checkconf -z /etc/named.conf
ExecStart=/usr/sbin/named -u named $OPTIONS

ExecReload=/bin/sh -c &amp;#39;/usr/sbin/rndc reload &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || /bin/kill -HUP $MAINPID&amp;#39;

ExecStop=/bin/sh -c &amp;#39;/usr/sbin/rndc stop &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || /bin/kill -TERM $MAINPID&amp;#39;

PrivateTmp=true

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Target 也是一种单元文件，但是它是引用和组织其他的单元文件，定义组织各种依赖关系。所以，Target 肯定可以实现Runlevel 的作用，只要定义六个Target 就可以了嘛。
再看看下面这张图，就大致明白了启动的时候是怎么加载服务进程的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bootup" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230301161805.png"&gt;&lt;/p&gt;
&lt;p&gt;更多细节，以及关机的过程请参考：&lt;a href="https://www.freedesktop.org/software/systemd/man/bootup.html"&gt;bootup&lt;/a&gt;&lt;/p&gt;</content><category term="2016"></category><category term="Linux"></category><category term="Systemd"></category></entry><entry><title>Docker与虚拟机等的SSH权限管理控制解决方案</title><link href="https://fangpsh.github.io/posts/2015/2015-11-26.html" rel="alternate"></link><published>2015-11-26T15:59:00+08:00</published><updated>2015-11-26T15:59:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-11-26:/posts/2015/2015-11-26.html</id><summary type="html">&lt;p&gt;Docker和VM一类的云平台的权限控制如果采用常见的方式，把登录者的公钥写入&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;, 由于企业内部的人员流动和权限变更，往往不是十分便利。  &lt;/p&gt;
&lt;p&gt;特别是如果还选择把authorized_keys 打到镜像 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Docker和VM一类的云平台的权限控制如果采用常见的方式，把登录者的公钥写入&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;, 由于企业内部的人员流动和权限变更，往往不是十分便利。  &lt;/p&gt;
&lt;p&gt;特别是如果还选择把authorized_keys 打到镜像中的话，管理起来就会十分蛋疼。不过对于Docker这种容器，如果还需要开发登录进去进行Debug或者做其他操作的话，姿势上其实是不对的，不符合它的设计哲学，但是按照目前接触的国内使用Docker做内部云的厂商来看的话，大都是把Docker当作一个轻量级的VM来用而已，很多更是为了用Docker而用Docker。  &lt;/p&gt;
&lt;p&gt;这是题外话，如果是在企业内部的Server（Docker的容器、VM以及物理机），应该选择公共帐号登录，而不是给每个开发者或者运维人员都开一个个人帐号上去搞，这样不仅会十分混乱，而且员工离职之类的还好带来不少“遗留问题”。  &lt;/p&gt;
&lt;p&gt;一种解决思路是通过一些配置管理工具来管理Server的authorized_keys，例如Puppet、SaltStack、Ansible等。不过这需要运维人肉编辑配置文件，而且权限这种东西变更很频繁，所以更进一步是在这些配置管理工具只是进行开发，提供一个Web 服务作为权限控制平台。    &lt;/p&gt;
&lt;p&gt;另外一种解决思路是通过&lt;a href="/posts/2015/2015-01-05.html"&gt;OpenSSH的AuthorizedKeysCommand选项&lt;/a&gt;，调用一个脚本，从远程的服务取得授权登者的公钥，具体做法可以参考前面链接的文章。  &lt;/p&gt;
&lt;p&gt;这种方法有个问题，如果远端权限管理的服务宕机了，可能是一个Web 服务，MySQL Server或者LDAP，都将造成通过这种方式授权的用户无法登录，所以必须保证该服务的稳定性。  &lt;/p&gt;
&lt;p&gt;另外应该禁止掉root登录，因为AuthorizedKeysCommand是作用于所有用户，包括root用户。将所有权限放在一个“篮子“里的话，除了得保证这个篮子的稳定性，还有安全性。  &lt;/p&gt;
&lt;p&gt;通过开发定制化一个Web服务，可以做更多事情，例如控制帐号的有效期，权限的批量开通等等。  &lt;/p&gt;</content><category term="2015"></category><category term="SSH"></category></entry><entry><title>OpenGrok 安装部署与添加LDAP验证</title><link href="https://fangpsh.github.io/posts/2015/2015-11-24.html" rel="alternate"></link><published>2015-11-25T15:09:00+08:00</published><updated>2015-11-25T15:09:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-11-25:/posts/2015/2015-11-24.html</id><summary type="html">&lt;p&gt;公司同事有阅读代码的需求，尝试部署了一个OpenGrok，安装过程参考这篇Blog，非常详细：&lt;a href="http://ox0spy.github.io/opengrok/2013/08/14/setup-opengrok/"&gt;OpenGrok安装使用指南&lt;/a&gt;，&lt;br&gt;
或者直接看官方Wiki: &lt;a href="https://github.com/OpenGrok/OpenGrok/wiki/How-to-install-OpenGrok"&gt;How to install OpenGrok&lt;/a&gt; 。&lt;br&gt;
遇到两个 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;公司同事有阅读代码的需求，尝试部署了一个OpenGrok，安装过程参考这篇Blog，非常详细：&lt;a href="http://ox0spy.github.io/opengrok/2013/08/14/setup-opengrok/"&gt;OpenGrok安装使用指南&lt;/a&gt;，&lt;br&gt;
或者直接看官方Wiki: &lt;a href="https://github.com/OpenGrok/OpenGrok/wiki/How-to-install-OpenGrok"&gt;How to install OpenGrok&lt;/a&gt; 。&lt;br&gt;
遇到两个问题，一个是导入了很多项目之后，对多个项目进修检索的时候出现了错误"Error parsing HTTP request header"，错误码400。这是由于选择多个项目时，导致HTTP 头特别大，超出了限制，修改一下app/tomcat/conf/server.xml，指定下maxHTTPSize:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;Connector port=&amp;quot;8080&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot;
           connectionTimeout=&amp;quot;20000&amp;quot;
           maxHttpHeaderSize=&amp;quot;65536&amp;quot;
           redirectPort=&amp;quot;8443&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外一个问题是LDAP支持的问题，需要支持LDAP验证，Google了一下，不少解决方法，不过都是抄来抄去，而且由于个人对Tomcat不熟悉，最后找了一个简单的方法，编辑server.html,也HOST标签之间插入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;Realm className=&amp;quot;org.apache.catalina.realm.JNDIRealm&amp;quot;
               debug=&amp;quot;99&amp;quot;
               connectionURL=&amp;quot;ldap://&amp;quot;
               userPattern=&amp;quot;cn={0}, ou=XXX,dc=XXX,dc=XXX&amp;quot;
/&amp;gt;
&amp;lt;/Realm&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外把原有的一个Realm块注释掉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;!--
        &amp;lt;Realm className=&amp;quot;org.apache.catalina.realm.UserDatabaseRealm&amp;quot;
               resourceName=&amp;quot;UserDatabase&amp;quot;/&amp;gt;
        &amp;lt;/Realm&amp;gt;
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果如下，基本的HTTP Authentication对话框：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="opengrok_ldap" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145512.png"&gt;  &lt;/p&gt;</content><category term="2015"></category><category term="OpenGrok"></category><category term="LDAP"></category></entry><entry><title>重温 IPv6</title><link href="https://fangpsh.github.io/posts/2015/2015-09-13.html" rel="alternate"></link><published>2015-09-13T21:48:00+08:00</published><updated>2015-09-13T21:48:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-09-13:/posts/2015/2015-09-13.html</id><summary type="html">&lt;p&gt;&lt;img alt="ipv6" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145336.png"&gt;&lt;/p&gt;
&lt;p&gt;今晚在&lt;a href="https://v2ex.com/t/220352"&gt;该帖子&lt;/a&gt;中见到网友说 塞尔的ipv6服务实际上包的openvpn，虽然官方只提供了Windows下的安装包，那岂不是可以拿出密钥文件和配置等，在Linux或者OSX上玩？&lt;/p&gt;
&lt;p&gt;到六年级的&lt;a href="http://6nianji.cn/"&gt;官网 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="ipv6" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302145336.png"&gt;&lt;/p&gt;
&lt;p&gt;今晚在&lt;a href="https://v2ex.com/t/220352"&gt;该帖子&lt;/a&gt;中见到网友说 塞尔的ipv6服务实际上包的openvpn，虽然官方只提供了Windows下的安装包，那岂不是可以拿出密钥文件和配置等，在Linux或者OSX上玩？&lt;/p&gt;
&lt;p&gt;到六年级的&lt;a href="http://6nianji.cn/"&gt;官网&lt;/a&gt;注册，购买个人免费套餐，邮箱会收到主题为"New Account Information”的邮件，记下Username（即个人注册的邮箱地址）和官网生成的Password，后续用于登录。&lt;/p&gt;
&lt;p&gt;下载六年级客户端，运行安装，到安装目录（默认为 C:/Program/六年级）可见到一个Link文件夹，其中的部分内容就是我们需要的，拷贝出来备用，dll和exe文件不需要。（注：也可以不拷贝，而复制我下文中提供的）&lt;/p&gt;
&lt;p&gt;以OSX为例，安装openvpn，过程见 &lt;a href="https://fangpsh.com/post/2015/07/30/"&gt;一键连接VPN&lt;/a&gt;，我将Link下的配置拷贝至 &lt;code&gt;/usr/local/etc/openvpn/6nianji&lt;/code&gt; 文件夹中，包含以下文件：&lt;/p&gt;
&lt;p&gt;文件名：ca.crt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-----BEGIN CERTIFICATE-----
MIIDKDCCAhCgAwIBAgIJAOOXJkeu5LvtMA0GCSqGSIb3DQEBCwUAMBIxEDAOBgNV
BAMTB25ld3RlY2gwHhcNMTQxMTI2MDYxMDMwWhcNMjQxMTIzMDYxMDMwWjASMRAw
DgYDVQQDEwduZXd0ZWNoMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
xM1rbqQO9S28ynpPB4Ch78Mb/Olkr+4VWm6X9B/Aqx5x8RgZoldFJsTBTIUHiWk8
lQdtpNU++QdXqqO6RL943lrXHC9qTvxKtp44DpeXETOfozDxexIHc7S1zRTjbmZZ
5yRlLhXPR6dpzH0fLDgINTk341n+jS4zGAoBcseiqlRPBDJQXOmhvWKfGPMD5SeI
fpKsDTcVwLDj1k8rhwy58MwW/5mDtUp0ykgC3N/Crn6QGJ+SZMsNR1rfXPs8qchM
nI/MXJjyDUi+f0PTRH9RsniHOg5p9X2ldXWLBkbASOP7gesokd6pu6TkkKYRM5eQ
/DkyEo+DLShQY67FoAvlOQIDAQABo4GAMH4wHQYDVR0OBBYEFMxRMcMG/1Q85ISL
2VrGk7P0zK+oMEIGA1UdIwQ7MDmAFMxRMcMG/1Q85ISL2VrGk7P0zK+ooRakFDAS
MRAwDgYDVQQDEwduZXd0ZWNoggkA45cmR67ku+0wDAYDVR0TBAUwAwEB/zALBgNV
HQ8EBAMCAQYwDQYJKoZIhvcNAQELBQADggEBAD7iHWOU2vrsT7a8k1F1VDs1dBCh
JEskfeT5U+/asby5J7GTaitqlKMbPqYKxf3VLdlibLgMUW8EpwI0OvYrBJHJGx70
RwW+glO7gqiKmWJcF3DGDHQxcHej4PHKeve+qhtlalTK38GTmI0RFu+lE4Qp1zMA
LcasWST4iboGvaAgOC6ZJe+MsMwV9aTOvMMM4TROh+2ipe6hxtiFH8UBR1WR4gdG
MIiqaZss4capsogETnIeACL+eeOQrVzyG3DEuuy5taw+Zl8XDIRdbOBX8/3oLG0x
o8IHc24ag59MqOttUQU1FFnGwpm5GOAbudMv7v0PNizsfZYdR5ALLjY9n9M=
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文件名：ta.key&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
a7254f6cdfc1425382b939d777174b52
45e2d5253e3688db2a6e5e5b7e996d99
78210eeb95a7ddad7c2176e63b9ed492
db08cdbb276be3e387f8556a8ab555b3
67c2bc9deb086af5df3e60f15b4fd13b
aa94f6f86c6c3147abe9e700f0b0c17f
ba53a933d6926f3a4ac5b104b2eed07c
e009d3b41b1637f638c537d3d6ef9ea7
4c8cd58cff6dfab30384cf9efc23fb3d
b62f77ffbbacd7d6b2c7e21986e69f02
244bac63c94970b097006ac04b62dac0
e974025f7203e9a4fac977f902291234
f405f71f00ac2b6f7ebc41f99b96f8ca
28b3bb7b7f984da1198aafa2e766926d
13674e1e80afdc1d08c7454d42244258
5da5f8cc31eca36999010c14a433f454
-----END OpenVPN Static key V1-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文件名：client.ovpn&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;client
dev tap
proto udp
remote vpnsrv1.cernewtech.com 80
remote vpnsrv2.cernewtech.com 80
resolv-retry infinite
persist-key
persist-tun
ca /usr/local/etc/openvpn/6nianji/ca.crt
comp-lzo
up /usr/local/etc/openvpn/6nianji/tap-up-down.sh
down /usr/local/etc/openvpn/6nianji/tap-up-down.sh
auth-user-pass /usr/local/etc/openvpn/6nianji/pass
verb 3
mute 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;client.ovpn 配置文件中的 auth-user-pass 执行的pass文件主要记录你的个人用户名和密码，用于登录验证，&lt;/p&gt;
&lt;p&gt;文件名：pass #填写上文邮件中的用户名和密码，各一行。你不想每次都手动输入账户和密码吧？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;username 
password 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在我一开始直接拷贝link下的文件过来登录的时候，遇到过 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;write to TUN/TAP : Input/output error (code=5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;的错误，查看了 tap0设备的状态，发现没有up。。囧。网络上找了一个&lt;a href="http://www.mccambridge.org/blog/2007/10/correct-way-to-set-up-openvpn-client-on-mac-os-x/"&gt;脚本&lt;/a&gt;，就是client.ovpn中 up和down指定的脚本，&lt;/p&gt;
&lt;p&gt;文件名：tap-up-down.sh&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# openvpn-tap-up-down.sh&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# A script to be used as an OpenVPN bridged (tap) up/down script on Mac OSX 10.4&lt;/span&gt;
&lt;span class="c1"&gt;# - uses ipconfig to acquire a DHCP lease via the OpenVPN tap interface, and scutil to&lt;/span&gt;
&lt;span class="c1"&gt;#  incorporate the DHCP-supplied DNS configuration&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Use in your OpenVPN config file as follows:&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;#    up  openvpn-tap-up-down.sh&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# - up: openvpn calls the &amp;#39;up&amp;#39; script after the tun/tap interface is created, but before the link&lt;/span&gt;
&lt;span class="c1"&gt;#   to the server is available for use (ditto &amp;#39;up-delay&amp;#39; at least for UDP)&lt;/span&gt;
&lt;span class="c1"&gt;#   - on testing w/ openvpn 2.0.5, and tcpdump on the tap interface as soon as it comes up,&lt;/span&gt;
&lt;span class="c1"&gt;#     packets are queued up on the interface (and not actually sent over the openvpn tunnel)&lt;/span&gt;
&lt;span class="c1"&gt;#     until *after* this script returns; this makes sense: this script could fail in which&lt;/span&gt;
&lt;span class="c1"&gt;#     case the connection is invalid&lt;/span&gt;
&lt;span class="c1"&gt;#     - this means the DHCP acquisition can&amp;#39;t complete until after this script exits&lt;/span&gt;
&lt;span class="c1"&gt;#     - that&amp;#39;s not directly a problem as the OS X DHCP client should do everything we need&lt;/span&gt;
&lt;span class="c1"&gt;#       to make the interface functional, all by itself - *except* for one small thing: as of&lt;/span&gt;
&lt;span class="c1"&gt;#       OS X 10.4.7 the DHCP-acquired DNS information is not &amp;quot;merged&amp;quot; into the System&lt;/span&gt;
&lt;span class="c1"&gt;#       Configuration (OS X bug?)&lt;/span&gt;
&lt;span class="c1"&gt;#       - thus we have a chicken-and-egg situation: we need to manually fixup the DNS config,&lt;/span&gt;
&lt;span class="c1"&gt;#         but can&amp;#39;t until we get the DHCP lease; we won&amp;#39;t get the lease until we this script exits&lt;/span&gt;
&lt;span class="c1"&gt;#       - the solution is to spawn a little &amp;quot;helper&amp;quot; that waits until the lease is acquired,&lt;/span&gt;
&lt;span class="c1"&gt;#         and then does the DNS fixup&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# - down: the only sensible &amp;#39;down&amp;#39; action is to release the DHCP lease (as a courtesy to the&lt;/span&gt;
&lt;span class="c1"&gt;#   DHCP server), alas it&amp;#39;s too late to do this *after* the connection has been shutdown (as&lt;/span&gt;
&lt;span class="c1"&gt;#   of OpenVPN 2.0 there&amp;#39;s no &amp;quot;pre-disconnect&amp;quot; script option; note that both &amp;#39;down&amp;#39; and&lt;/span&gt;
&lt;span class="c1"&gt;#   &amp;#39;down-pre&amp;#39; are called only after the connection to the server is closed (&amp;#39;down-pre&amp;#39; before&lt;/span&gt;
&lt;span class="c1"&gt;#   closing the tun/tap device, &amp;#39;down&amp;#39; after)&lt;/span&gt;
&lt;span class="c1"&gt;#   - OS X automatically cleans up the System Config keys created from ipconfig, but we need to&lt;/span&gt;
&lt;span class="c1"&gt;#     manually remove the DNS fixup&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# 2006-09-21    Ben Low    original&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# 200x-xx-xx    name&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt;: \$dev not defined, exiting&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="c1"&gt;# relevant script_type values are &amp;#39;up&amp;#39; or &amp;#39;down&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$script_type&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;up&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# bring the interface up and set it to DHCP&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# - System Configuration dynamic store will be automatically updated, with the&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;#       State:/Network/Service/DHCP-tap0&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;#   data store created.&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# - the ipconfig man page notes that it should only be used for &amp;quot;test and debug&amp;quot; purposes,&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;#   and that you&amp;#39;re supposed to use the SystemConfiguration APIs to manipulate the network&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;#   configuration&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;#   - alas, there appears to be no CLI utility other than ipconfig&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;DHCP
&lt;span class="w"&gt;     &lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;AUTOMATIC-V6
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# spawn our little DNS-fixerupper&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# whilst ipconfig will have created the neccessary Network Service keys, the DNS&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# settings won&amp;#39;t actually be used by OS X unless the SupplementalMatchDomains key&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# is added&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# ref. &amp;lt;http://lists.apple.com/archives/Macnetworkprog/2005/Jun/msg00011.html&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# - is there a way to extract the domains from the SC dictionary and re-insert&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;#   as SupplementalMatchDomains? i.e. not requiring the ipconfig domain_name call?&lt;/span&gt;

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# - wait until we get a lease before extracting the DNS domain name and merging into SC&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# - despite it&amp;#39;s name, ipconfig waitall doesn&amp;#39;t (but maybe one day it will :-)&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;waitall

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# usually takes at least a few seconds to get a DHCP lease&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;sleep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$domain_name&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-lt&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;sleep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$n&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;expr&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;+&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="nv"&gt;domain_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;getoption&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;domain_name&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;/dev/null&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$domain_name&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;/usr/sbin/scutil&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span class="s"&gt;d.init&lt;/span&gt;
&lt;span class="s"&gt;get State:/Network/Service/DHCP-$dev/DNS&lt;/span&gt;
&lt;span class="s"&gt;d.add SupplementalMatchDomains * $domain_name&lt;/span&gt;
&lt;span class="s"&gt;set State:/Network/Service/DHCP-$dev/DNS&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;

&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;

&lt;span class="w"&gt;   &lt;/span&gt;down&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# for completeness...&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;/usr/bin/id&lt;span class="w"&gt; &lt;/span&gt;-u&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-eq&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NONE
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;*&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt;: invalid script_type&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
&lt;span class="k"&gt;esac&lt;/span&gt;

&lt;span class="c1"&gt;##### FIN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不过如果直接用这哥们提供的脚本，会发现tap0并没有分配到ipv6地址，所以上文中我加上了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;     &lt;/span&gt;/usr/sbin/ipconfig&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$dev&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;AUTOMATIC-V6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候执行openvpn登录，可以会出现以下WARNING：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;WARNING: External program may not be called unless &amp;#39;--script-security 2&amp;#39; or higher is enabled. See --help text or man page for detailed info.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那就按照提供 --script-security 2 选项咯：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;/usr/local/sbin/openvpn&lt;span class="w"&gt;  &lt;/span&gt;--config&lt;span class="w"&gt; &lt;/span&gt;/usr/local/etc/openvpn/6nianji/client.ovpn&lt;span class="w"&gt; &lt;/span&gt;--script-security&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;做个简短的alias吧。&lt;/p&gt;
&lt;p&gt;贴下登录的日志：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;➜  ~  sudo /usr/local/sbin/openvpn  --config /usr/local/etc/openvpn/6nianji/client.ovpn --script-security 2
Sun Sep 13 22:20:34 2015 OpenVPN 2.3.7 x86_64-apple-darwin14.4.0 [SSL (OpenSSL)] [LZO] [MH] [IPv6] built on Jul 30 2015
Sun Sep 13 22:20:34 2015 library versions: OpenSSL 1.0.2d 9 Jul 2015, LZO 2.09
Sun Sep 13 22:20:34 2015 WARNING: file &amp;#39;/usr/local/etc/openvpn/6nianji/pass&amp;#39; is group or others accessible
Sun Sep 13 22:20:34 2015 WARNING: No server certificate verification method has been enabled.  See http://openvpn.net/howto.html#mitm for more info.
Sun Sep 13 22:20:34 2015 NOTE: the current --script-security setting may allow this configuration to call user-defined scripts
Sun Sep 13 22:20:34 2015 Socket Buffers: R=[196724-&amp;gt;65536] S=[9216-&amp;gt;65536]
Sun Sep 13 22:20:34 2015 UDPv4 link local (bound): [undef]
Sun Sep 13 22:20:34 2015 UDPv4 link remote: [AF_INET]121.194.13.130:80
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS: Initial packet from [AF_INET]121.194.13.130:80, sid=8b7c1075 4b39cd60
Sun Sep 13 22:20:35 2015 WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 VERIFY OK: depth=1, CN=newtech
Sun Sep 13 22:20:35 2015 VERIFY OK: depth=0, CN=newtech-BJ
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 TLS Error: local/remote TLS keys are out of sync: [AF_INET]121.194.13.130:80 [0]
Sun Sep 13 22:20:35 2015 Data Channel Encrypt: Cipher &amp;#39;BF-CBC&amp;#39; initialized with 128 bit key
Sun Sep 13 22:20:35 2015 Data Channel Encrypt: Using 160 bit message hash &amp;#39;SHA1&amp;#39; for HMAC authentication
Sun Sep 13 22:20:35 2015 Data Channel Decrypt: Cipher &amp;#39;BF-CBC&amp;#39; initialized with 128 bit key
Sun Sep 13 22:20:35 2015 Data Channel Decrypt: Using 160 bit message hash &amp;#39;SHA1&amp;#39; for HMAC authentication
Sun Sep 13 22:20:35 2015 Control Channel: TLSv1, cipher TLSv1/SSLv3 DHE-RSA-AES256-SHA, 2048 bit RSA
Sun Sep 13 22:20:35 2015 [newtech-BJ] Peer Connection Initiated with [AF_INET]121.194.13.130:80
Sun Sep 13 22:20:37 2015 SENT CONTROL [newtech-BJ]: &amp;#39;PUSH_REQUEST&amp;#39; (status=1)
Sun Sep 13 22:20:37 2015 PUSH: Received control message: &amp;#39;PUSH_REPLY,route-gateway dhcp,ping 10,ping-restart 120&amp;#39;
Sun Sep 13 22:20:37 2015 OPTIONS IMPORT: timers and/or timeouts modified
Sun Sep 13 22:20:37 2015 OPTIONS IMPORT: route-related options modified
Sun Sep 13 22:20:37 2015 TUN/TAP device /dev/tap0 opened
Sun Sep 13 22:20:37 2015 /usr/local/etc/openvpn/6nianji/tap-up-down.sh tap0 1500 1574   init
Sun Sep 13 22:20:37 2015 Initialization Sequence Completed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还有一些错误和警告，不过已经可以正常访问IPv6网站，先忽略了。
Google的各项服务秒开了，可惜六维已经打不开了，听说限制东北大学校内访问了，只能去交大的晨光PT看看。&lt;/p&gt;
&lt;p&gt;周末结束了，感冒还没好，希望明天北京天气依旧好吧。&lt;/p&gt;</content><category term="2015"></category><category term="IPv6"></category></entry><entry><title>一键连接VPN</title><link href="https://fangpsh.github.io/posts/2015/2015-07-30.html" rel="alternate"></link><published>2015-07-30T22:00:00+08:00</published><updated>2015-07-30T22:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-07-30:/posts/2015/2015-07-30.html</id><summary type="html">&lt;p&gt;公司安全的同事最近给OpenVPN加上了基于Google Authenticator的二步验证，密码是「常用密码」+「每次变化的Token」，每次在外边想做事都得打开手机查看Token，输入密码串，安全是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;公司安全的同事最近给OpenVPN加上了基于Google Authenticator的二步验证，密码是「常用密码」+「每次变化的Token」，每次在外边想做事都得打开手机查看Token，输入密码串，安全是安全了，可是不能忍！&lt;/p&gt;
&lt;h2&gt;OSX 生成Token&lt;/h2&gt;
&lt;p&gt;首先想到的是不要每次都打开手机，所以开始寻找Google Authenticator 生成工具的桌面版，果然有很多解决方案&lt;a href="http://superuser.com/questions/462478/is-there-a-google-authenticator-desktop-client"&gt;Is there a Google Authenticator desktop client?&lt;/a&gt;, 有Web版的、Java版的，不过最高效的当然是命令行版&lt;a href="http://www.nongnu.org/oath-toolkit/"&gt;oathtool&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;安装oath-toolkit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;brew install oath-toolkit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个shell脚本，拷贝到 /usr/local/bin/，加上可执行权限:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c1"&gt;#fork from http://superuser.com/questions/462478/is-there-a-google-authenticator-desktop-client , by Peter Beckman&lt;/span&gt;

&lt;span class="nv"&gt;scriptname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;basename&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$scriptname&lt;/span&gt;&lt;span class="s2"&gt;: Service Name Req&amp;#39;d&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Usage:&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;   otp google&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Configuration: &lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/.otpkeys&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Format: name=key&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="nv"&gt;otpkey&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;^&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;/.otpkeys&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="s2"&gt;&amp;quot;=&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;s/ //g&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$otpkey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$scriptname&lt;/span&gt;&lt;span class="s2"&gt;: Bad Service Name&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="nv"&gt;token&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;/usr/local/bin/oathtool&lt;span class="w"&gt; &lt;/span&gt;--totp&lt;span class="w"&gt; &lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$otpkey&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$token&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$token&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;/usr/bin/pbcopy&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;#自动拷贝至剪贴板&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;!-- more --&gt;
&lt;p&gt;创建$HOME/.otpkeys 文件，输入Token生成码，格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;格式：「名称」=「生成码」
例：google=UKPPIDEALLKPYTT9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，打开终端，执行 &lt;code&gt;[脚本名] [名称]&lt;/code&gt; 试一试,例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; ~  which oath
/usr/local/bin/oath
 ~  cat ~/.otpkeys
google=UKPPIDEALLKPYTT9
 ~  oath google
123456
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外按下 Command键+V 试一试，爽到不行，pbcopy真是个伟大的命令。&lt;/p&gt;
&lt;h2&gt;自动连接VPN&lt;/h2&gt;
&lt;p&gt;自动生成Token复制到剪贴板是方便了一点，不过想着每次还得自己打开客户端--「Tunnelblick」手动输入太烦。
安装OpenVPN：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;brew install Caskroom/cask/tuntap #先安装这货
brew install openvpn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装完成后拷贝OpenVPN的配置文件至 &lt;code&gt;/usr/local/etc/openvpn&lt;/code&gt;目录（不放这个目录也行。。反正是手动指定的），
例： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#/usr/local/etc/openvpn/client.ovpn
...
remote vpn.google.com 1234
...
ca /usr/local/etc/openvpn/ca.crt
cert /usr/local/etc/openvpn/client1.crt
key /usr/local/etc/openvpn/client1.key
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;记得上面的&lt;code&gt;ca&lt;/code&gt;，&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;cert&lt;/code&gt;几个要写绝对路径，即使和openvpn的配置文件在同一目录下。&lt;br&gt;
好了，执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /usr/local/sbin/openvpn  --config /usr/local/etc/openvpn/client.ovpn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;试一试，输入帐号和密码，没问题的话会看到连接成功，下发的路由等等。  &lt;/p&gt;
&lt;p&gt;连接成功之后尝试把前面几步输入的操作用脚本搞定，祭出老牌神器--[expect]。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/expect&lt;/span&gt;

&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;username&lt;span class="w"&gt; &lt;/span&gt;「你的用户名」
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;passwd&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sh&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;「你的密码」&amp;quot;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;「上面一步生成Token你的脚本的绝对路径」&lt;span class="w"&gt; &lt;/span&gt;「&lt;span class="nv"&gt;$HOME&lt;/span&gt;/.otpkeys中对应的条目名称」&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt;
&lt;span class="c1"&gt;#例：set passwd [exec sh -c {echo &amp;quot;helloworld&amp;quot;`/usr/local/bin/oath google`}]&lt;/span&gt;
spawn&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;/usr/local/sbin/openvpn&lt;span class="w"&gt;  &lt;/span&gt;--config&lt;span class="w"&gt; &lt;/span&gt;/usr/local/etc/openvpn/「OpenVPN配置文件」
&lt;span class="c1"&gt;#例：spawn sudo /usr/local/sbin/openvpn  --config /usr/local/etc/openvpn/client.ovpn&lt;/span&gt;
expect&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Enter Auth Username:&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;send&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$username&lt;/span&gt;&lt;span class="s2"&gt;\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
expect&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Enter Auth Password:&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;send&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$passwd&lt;/span&gt;&lt;span class="s2"&gt;\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;

interact
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;保存上面的脚本到一个你觉得方便运行的地方，爽到不行不行的。不喜欢expect脚本的，可以用openvpn的 'auth-user-pass-verify' 选项来达到同样的目的。&lt;/p&gt;
&lt;h3&gt;openconnect&lt;/h3&gt;
&lt;p&gt;如果用的是OpenConnect的话，使用下列命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;brew install Caskroom/cask/tuntap
brew install openconnect
echo &amp;quot;Password&amp;quot;`oath google`  |sudo openconnect --user=USERNAME --passwd-on-stdin   vpn.google.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2015"></category><category term="shell"></category><category term="openvpn"></category></entry><entry><title>cronic脚本修正</title><link href="https://fangpsh.github.io/posts/2015/2015-07-13.html" rel="alternate"></link><published>2015-07-13T00:00:00+08:00</published><updated>2015-07-13T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-07-13:/posts/2015/2015-07-13.html</id><summary type="html">&lt;p&gt;实习期间做的一个东西需要读写控制crontab 的任务，失败需要报警。crontab本身有报警，但是非常不友好，例如cron job如果有任何输出（标准输出或者标准错误输出 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;实习期间做的一个东西需要读写控制crontab 的任务，失败需要报警。crontab本身有报警，但是非常不友好，例如cron job如果有任何输出（标准输出或者标准错误输出），都会发送邮件通知，并且还需要在每台机器上配置smtp，非常麻烦。所以想着就在前面直接套了个脚本，如果任务异常，用curl调一下远程服务的api发送邮件即可。&lt;/p&gt;
&lt;p&gt;找到这样一份shell脚本-- &lt;a href="http://habilis.net/cronic/"&gt;Cronic&lt;/a&gt;，不过这份脚本不满足一些需求，并在部署测试的时候遇到一些bug，修正如下。&lt;/p&gt;
&lt;p&gt;上文脚本链接中的例子是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 1 * * * cronic backup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;backup&lt;/code&gt;指的是&lt;strong&gt;一条&lt;/strong&gt;命令，不能使用组合的命令，不然会出现意想不到的事情。例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;30 23 * * * cronic cd /named/zone_bak  &amp;amp;&amp;amp; find ./ -maxdepth 1 -mtime +2 | xargs -i rm -rf {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果用root 用户执行这个任务，将直接导致 /root下两天前的所有文件被删。。至于为什么，看原来脚本的写法就知道了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;$@&amp;quot; &amp;gt;$OUT 2&amp;gt;$TRACE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解决方法是把cron job都写成一个脚本，然后 &lt;code&gt;cronic command&lt;/code&gt; 来调用，但是开发同学肯定不爽，SA也不爽。&lt;br&gt;
那就加单引号吧，bash脚本中加了单引号的所有特殊字符不会被展开，当然command里面的单引号得用转义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cronic &amp;#39;command&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原来脚本中执行命令的部分使用&lt;code&gt;eval&lt;/code&gt;改写，顺带解决下重定向输出的bug（想想如果command中已经包含了重定向的操作，会发生什么奇怪的事情，2333）：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; eval &amp;quot;(&amp;quot;$@&amp;quot;)&amp;quot; &amp;gt;$OUT 2&amp;gt;$TRACE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整脚本见 &lt;a href="https://gist.github.com/fangpsh/688b56c029147f44d879"&gt;cronic.sh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外有一个Python版本的，见 &lt;a href="http://www.zlovezl.cn/articles/pycronic-makes-crontab-emails-painless/"&gt;pycronic: 使crontab的报警更无痛&lt;/a&gt;。&lt;/p&gt;</content><category term="2015"></category><category term="crontab"></category><category term="cronic"></category><category term="bash"></category></entry><entry><title>面向网页工程师与网站管理员的Web缓存教程</title><link href="https://fangpsh.github.io/posts/2015/2015-04-06.html" rel="alternate"></link><published>2015-04-06T18:00:00+08:00</published><updated>2015-04-06T18:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-04-06:/posts/2015/2015-04-06.html</id><summary type="html">&lt;p&gt;这是一篇知识性的文档。尽管是技术性文章，但是本文试图让相关的概念更容易被理解，及更容易被应用到实际场景中去 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是一篇知识性的文档。尽管是技术性文章，但是本文试图让相关的概念更容易被理解，及更容易被应用到实际场景中去。正因如此，为了更加简明，某些原理方面的东西在文中被简化或省略了。如果你对这些细节部分感兴趣，请深入阅读文末的&lt;a href="#11-参考文档和更多信息"&gt;参考文档和更多信息&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;1.什么是Web缓存？为什么人们使用它？&lt;/h2&gt;
&lt;p&gt;Web缓存位于一个或多个Web服务器（即源服务器）和一个或多个客户端之间，监视着进入的请求，保存着服务器响应的内容（例如HTML页面、图片和文件（统称为代表））的代表。然后，当下一个同样URL的请求到来时，它可以使用保存的内容响应请求，而不是向源服务器再次请求。&lt;/p&gt;
&lt;p&gt;使用Web缓存的两大主要理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降低响应延时&lt;/strong&gt;：因为请求被缓存（离客户端更近）响应而不是源服务器，可以花更少的时间得到服务文件并渲染展示。这让网页看起来响应更迅速。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低网络流量&lt;/strong&gt;：因为代表文件被重用，这将降低客户端所用的带宽总量。这也将为按流量计费的客户端节省资费，和保持更低的带宽以及让带宽更容易管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.Web缓存类型&lt;/h2&gt;
&lt;h3&gt;2.1 浏览器缓存&lt;/h3&gt;
&lt;p&gt;如果你查看任何一款现代浏览器（例如 Internet Explorer, Safari 或 Mozilla）的首选项，可能会注意到一项叫“缓存”的设置，它可以在你的计算机上设置一块硬盘空间用于存储你浏览器过的网页的代表文件。浏览器缓存依照非常简单的规则进行运作：在同一个用户会话中（即当前使用浏览器没有关闭前）会检查并确保存储的代表文件是最新的。  &lt;/p&gt;
&lt;p&gt;当用户单击浏览器的‘返回’按钮或者点击某个浏览过的页面链接时，浏览器缓存特别有用。另外，如果你在你的网站中使用相关的导航图片，这些图片的访问请求可以从用户浏览器缓存中及时得到响应。&lt;/p&gt;
&lt;h3&gt;2.2 代理缓存&lt;/h3&gt;
&lt;p&gt;Web代理缓存依据同样的原理工作，只是规模更大。代理服务器以同样的方式为成千上万的用户服务。大公司和网络服务提供商（ISP）们经常将代理服务器部署在它们的防火墙上，或者使用独立的设备（也称为中介服务器）。&lt;/p&gt;
&lt;p&gt;由于代理服务器既不是客户端也不是源服务器的一部分，但是它们位于网络中间，并且请求都必须经由它们发往别处。一种方式是手动设置你的浏览器，告诉它们使用哪些代理。另一种方式是使用拦截代理。拦截代理服务器自己会将所有网页请求转发给后台网络，客户端无需进行设置，甚至对于客户端来说代理服务器是透明的。&lt;/p&gt;
&lt;p&gt;代理缓存是共享缓存的一种：通常有大量的用户使用它而不是单个用户，多次请求的代表文件会被大量重复利用，所以使用代理缓存非常有利于降低响应延时和降低网络流量。&lt;/p&gt;
&lt;h4&gt;网关缓存&lt;/h4&gt;
&lt;p&gt;除了被称为“反向代理缓存”或“代理缓存”，网关缓存也是中介服务器，但是和网络管理员部署代理缓存用于节省带宽不同，网关缓存通常由网站管理员自己部署，为了使网站更容易扩展，有更加可靠和有更好的性能。&lt;/p&gt;
&lt;p&gt;请求可以通过多种方式路由到网关缓存，但是通常是使用某种类型的负载均衡器构建一个或多个网关缓存，从客户端看来就像访问源服务器。&lt;/p&gt;
&lt;p&gt;内容分发网络（Content delivery network，简称CDN）就是在整个或部分互联网上部署网关缓存服务器，并出售缓存服务给感兴趣的网站。&lt;a href="http://www.speedera.com/"&gt;Speedera&lt;/a&gt; 和&lt;a href="http://www.akamai.com/"&gt;Akamai&lt;/a&gt;就是典型的CDN服务提供商。&lt;/p&gt;
&lt;p&gt;这份教程主要还是关注浏览器缓存与代理缓存，虽然有部分内容适合对网关缓存有兴趣的朋友。&lt;/p&gt;
&lt;h2&gt;3.Web缓存对我无害吗？为什么要鼓励使用缓存？&lt;/h2&gt;
&lt;p&gt;Web缓存是互联网上最容易被误解的技术之一，尤其是网站管理员，他们害怕失去对网站的控制权，因为代理缓存可以“隐藏”网站的用户，让看到哪些用户在使用网站这件事变得困难。&lt;/p&gt;
&lt;p&gt;不幸的是，即使不存在Web缓存，互联网上也有太多因素导致网站管理员无法清晰的知晓用户是如何访问他们的网站。如果这对你来说也是一个大问题，那么本教程将会指导你如何在不需要使网站对缓存不友好的情况下，依然可以获得你需要的统计数据。&lt;/p&gt;
&lt;p&gt;另外一个值得让人担忧点是缓存可能会给用户提供过时陈旧的内容，不过本教程将向你展示如何配置你的服务器来控制缓存的内容。&lt;/p&gt;
&lt;p&gt;另一方面，如果你规划好你的网站，缓存可以帮你让网站加载速度更快，并降低服务器负载与网络链路负载。这种差异是惊人的：一个难以被缓存的网站可能得花费数秒加载，而一个利用了缓存特性的网站可以被瞬间加载。用户更享受一个加载迅速的网站，并且日后会更加频繁的访问。&lt;/p&gt;
&lt;p&gt;往这个角度想想：很多大公司花费数百万美元在世界各地建立服务器集群来存储它们的内容代表，为了使它们的用户访问更加迅速。缓存可以为你做同样的事，并且它们离终端用户更近。最重要的是，你不需要为缓存买单。&lt;/p&gt;
&lt;p&gt;事实上，无论你喜欢不喜欢，代理缓存和浏览器缓存都会被使用。如果你不配置你的网站使其被正确缓存，那么它们会默认按照缓存管理员的策略进行缓存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CDN（Content delivery network）是一种有趣的发展，因为不同于大多数代理缓存，CDN的网关缓存只缓存乐意被缓存的网站，所以不存在上文提到的问题。然而，当你使用CDN时还是不得不考虑下游的代理缓存与浏览器缓存的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;4.Web缓存是如何工作的&lt;/h2&gt;
&lt;p&gt;所有缓存都有一套规则用来判断什么时候使用缓存中的代表（如果代表可用的情况下）来响应请求。一些规则在（HTTP1.0 和HTTP1.1）协议中有定义，另外一些规则则由缓存的管理员（浏览器缓存的用户或者代理服务器的管理员）设置。  &lt;/p&gt;
&lt;p&gt;一般来说，缓存遵循常见的规则（不要担心你不理解细节，细节内容会在下文解释）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果响应头信息告诉缓存不要进行保留，缓存即不会保留；&lt;/li&gt;
&lt;li&gt;如果请求是需要认证的或者加密的（HTTPs），也不会被缓存；&lt;/li&gt;
&lt;li&gt;一个缓存代表会被认为是新的（换言之，不检查源服务器，代表可以被直接发送给客户端），如果：&lt;/li&gt;
&lt;li&gt;头信息中设置了一个过期时间或寿命控制，并且代表根据设置是在新鲜期中；&lt;/li&gt;
&lt;li&gt;缓存近期访问过该代表，并且代表最近的修改时间是很久之前。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新鲜的代表将直接从缓存中取出用于响应请求，在没有检查源服务器的情况下。
4. 如果代表过旧了，缓存将会请求源服务器校验代表，或者请求源服务器告知该代表是否仍旧可用；
5. 在某些情况下，例如当断开网络连接时，缓存可以使用过期的代表响应请求而不需要检查源服务器。&lt;/p&gt;
&lt;p&gt;如果请求的响应中不存在验证器（ETag或Last-Modify头信息），并且它没有其他任何明确的更新信息，通常情况下，但不总是，该请求响应将被认为是不可缓存的。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;&lt;em&gt;新鲜度&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;校验&lt;/em&gt;&lt;/strong&gt;是缓存管理内容的最要依据。一个缓存中的新鲜的代表是可用的，而一个缓存校验器也可以避免将一个没有变化的代表从源服务器传输一遍。&lt;/p&gt;
&lt;h2&gt;5.如何控制缓存文件或不缓存文件&lt;/h2&gt;
&lt;p&gt;网页设计师和网站管理员可以使用多种工具来使调整缓存对待网站的方式，这也许需要你亲手配置你的服务器，但取得的结果绝对值得你动手。关于如何使用这些工具配置你的服务器，请查看下文【实现注意事项】章节。&lt;/p&gt;
&lt;h3&gt;5.1 HTML Meta标签 vs. HTTP头信息&lt;/h3&gt;
&lt;p&gt;HTML编写者可以在文档的\&amp;lt;HEAD&amp;gt;区加入描述文档属性的标签。这些Meta标签常常用于标记一个文档不可缓存，或者在某个确定时刻过期。&lt;/p&gt;
&lt;p&gt;Meta标签很容易使用，但是效率不高。这是因为只有少数的浏览器缓存支持这些标签，代理缓存不支持（它们几乎不会读取文档中的HTML内容）。有时会为了让页面保持新鲜而在Web页面中放上'Pragma:no-cache'这个Meta标签，这是没有必要的。&lt;/p&gt;
&lt;p&gt;另外一方面，HTTP 头可以让你对浏览器缓存和代理缓存如何处理代表文件做更多的控制。在HTML文件见不到它们，通常由Web服务器自动生成。然而，根据使用的Web服务器不同，你可以做不同程度的控制。在下面的章节中，你将看到一些有趣的HTTP头信息，和如何在你的网站上进行应用它们。&lt;/p&gt;
&lt;p&gt;HTTP头信息由Web服务器在发送HTML之前发送，并且只能浏览器和每一个中间缓存服务器看到。典型的HTTP1.1 协议的响应头可能如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Fri, 30 Oct 1998 13:19:41 GMT
Server: Apache/1.3.3 (Unix)
Cache-Control: max-age=3600, must-revalidate
Expires: Fri, 30 Oct 1998 14:19:41 GMT
Last-Modified: Mon, 29 Jun 1998 02:28:12 GMT
ETag: &amp;quot;3e86-410-3596fbbc&amp;quot;
Content-Length: 1040
Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这些头信息之后，以一行空格分隔，紧跟着是HTML内容。关于如何设置HTTP头信息请查看【实现注意事项】章节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你的网站是托管在ISP机房中，它们不会允许你设置HTTP头信息（例如Expires和Cache-Control），大声的抱怨吧：它们是你工作的必要工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;5.2 Pragma HTTP头信息（为何它们不起作用？）&lt;/h3&gt;
&lt;p&gt;许多人认为设置了一个 ‘Pragma: no-cache’的头信息可以让代表不被缓存。实际上这是不对的：HTTP规范中没有任何关于设置Pragma 响应头信息的指导；相反，对Pragma请求头（从浏览器发送给服务器的头信息）进行了讨论。虽然少数缓存会遵循这个头信息，大部分不会，但是也不会有任何效果。用下文的头信息来替代Pragma吧。&lt;/p&gt;
&lt;h3&gt;5.3 使用Expires HTTP头信息来控制更新&lt;/h3&gt;
&lt;p&gt;Exipres 头信息是管理缓存最基础的方式：它会告诉缓存代表文件在多长时间内是新鲜的。在这个时间之后，缓存将总会访问源服务器检查文件是否更改。几乎所有的缓存都支持Expires头信息。&lt;/p&gt;
&lt;p&gt;大多数Web服务器都允许你通过多种方式设置Expires响应头信息。通常，它们允许设置一个准确的过期时刻，基于客户端最近一次访问代表的时间，或者基于服务器上文档最后一次改变的时间（最新修改时间，last modification time）。&lt;/p&gt;
&lt;p&gt;Exipres 头信息对于设置静态图片缓存（例如导航栏或者按钮的图片）十分有用。因为这些文件不经常变动，你可以给它们设置一个特别长的过期时间，从而使你的网站更快得响应用户。它们对于控制规律变化的页面的缓存也非常有用。举个例子，如果你在每天早上六点更新一个页面，你可以设置对应代表的超时时间在这个点，从而让缓存知道什么时刻它们需要一份新的拷贝，而不必让用户点击“重载”按钮。&lt;/p&gt;
&lt;p&gt;Expires 头信息的值只能是HTTP格式的日期，其他的值都会被解析成‘过去的时刻’，以至于代表都会过期。另外记住HTTP的时间是格林威治时间（GMT），不是本地时间。&lt;br&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Expires: Fri, 30 Oct 1998 14:19:41 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然Expires头信息非常有用，但是它也有一些限制。首先，因为涉及到日期，Web服务器上和缓存上的时钟必须同步。如果它们不同步，将达不到预期的结果，缓存可能错误的认为过期的内容是新鲜的。
另外一个关于Expires的问题是非常容易忘记你曾经为某些内容设置了一个特定的过期时刻。如果你在返回内容时没有更新Expires 时间，那么每个请求都将发回源服务器，将增加负载和响应时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你使用Expires 头信息，确保你的Web服务器的时钟是准确的将非常重要。一个方式是使用网络时间同步协议（NTP），可以向你的系统管理员咨询更多信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;5.4 Cache-Control HTTP头信息&lt;/h3&gt;
&lt;p&gt;HTTP1.1 协议介绍了一组新的头信息，cache-control 响应头信息，让网站发布者可以更全面的控制他们的内容，并解决了Expires头信息的限制。&lt;br&gt;
有用的cache-control响应头信息包括：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;max-age&lt;/strong&gt;=[秒] - 指定代表被视为新鲜的最长时间。类似于Expires，这个参数是指相对于请求时刻的时间间隔，而不是绝对的时刻。[秒]是指从请求开始时刻到你希望缓存依旧保持新鲜的时刻之间的秒数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s-maxage&lt;/strong&gt;=[秒] - 类似于max-age，不过它只应用与共享缓存（例如代理服务器）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt; - 标记认证的请求也可以缓存。通常来说，如果需要HTTP认证，响应内容即为私有的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt; - 允许缓存指定一个用户（例如在浏览器中）存储响应内容。共享缓存（例如代理服务器）可能不可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-cache&lt;/strong&gt; - 强制缓存在每一次释放一个缓存代表前都向源服务器发起请求进行验证。这对确保请求得到认证（和public结合使用）或确保内容新鲜都是非常有用的，并且不需要牺牲使用缓存的所有好处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-store&lt;/strong&gt; - 指示缓存在任何情况下都不要保留代表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;must-revalidate&lt;/strong&gt; - 告知缓存遵循你给出的任何关于代表的新鲜度信息。HTTP协议允许缓存在某些特定情况下返回过期代表。通过指定这个头信息，你可以告知缓存严格遵守你的规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy-revalidate&lt;/strong&gt; - 和 must-revalidate 类型，除了它只作用于代理缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Cache-Control: max-age=3600, must-revalidate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当同时存在cache-control和Expires时，cache-control优先。如果你打算使用cache-control头信息，你应该看一下HTTP1.1协议的这篇不错的文档，见【参考文档和更多信息】节。&lt;/p&gt;
&lt;h3&gt;5.5 验证器与验证&lt;/h3&gt;
&lt;p&gt;在【Web缓存是如何工作的】一节中，我们说过验证是用于当代表变更后服务器和缓存之间的通讯。通过使用它，可以禁止缓存下载整个代表，当他们本地有一份拷贝但不确定拷贝是否新鲜时。&lt;/p&gt;
&lt;p&gt;验证器非常重要，如果有一个不存在，并且没有任何其他新鲜度信息（Expires或者Cache-Control）可用，那么缓存将不会保存任何代表。&lt;/p&gt;
&lt;p&gt;最常见的验证器是文档的最后修改时间，通过Last-Modified头信息传递。当一份缓存有一个包含Last-Modified头信息的代表时，它可以通过发送一个IfModified-Since请求，询问服务器这份缓存在上次浏览之后是否被修改了。&lt;/p&gt;
&lt;p&gt;HTTP1.1中介绍了另外一种称为Etag的验证器。Etag是服务器生成的唯一的标识符，并且每次代表改变时都会变动。因为服务器可以控制如何生成Etag，所以当缓存发送If-None-Match请求时，如果ETag是匹配的，缓存就可以确定代表是相同的。&lt;/p&gt;
&lt;p&gt;几乎所有缓存都使用Last-Modified时间作为验证器，ETag验证器也正在逐渐流行起来。&lt;br&gt;
大部分现代的Web服务器会自动同时生成ETag和Last-Modified头信息来作为静态内容的验证器，你不需要做任何事。然而，它们对于动态内容并不知道如何生成Last-Modified和ETag头信息，见【编写支持缓存的脚本】一节。&lt;/p&gt;
&lt;h2&gt;6.搭建支持缓存的网站的技巧&lt;/h2&gt;
&lt;p&gt;除了使用新鲜读信息和验证器，这儿还有很多方法可以让你的网站对缓存更友好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用统一的URL - 这是缓存的黄金守则。如果对于不同的用户或者来自不同的站点请求返回包含相同内容的不同页面，应该使用相同的URL。这是使你的网站对缓存友好的最简单、最有效的方法。例如，如果你在HTML页面中使用‘/index.html’作为一个引用，那么就始终使用这个URL。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用一个共用的&lt;/strong&gt;图片或者其他元素的库，在不同的地方引用它们。&lt;/li&gt;
&lt;li&gt;通过设置一个cache-contrl：max-age为很大的值，&lt;strong&gt;让缓存服务器存储那些不常变动的图片和页面&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;通过指定一个合适的max-age或过期时间，&lt;strong&gt;让缓存服务器识别规律更新的页面&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果一个资源（特别是下载文件）变动了，修改它的名称&lt;/strong&gt;。通过这种方式，你可以使其在未来很长一段时间内不过期，并且仍然确保响应的是正确的版本。不过链接到下载文件的页面需要设置一个较短的过期时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非必要的情况下不要修改文件&lt;/strong&gt;。如果你这么做了，所有的文件都会有一个不正确的新的Last-Modified日期。例如，当你更新你的网站时，不应该拷贝整个网站，只上传你修改过的文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只在必要的地方使用cookies&lt;/strong&gt; - cookies非常难被缓存，并且在大部分情况下是不需要的。如果你一定要使用cookie，只限在动态页面中使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少使用SSL &lt;/strong&gt;- 因为加密的页面不能被共享缓存所存储，所以在不得已的时候再使用它们，并且减少在SSL 页面上使用图片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;a href="https://redbot.org/"&gt;REDbot&lt;/a&gt;检查你的页面&lt;/strong&gt; - 它可以帮助你实践很多本教程内的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7.编写支持缓存的脚本&lt;/h2&gt;
&lt;p&gt;默认情况下，大部分脚本不会返回验证器（Last-Modified 或ETag响应头信息）或者新鲜度信息（Expires或Cache-Control）。有些脚本确实是动态的（意味着每次请求它们都会返回不同的响应内容），但是大部分（像搜索引擎和数据引擎网站）可以从设置为缓存友好中获益。&lt;/p&gt;
&lt;p&gt;一般来说，如果一份脚本在一段时间内（无论是几分钟或者几天），对于同样的请求生成的输出是重复的，那么它就是可以被缓存的。如果脚本的输出内容只随URL变化而变化，那么它也是可以被缓存的，但如果输出内容依赖cookies，认证信息或者其他外部其他条件，那么可能不能被缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使一份脚本对缓存友好化的最好方式是（同时也改善性能）的方式是在内容改变时导出成静态文件。Web服务器可以对待这些静态文件例如其他Web页面，生成和使用验证器，会让你更加方便。记住只在变化时写文件，这样可让Last-Modified时间受保护。&lt;/li&gt;
&lt;li&gt;另外一种使脚本对缓存友好化的有局限性的方式是在对未来一段实际时间内设置一个相对寿命的头信息。虽然使用Expires可以实现，不过更容易的方式是使用Cache-Control：max-age，它会在请求之后让缓存在一段时间内保持新鲜。&lt;/li&gt;
&lt;li&gt;如果以上你都做不到，你将需要让脚本生成一个验证器，并响应If-Modified 和/或 If-None-Match请求。这些可以在解析HTTP头信息时完成，并在符合条件的情况下返回304 Not Modified。不幸的是，这不是一个简单的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他技巧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不要使用POST&lt;/strong&gt;除非是适合的。POST方法请求的响应内容不会被大多数缓存保存；如果你通过路径或者查询（通过GET请求）发送信息，缓存服务器可以存储信息供日后使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要在URL中嵌入用户特有的信息&lt;/strong&gt;，除非生成的内容对用户是完全唯一的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要统计一个用户来着来自同一个主机的请求&lt;/strong&gt;，因为缓存常常是共同工作的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成Conten-Length响应头信息&lt;/strong&gt;。这很容易做到，并且这将允许你的脚本的响应内容用于持久连接。这将允许客户端可以在一个TCP/IP连接中请求多个代表，而不是每个请求都建立一个TCP/IP连接。这会使你的网站看起来更快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多细节信息请看【实现注意事项】。&lt;/p&gt;
&lt;h2&gt;8.常见问题解答&lt;/h2&gt;
&lt;h3&gt;使网站可缓存的的重点是什么？&lt;/h3&gt;
&lt;p&gt;好的策略是找出那些最受欢迎的，且最大的代表文件（特别是图片），将它们事先缓存起来。&lt;/p&gt;
&lt;h3&gt;我如何才能使用缓存服务器让我的页面尽可能的快？&lt;/h3&gt;
&lt;p&gt;大多数缓存的代表文件会设置一个很长的新鲜时间。验证器可以帮助降低检查代表文件的时间，但是缓存还是得和源服务器通讯一次以确定它是新鲜的。如果缓存已知它是新鲜的，代表文件可以被直接服务。&lt;/p&gt;
&lt;h3&gt;我明白缓存是不错，但是我不得不统计有多少人访问我的页面！&lt;/h3&gt;
&lt;p&gt;如果你一定要知道一个页面的访问次数，选择页面上的「一个」小元素（或者页面本身），并通过给它设置一个合适的头信息，让它不被缓存。例如，你可以在每个页面上引用一个1x1 的透明的不会被缓存的图片。引用头信息会包含哪个个页面访问了它的信息。&lt;/p&gt;
&lt;p&gt;注意这并不会给予你真实和准确的用户统计信息，并且这对你的用户和网络都是不友好的。它不会消耗不必要的网络带宽，强迫人们等待不被缓存的内容下载完毕。更多信息，请查看【参考文档和更多信息】中的「关于非连续性访问的统计」。&lt;/p&gt;
&lt;h3&gt;我如何能看到一个代表的文件的HTTP头信息？&lt;/h3&gt;
&lt;p&gt;多数Web浏览器可以让你在‘页面信息’或者类似的界面看到Expires和last-Modified 头信息。如果可以的话，你会得到页面的菜单和页面相关的所有代表文件（像图片等），包括它们的详细信息。&lt;/p&gt;
&lt;p&gt;要查看一个代表文件的全部头信息，你可以使用Telnet 客户端手动连接Web服务器。&lt;/p&gt;
&lt;p&gt;要这样做，你可能需要在一个字段中指定端口（默认是80），或者你可能需要连接www.example.com:80 或www.example.com 80 (注意空格)。参考下你的Telnet客户端的文档。&lt;/p&gt;
&lt;p&gt;一旦你打开了网站的一个连接，输入一个代表文件的请求。例如，如果你想要看 http://www.example.com/foo.html 的头信息，连接 www.example.com，端口80，并输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GET /foo.html HTTP/1.1 [回车]
Host: www.example.com [回车][回车]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次你看到「回车」按下回车键，确保在最后的时候你按了两次。将会打印头信息，接着是完整的页面文件。如果只想看到头信息，将&lt;code&gt;GET&lt;/code&gt; 换成 &lt;code&gt;HEAD&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;我的页面是受密码保护的，代理缓存会如何处理它们？&lt;/h3&gt;
&lt;p&gt;默认情况下，受HTTP认证保护的页面都认为是私有的，它们不会被共享缓存保存。然而，你可以用一个Cache-Control：pbulic header 头信息使认证页面公开。HTTP1.1兼容的缓存会允许它们被缓存。&lt;/p&gt;
&lt;p&gt;如果你喜欢这类页面被缓存，但是对每个用户仍然要认证才能访问，可以结合Cache-Control：public 和no-cache头信息。这将会告知缓存在释放代表文件之前确认新的客户端必须提交认证信息给服务器。设置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Cache-Control: public, no-cache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无论是否做到这点，最好减少认证的使用。例如，如果你的图片不是敏感信息，将它们放在一个单独的目录，并配置你的服务器不对它们进行强制认证。通过这种方式，这些图片将可以被正常缓存。&lt;/p&gt;
&lt;h3&gt;如果用户通过缓存访问我的网站我是否要担心安全性？&lt;/h3&gt;
&lt;p&gt;SSL 页面不会被代理缓存服务器所缓存（或解密），所以你不必担心这个问题。不过，因为缓存服务器会存储经过它们的非SSL请求和URL，你应该意识到对于不安全的站点，不道德的缓存服务器管理员可能收集它们用户的信息，特别是通过URL。&lt;/p&gt;
&lt;p&gt;实际上，在你的服务器和你的客户端之间的任何网络管理员都可以收集这类信息。特别是当CGI脚本把用户名和密码放在它的URL时，这会很容易让他人找到此类信息并利用从而登录。&lt;/p&gt;
&lt;p&gt;如果你了解一般的Web安全问题，你不会对代理缓存服务器感到惊奇。&lt;/p&gt;
&lt;h3&gt;我在寻找一个集成Web发布的解决方案。哪些是支持缓存的？&lt;/h3&gt;
&lt;p&gt;差异很大，一般来说，越复杂的解决方案，越难被缓存。最糟糕的方案是那些动态生成所有内容，并且不提供验证器的，它们可能完全不会被缓存。向你的供应商的技术人员了解一下，并参考下下文的「实现注意事项」。&lt;/p&gt;
&lt;h3&gt;我的图片是一个月后过期，但是我需要它们立刻更新！&lt;/h3&gt;
&lt;p&gt;Expires头信息无法避开，除非缓存（浏览器或者代理服务器）空间不足才会删除代表文件，缓存副本会一直被使用直到过期。&lt;/p&gt;
&lt;p&gt;最有效的方式是修改它们的链接。这样，完全新的代表文件会从源服务器被加载。记住，任何引用这些代表文件的页面也会被缓存。因此，最好让静态图片或者其他类似的代表文件被缓存，同时严格控制引用它们的HTML页面。&lt;/p&gt;
&lt;p&gt;如果你希望重载从指定缓存加载一个代表文件，你可以在使用缓存的时候强制重载（在FIrefox中，按住shirt键的时候按下‘重载’键可以做到，通过发起一个Pragma：no-cache头信息的请求）。或者，你可以让缓存服务器管理员在他们的节点中删除代表文件。&lt;/p&gt;
&lt;h3&gt;我运行一个Web托管服务，我怎么样才能让用户发布对缓存友好的页面？&lt;/h3&gt;
&lt;p&gt;如果你使用Apache，考虑允许他们使用.htaccess 文件并提供相应文档。&lt;/p&gt;
&lt;p&gt;另外，你可以在各个虚拟主机里预先创建缓存各类元素的缓存区。例如，你可以指定一个目录 /cache-1m 用于缓存访问之后的内容，缓存一个月。一个 /no-cache 区用于提供不会被缓存的，通过头信息告知缓存不存储代表文件。&lt;/p&gt;
&lt;p&gt;无论你是否能做到，最好让你最大的客户使用上缓存。对于大网站这可以大量节约成本（带宽和服务器负载方面）。&lt;/p&gt;
&lt;h3&gt;我已经标记了我的页面是可缓存的，但是我的浏览器每次都会向源服务器发起请求。我如何才能强制缓存保存这些页面的代表文件？&lt;/h3&gt;
&lt;p&gt;缓存不需要保存代表文件和重用它。它们只会被要求不要保存和使用代表文件，在某些情况下。所有的缓存都是基于代表文件的大小（例如图片和html页面），以及如果保存它们本地还能剩余多少磁盘空间等来做决定。你的页面相比更热门或者更大的代表文件，并不值得缓存。&lt;/p&gt;
&lt;p&gt;一些缓存服务器允许它们的管理员优先考虑哪些类型的代表文件被保存，一些代表文件会被永久缓存，所以它们总是可用的。&lt;/p&gt;
&lt;h2&gt;9.实现注意事项-Web服务器&lt;/h2&gt;
&lt;p&gt;一般来说，无论什么Web服务器，最好使用最新的版本来部署。它们不仅包含更多与缓存友好的特性，而且新版本通常在安全和性能方面也会有改善。&lt;/p&gt;
&lt;h3&gt;Apache HTTP Server&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.apache.org/"&gt;Apache&lt;/a&gt; 使用可选的模块来引入头信息，包括Expires和Cache-Control。这两个模块在1.2 或高的版本中都可用。&lt;/p&gt;
&lt;p&gt;这些模块需要内置到Apache；虽然它们已经包含在发布的版本中，但是默认没有启用。为了找出你服务器上启用了哪些模块，找到httpd二进制文件，运行 &lt;code&gt;httpd -l&lt;/code&gt;；这应该能打印出可用模块的列表（注意这只列出了编译进apache的模块；在最新版本的apache上，使用&lt;code&gt;httpd -M&lt;/code&gt;也包含动态加载的模块 ）。这些模块中我们要找的是expires_module 和 headers_module。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果它们是不可用的，并且你有管理员权限，你可以重新编译Apache来引入它们。这可以通过反注释Configuration文件中的对应行，或者使用编译选项&lt;code&gt;-enable-module=expires&lt;/code&gt;和 &lt;code&gt;-enable-module=headers&lt;/code&gt;(1.3或更高版本)配置做到。参考Apache发行版中的INSTALL 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦你有了一个有着合适模块的Apache，你可以在.htaccess 文件或者服务器的access.conf文件中使用mod_expires来指定代表文件什么时候过期，你可以指定从访问时间或者修改时间开始计算的的过期时间，应用到某个类型的文件或者按照默认设置。如果你遇到困难，可以阅读&lt;a href="http://www.apache.org/docs/mod/mod_expires.html"&gt;模块文档&lt;/a&gt;获取更多信息，或者和你附近的Apache大师聊一聊。&lt;/p&gt;
&lt;p&gt;为了使用Cache-Control 头信息，你将需要使用mod_headers模块，它可以使你为一个资源指定任意HTTP 头信息。参考 &lt;a href="http://www.apache.org/docs/mod/mod_headers.html"&gt;mode_headers 文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这儿有一个例子，关于如何使用头信息的示范操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.htaccess 文件允许网站发布者使用通常只能在配置文件中找到的命令。它们会影响到目录的内容和它们子目录的内容。和你的服务器管理员了解下它们是否被启用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;### 激活 mod_expires 
ExpiresActive On
### .gif 文件在访问一个月之后过期
ExpiresByType image/gif A2592000
### 任何文件在最后一次修改的一天后过期
###（此处使用了Alternative 语法）
ExpiresDefault &amp;quot;modification plus 1 day&amp;quot;
### 对 index.html 文件应用一个Cache-Control 头信息
&amp;lt;Files index.html&amp;gt;
Header append Cache-Control &amp;quot;public, must-revalidate&amp;quot;
&amp;lt;/Files&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;注意：mod_expires会在合适的情况下自动生成和插入一个Cache-Control:max-age 头信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache 2的配置和1.3非常相似，参考 2.2&lt;a href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html"&gt;mod_expires&lt;/a&gt;和&lt;a href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html"&gt;mod_headers&lt;/a&gt;文档获取更多信息。&lt;/p&gt;
&lt;h3&gt;Microsoft IIS&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.microsoft.com/"&gt;微软&lt;/a&gt;的 IIS 可以通过非常灵活的方式，非常容易的设置头信息。注意这这在IIS 4或者更高版本可行，并且只能运行在NT服务器上。&lt;/p&gt;
&lt;p&gt;为一个网站的一块区域指定头信息，先在 &lt;code&gt;Administration Tools&lt;/code&gt; 的界面中选中，然后设置它的属性。在选中&lt;code&gt;HTTP Headers&lt;/code&gt;项之后，你应该可以看到两块有趣的区域：&lt;code&gt;Enable Content Expiration&lt;/code&gt;和&lt;code&gt;Custom HTTP headers&lt;/code&gt;。前者会自动配置，后者可以用于配置Cache-Control头信息。&lt;/p&gt;
&lt;p&gt;可以在&lt;code&gt;Active Server Pages&lt;/code&gt;的ASP章节上参考关于设置头信息的内容，可能也可以通过ISAPI模块设置头信息，细节请参考MSDN。&lt;/p&gt;
&lt;h3&gt;Netscape/iPlanet Enterprise Server&lt;/h3&gt;
&lt;p&gt;随着3.6版本发布，Enterprise服务器不再提供任何明确的方式来设置Expires头信息。然而，它从3.0版本开始已经支持HTTP1.1协议的特性。这意味着 HTTP 1.1缓存（代理服务器或者浏览器）可以使用Cache-Control设置来实现。&lt;/p&gt;
&lt;p&gt;为使用Cache-Control 头信息，在管理员服务器上选择&lt;code&gt;Content Management | Cache Control Directives&lt;/code&gt;。接着，使用&lt;code&gt;Resource Picker&lt;/code&gt;，选择你想要设置头信息的目录。设置完头信息之后，点击&lt;code&gt;OK&lt;/code&gt;。更多信息请参考&lt;a href="http://www.redhat.com/docs/manuals/ent-server/"&gt;NES手册&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;10.实现注意事项-服务器端脚本&lt;/h2&gt;
&lt;p&gt;因为在服务器端的脚本强调的是动态内容，它们不会生成非常容易利于的页面，即使这些内容是可以被缓存的。如果你的内容经常变化，但是不是在每次页面被点击时，那么考虑设置一个Cache-Control: max-age头信息。大多数用户再次访问页面都是在一个较短的时间间隔之后。例如，当用户点击‘返回’按钮，如果没有认证或者更新的内容，他们不得不得等待页面从服务器上重新下载才能看到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一点要记住的是，在你的Web服务器中设置HTTP头信息可能比在脚本语言中更容易。都尝试一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;CGI&lt;/h3&gt;
&lt;p&gt;CGI 脚本是生成内容最流行的方式之一。你可以非常容易的添加HTTP响应头信息，在你发送内容之前。大多数CGI实现都要求你写 Content-Type 头信息。例如，在Perl中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!/usr/bin/perl
print &amp;quot;Content-type: text/html\n&amp;quot;;
print &amp;quot;Expires: Thu, 29 Oct 1998 17:04:19 GMT\n&amp;quot;;
print &amp;quot;\n&amp;quot;;
### the content body follows...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于都是文本信息，你可以非常容易的使用内置函数生成Expires和其他日期相关的头信息。如果你使用Cache-Control: max-age甚至可以更简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;print &amp;quot;Cache-Control: max-age=600\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这会使脚本在请求之后可以被缓存10分钟，所以如果用户点击‘返回’按钮，他们不再会重新提交请求。&lt;/p&gt;
&lt;p&gt;在脚本环境中，CGI规范也允许客户端发送头信息的请求；每个头信息都有一个‘HTTP_’前缀和头信息名称。所以，如果一个客户端发起一个 If-Modified-Since请求，它会显示为&lt;code&gt;HTTP_IF_MODIFIED_SINCE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考&lt;a href="https://www.mnot.net/cgi_buffer/"&gt;cgi_buffer&lt;/a&gt;库，一个自动处理Etag生成和验证，Content-Length生成和对内容进行gzip压缩的库，在Perl和Python CGI 脚本中一行即可引入。Python版本的也可以用于包装任意CGI脚本。&lt;/p&gt;
&lt;h3&gt;Server Side Includes&lt;/h3&gt;
&lt;p&gt;SSI（经常使用.shtml扩展名）是网站发布者最早可以生成动态内容的方式之一。通过在页面中使用特别的标记，可以嵌入有限的HTML脚本。&lt;/p&gt;
&lt;p&gt;大部分SSI的实现无法设置验证器，也就无法被缓存。不过，Apache实现了可以通过对特定文件的组执行权限设置，实现允许用户设置哪些SSI可以被缓存，结合&lt;code&gt;XbitHack&lt;/code&gt;调整整个目录。更多信息请参考&lt;a href="http://www.apache.org/docs/mod/mod_include.html"&gt;mod_include&lt;/a&gt;文档。&lt;/p&gt;
&lt;h3&gt;PHP&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.php.net/"&gt;PHP&lt;/a&gt;是一个内建在web服务器中的服务器端脚本语言，可以做为HTML嵌入式脚本，很像SSI，不过有更多的选项。PHP可以在各种Web服务器上设置为CGI脚本运行（Unix或Windows），或作为Apache的模块运行；&lt;/p&gt;
&lt;p&gt;默认情况下，PHP生成代表文件没有设置验证器，也就无法缓存。但是，开发者可以通过Header()函数来设置HTTP头信息。&lt;/p&gt;
&lt;p&gt;例如，这些代码会生成一个Cache-Control头信息，也会设置一个3天后过期的Expires头信息；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;?php
 Header(&amp;quot;Cache-Control: must-revalidate&amp;quot;);

 $offset = 60 * 60 * 24 * 3;
 $ExpStr = &amp;quot;Expires: &amp;quot; . gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;, time() + $offset) . &amp;quot; GMT&amp;quot;;
 Header($ExpStr);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;记住，Header()的输出&lt;strong&gt;必须&lt;/strong&gt;先于所有其他HTML的输出。&lt;/p&gt;
&lt;p&gt;正如你看到的，你可以手工为Expires头信息创建HTTP日期；PHP没有为此提供专门的函数（不过新版本已经让这个更容易了，请参考&lt;a href="http://php.net/date"&gt; PHP's date documentation&lt;/a&gt;)。当然，最简单的还是设置Cache-Control: max-age头信息，对于大部分情况都比较适用；&lt;/p&gt;
&lt;p&gt;更多信息，请参考&lt;a href="http://www.php.net/manual/function.header.php3"&gt;e manual entry for header&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;也请参考一下&lt;a href="https://www.mnot.net/cgi_buffer/"&gt;cgi_buffer&lt;/a&gt;库，一个能够自动处理ETag的生成和验证，Content-Length生成和内容的gzip压缩的库，PHP脚本引用只需一行代码。&lt;/p&gt;
&lt;h3&gt;Cold Fusion&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.macromedia.com/software/coldfusion/"&gt;Cold Fusion&lt;/a&gt;由&lt;a href="http://www.macromedia.com/"&gt;Macromedia&lt;/a&gt;开发的一款商业服务端脚本引擎，支持多种Windows，Linux和多种Unix平台上的Web服务器。&lt;/p&gt;
&lt;p&gt;Cold Fusion让设置任意HTTP头信息相当容易，通过&lt;a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00000270.htm"&gt;CFHEADER&lt;/a&gt;标签。可惜的是：以下设置Expires头信息的例子有些容易误导。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;CFHEADER NAME=&amp;quot;Expires&amp;quot; VALUE=&amp;quot;#Now()#&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它不是像你认为你的那样生效，因为时间（这个例子中是请求发起的时间）并不会被转换成一个符合HTTP的时间；相反的，它只打印出代表文件的Cold fusion日期/时间对象。大多数客户端会忽略这样一个值，或者将其转换成默认值，例如1970年1月1日。&lt;/p&gt;
&lt;p&gt;然而，Cold Fusion提供了一套日期格式化函数来完成这项工作： &lt;a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00000483.htm"&gt;GetHttpTimeSTring&lt;/a&gt;。 结合DateAdd函数，很容易设置Expires时间了.这里,我们设置一个头信息声明代表文件在1个月以后过期；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;cfheader name=&amp;quot;Expires&amp;quot; 
  value=&amp;quot;#GetHttpTimeString(DateAdd(&amp;#39;m&amp;#39;, 1, Now()))#&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你也可以使用CFHEADER标签来设置Cache-Control: max-age等其他头信息；&lt;/p&gt;
&lt;p&gt;记住Web服务器的头信息也会通过Cold Fusion的一些部署方式传递(例如CGI）；检查你的服务器设置，确定你是否可以使用它，并通过在Web服务器上设置头信息来代替Cold Fusion。 &lt;/p&gt;
&lt;h3&gt;ASP and ASP.NET&lt;/h3&gt;
&lt;p&gt;Active Server Pages，内置在IIS中，在其他Web服务器中也可用，也允许你设置HTTP头。例如，设置一个过期时间，你可以使用Response方法的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;% Response.Expires=1440 %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;指定请求的代表文件在多少分钟后过期。Cache-Control头信息可以这样添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;% Response.CacheControl=&amp;quot;public&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在ASP.NET中，Response.Expires已不推荐使用。正确的方法是通过Response.Cache设置cache相关的头信息；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Response.Cache.SetExpires ( DateTime.Now.AddMinutes ( 60 ) ) ;
Response.Cache.SetCacheability ( HttpCacheability.Public ) ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;当在ASP中设置头信息时，确保你将Response方法放置在任何HTML生成之前，或者使用 Response.Buffer来缓冲输出内容。另外，注意有些版本的IIS默认设置一个 Cache-Control: private 的头信息，必须声明成public才能被共享缓存服务器缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;11.参考文档和更多信息&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ietf.org/rfc/rfc2616.txt"&gt;HTTP 1.1 Specification&lt;/a&gt;&lt;br&gt;
The HTTP 1.1 spec has many extensions for making pages cacheable, and is the authoritative guide to implementing the protocol. See sections 13, 14.9, 14.21, and 14.25.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.web-caching.com/"&gt;Web-Caching.com&lt;/a&gt;&lt;br&gt;
An excellent introduction to caching concepts, with links to other online resources.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.web-caching.com/"&gt;On Interpreting Access Statistics&lt;/a&gt;&lt;br&gt;
Jeff Goldberg’s informative rant on why you shouldn’t rely on access statistics and hit counters.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://redbot.org/"&gt;REDbot&lt;/a&gt;&lt;br&gt;
Examines HTTP resources to determine how they will interact with Web caches, and generally how well they use the protocol.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.mnot.net/cgi_buffer/"&gt;cgi_buffer Library&lt;/a&gt;
One-line include in Perl CGI, Python CGI and PHP scripts automatically handles ETag generation and validation, Content-Length generation and gzip Content-Encoding — correctly. The Python version can also be used as a wrapper around arbitrary CGI scripts.&lt;/p&gt;
&lt;h2&gt;12.关于本文档&lt;/h2&gt;
&lt;p&gt;This document is Copyright © 1998-2013 Mark Nottingham &lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#109;&amp;#110;&amp;#111;&amp;#116;&amp;#64;&amp;#109;&amp;#110;&amp;#111;&amp;#116;&amp;#46;&amp;#110;&amp;#101;&amp;#116;"&gt;&amp;#109;&amp;#110;&amp;#111;&amp;#116;&amp;#64;&amp;#109;&amp;#110;&amp;#111;&amp;#116;&amp;#46;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;. &lt;a href="http://creativecommons.org/licenses/by-nc-nd/3.0/"&gt;This work is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 Unported License&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All trademarks within are property of their respective holders.&lt;/p&gt;
&lt;p&gt;Although the author believes the contents to be accurate at the time of publication, no liability is assumed for them, their application or any consequences thereof. If any misrepresentations, errors or other need for clarification is found, please contact the author immediately.&lt;/p&gt;
&lt;p&gt;The latest revision of this document can always be obtained from https://www.mnot.net/cache_docs/&lt;/p&gt;
&lt;p&gt;Translations are available in: Chinese, Czech, German, and French.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译文，原文地址：&lt;a href="https://www.mnot.net/cache_docs/"&gt;https://www.mnot.net/cache_docs/&lt;/a&gt;，遵循原文的版本许可协议：&lt;a href="http://creativecommons.org/licenses/by-nc-nd/3.0/"&gt;Attribution-NonCommercial-NoDerivs 3.0 Unported&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="2015"></category><category term="Web"></category><category term="Cache"></category></entry><entry><title>14年下半年的奇葩经历</title><link href="https://fangpsh.github.io/posts/2015/2015-01-21.html" rel="alternate"></link><published>2015-01-21T00:00:00+08:00</published><updated>2015-01-21T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-01-21:/posts/2015/2015-01-21.html</id><summary type="html">&lt;p&gt;回家两天了，想着该整理下下半年来的经历，从深圳回到学校待了一段时间后，因为一位师兄的推荐，收到网易HR的电话让过去实习，工资虽然 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;回家两天了，想着该整理下下半年来的经历，从深圳回到学校待了一段时间后，因为一位师兄的推荐，收到网易HR的电话让过去实习，工资虽然少的可怜，不过想想学校这边校招基本都结束了不如先回去了，反正快年底了也要回家，顺便也看看网易杭州研究院是个什么样子，起了个这么牛逼的名字，笑。
实习的过程不算愉快，后面慢慢吐槽，一天看某招聘网站，投了百姓网和另外一家北京公司的SA岗，拿到两家offer的时候，也就离职回家了，北京公司的电话面试较快捷舒服，没太多好说的，百姓网的面试经历还是十分有趣的，有让人赞的点也有让人不舒服的地方。&lt;/p&gt;
&lt;h3&gt;网易杭州研究院实习经历&lt;/h3&gt;
&lt;p&gt;&lt;img alt="听说这是伞哥" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302150939.jpg"&gt;&lt;/p&gt;
&lt;p&gt;最早听说网易研究院是在&lt;a href="http://teahour.fm/2014/03/17/interview-with-binghe.html"&gt;teahour听冰河的访谈&lt;/a&gt;，想这地方应该不错，至少在实习期间是可以学到点东西。本来不应该在离职之后说“坏话”，为了各种各样的顾忌，不过我不觉得我说的是所谓的坏话，以下只是基于我自身经历的实话，而且也是对事不对人。当然也没有全部表述，有些事情只是我主观的猜想，还是不说了。  &lt;/p&gt;
&lt;p&gt;这边部门易主，部门调整，进的系统运维组，五个在职员工，一开始就我一个实习生。听说是小组原本七人，开了一个人，转岗一个人，又接了一堆乱七八糟的业务，难怪大家都忙成狗。先说说做了哪些事情，学习了内部的基础文档，写了几份内部需求的shell脚本，练手了一些主机的基础操作，这些两三天就做好的事情，经历了一个月，说白了，还是没人管我，带我的导师忙的很，我也就管自己查阅和吸收内部能够看到的文档资料（能吸收的就吸收，虽然日后要走的，不能吸收也没复制留存，职业道德还是要有的），看的没有东西看了，就开始看毕业设计相关的文档了。  &lt;/p&gt;
&lt;p&gt;后面看实在太没趣了，也不能吃白饭嘛，就要求值班，即当客服。。一开始还挺有新鲜劲，每当QA妹子找我的时候，都激动不已，细心服务，最喜欢一些非技术部门的妹子，上班无聊的时候聊聊天也是极好的。不过偶尔也会遇到不少傻逼开发人员（当然都是男的，女的那叫蠢萌蠢萌）上来问怎么ssh登陆、nginx规则怎么配置等等问题。想想自己如果在这种地方入职，要做值班客服至少一、两年，还好当初没有直接给我发offer让我签三方，谢天谢地。在这种大公司，还是业务为先，KPI为先，他们好像就是喜欢让工作变的无趣，同时因为一些历史原因、历史包袱，很多明摆着的问题没人愿意去推动解决。  &lt;/p&gt;
&lt;p&gt;拿到其他offer，萌发离职回家过年的意愿，恰好总监大人说我和后面来实习的妹子对比态度不够好（每天6点准时下班太早了，在杭研，12点前的加班都不算是加班你们造吗）不想再看到我，于是马上走人。  &lt;/p&gt;
&lt;p&gt;另外在这边也遇到一个醉人的部门秘书，见下图：
&lt;img alt="实习生真的很无辜。。" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302151026.jpg"&gt;&lt;/p&gt;
&lt;p&gt;实习期间还收到阿里淘宝技术保障部的面试，走了几轮，前后历时2个多月，最后再三催校照客服，一分钟内给了我个拒信，要原因，先是说第二批招聘薪资审核下不来（审批不下来你招个啥子人嘛），再问，改口说综合评定我能力问题，他说不行就不行吧，20多岁也不着急往阿里这个红色大熔炉跳，倒是浪费了我很多电话费。HR面的HR姐姐来擦屁股做了很多工作，不想给她再添麻烦，其他细节就不说了。
&lt;img alt="话说有同学面的轮数比我多吗" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230302151051.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;百姓网面试经历&lt;/h3&gt;
&lt;p&gt;最早了解到百姓网是因为v2ex上的一些招聘帖子，看起来氛围还挺不错的，本身也比较喜欢这种规模的和氛围的公司，让人向往。&lt;br&gt;
在某招聘网站上投了简历，HR发来笔试题，笔试题目如下，感觉相比某些公司的智力题出的还是不错的。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果让你搭一个百姓网,你会需要哪些用途的服务器,各多少台,什么样的配
置,运行什么软件?如果需要用到第三方服务的也请一并列出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;百姓网是LAMP架构，另外在infoq上有个演讲，在slide中可以一窥百姓网的架构，感觉中规中矩，没什么特别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有用户反映说他不能访问我们网站,而你是系统工程师,你准备分哪几步来找
到问题?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见的问题，按照经验和思维习惯回答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;列举你最喜欢的一个开源软件并说明理由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现有web服务的访问日志webaccess.log,形式如下:
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;200 123.190.216.50 - shanghai.baixing.com [03/Mar/2013:03:59:59 +0800] &amp;quot;GET
/menpiao/a250632202.html HTTP/1.1&amp;quot; &amp;quot;http://shanghai.baixing.com/menpiao/&amp;quot;
&amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot; 9175 384 54237......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现需要从中分别提取所有包含“Googlebot”和“Baiduspider”,且非404打头的行,分别保存到以访问日
期分割的文件中并压缩,如googlebot.2013-03-03.log.bz2和baiduspider.2013-03-03.log.bz2。请用bash shell,并以最优的方式实现这段脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-ne&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Usage: &lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt; logfile_name spiders_user_agent&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nv"&gt;LOG_FILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;span class="nv"&gt;UA&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;
&lt;span class="nv"&gt;lowUA&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$UA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tr&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A-Z&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a-z&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
grep&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;^404&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$LOG_FILE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$UA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;awk&lt;span class="w"&gt; &lt;/span&gt;-F&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;[:[]&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;{ outFile=&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$lowUA&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.&amp;quot;$2&amp;quot;.log&amp;quot;; gsub(/\//, &amp;quot; &amp;quot;, outFile); print $0 &amp;gt;&amp;gt; outFile}&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$lowUA&lt;/span&gt;.*.log&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;bzip2&lt;span class="w"&gt; &lt;/span&gt;-z&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;newname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$lowUA&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;xargs&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;date&lt;span class="w"&gt; &lt;/span&gt;+&lt;span class="s2"&gt;&amp;quot;%Y-%m- %d&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{}&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.log.bz2&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;mv&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;.bz2&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$newname&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我是这样直接打到文件里，写起来方便点，另外为了考虑脚本的通用性，没有把Googlebot 和Baiduspider放到一个脚本里判断，写成这样通用的脚本更方便点吧，方便以后处理什么搜狗，360，Bing，搜搜啥的。不过这样频繁IO带来的代价肯定很大，还要优化的话，就把中间的临时文件放到 /dev/shm/ 一个对应的目录下吧。  &lt;/p&gt;
&lt;p&gt;发了笔试答卷的当天下午HR就约了面试时间。&lt;br&gt;
几天后的一个早晨赶到上海交大某校区旁边的大厦接受面试。第一个面试官很Nice，聊得很轻松。第二个面试官聊的也还开心，居然问我是不是处女座=。=。第三个面试官让人很不舒服，说的过分点，甚至觉得有点不尊重人，他抓住一个问题死磕到底，可能这是他的面试风格，不过也学到了，面试者在面试中应该更加主动一些，对不好的状态应该及时打断切换转移，防止一直处于比较被动的局势。第三面下来吃饭的心情都没了，坐在一角休息、喝水。过了很久，快睡着的时候PP姐过来，给了offer，聊了薪资（计算很麻烦，没记住），坦白对于薪资不太能接受，想回去考虑。  &lt;/p&gt;
&lt;p&gt;回来的路上收到北京公司的offer。  &lt;/p&gt;
&lt;p&gt;后来选择不接受百姓网的offer时，较纠结，百姓网的公司氛围确实是不错的，相信也是适合我毕业后工作和学习的，整个面试流程还算舒服，薪资上其实还行（后来电话过来重新谈了薪资），只是我那一颗北漂的心。。。还是挺建议愿在上海发展的同学选择这家公司。  &lt;/p&gt;
&lt;p&gt;14年就这样马不停蹄的远去了。  &lt;/p&gt;</content><category term="2015"></category><category term="career"></category></entry><entry><title>OpenSSH的AuthorizedKeysCommand选项</title><link href="https://fangpsh.github.io/posts/2015/2015-01-05.html" rel="alternate"></link><published>2015-01-05T00:00:00+08:00</published><updated>2015-01-05T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-01-05:/posts/2015/2015-01-05.html</id><summary type="html">&lt;p&gt;&lt;img alt="openssh" src="https://www.openssh.com/images/openssh.gif"&gt;&lt;/p&gt;
&lt;p&gt;Debian jessie 冻结了，今年就要release，openssh-server 包也从6.0 升到6.7，AuthorizedKeysCommand 和AuthorizedKeysCommandUser 这两个配置选项是在6.2的时候引入的，所以也能用上了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wheezy (stable)：1:6.0p1-4+deb7u2&lt;/li&gt;
&lt;li&gt;wheezy-backports： 1:6 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="openssh" src="https://www.openssh.com/images/openssh.gif"&gt;&lt;/p&gt;
&lt;p&gt;Debian jessie 冻结了，今年就要release，openssh-server 包也从6.0 升到6.7，AuthorizedKeysCommand 和AuthorizedKeysCommandUser 这两个配置选项是在6.2的时候引入的，所以也能用上了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wheezy (stable)：1:6.0p1-4+deb7u2&lt;/li&gt;
&lt;li&gt;wheezy-backports： 1:6.6p1-4~bpo70+1&lt;/li&gt;
&lt;li&gt;jessie (testing) ： 1:6.7p1-3&lt;/li&gt;
&lt;li&gt;sid (unstable) ： 1:6.7p1-3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AuthorizedKeysCommand 可以指定运行一个脚本，而这个脚本主要是寻找登录用户的publickey，默认传参为登录用户名，若未认证成功，将继续使用AuthorizedKeysFile文件来做认证。AuthorizedKeysCommandUser就是指定以什么用户来运行这个脚本。
这两个配置选项的一个用处就是在用户管理上可以不再依靠本地管理，而可以通过脚本读取远程数据库系统中的用户的publickey进行认证，例如MySQL或者LDAP，这样的话，更便于用户的集中管理。&lt;/p&gt;
&lt;p&gt;更多参考 &lt;a href="https://web.archive.org/web/20170106015909mp_/http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/sshd_config.5?query=sshd_config&amp;amp;sec=5&amp;amp;arch=i386"&gt;SSHD_CONFIG(5) File Formats Manual&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;MySQL&lt;/h3&gt;
&lt;p&gt;下面这个例子取自OpenSSH 6.2 で追加された機能を試す¶. 如果是Debian的系统需要确保服务器上的openssh-server版本在6.2之上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mysql创建数据表：
mysql&amp;gt; create database authorizedkeys;
mysql&amp;gt; use authorizedkeys;
mysql&amp;gt; create table authorizedkeys(username text , publickey text);
mysql&amp;gt; insert into authorizedkeys values(&amp;#39;fps&amp;#39;,&amp;#39;ssh-rsa AAA....xOr+WVPFsH/npVrvz/w== fangpeishi&amp;#39;); #添加用户的publickey到数据表中

AuthorizedKeysCommand调用的脚本：/etc/key.sh
#!/bin/sh
/usr/bin/mysql -uroot authorizedkeys -sNe &amp;quot;select publickey from authorizedkeys where username=&amp;#39;$1&amp;#39;&amp;quot;

/etc/ssh/sshd_config配置文件：
...
AuthorizedKeysCommand /etc/key.sh
AuthorizedKeysCommandUser root #以root用户调用脚本
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  # service ssh stop 停止服务
  # /usr/sbin/ssh -ddd 进行debug，运行之后尝试远程登录，查看日志信息如下
  ...
  ...
  debug1: temporarily_use_uid: 0/0 (e=0/0)
  debug3: Running AuthorizedKeysCommand: &amp;quot;/etc/ssh/key.sh fps&amp;quot; as &amp;quot;root&amp;quot;
  debug1: restore_uid: 0/0
  debug1: temporarily_use_uid: 0/0 (e=0/0)
  debug1: matching key found: file /etc/ssh/key.sh, line 1 RSA 00:11:26:ba:28:bc:fc:9c:da:f7:d0:ff:ee:64:fa:e2
  debug1: restore_uid: 0/0
  debug3: mm_answer_keyallowed: key 0x7fb2576727c0 is allowed
  ...
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;LDAP&lt;/h3&gt;
&lt;p&gt;这东西没折腾过，不熟悉，看两个例子吧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20170106015909mp_/http://jmorano.moretrix.com/2013/09/openssh-6-2-x-ldap-authentication/"&gt;OpenSSH 6.2.x and LDAP authentication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20170106015909mp_/http://www.sysadmin.org.au/index.php/2012/12/authorizedkeyscommand/"&gt;sshd AuthorizedKeysCommand&lt;/a&gt; 意思都差不多，都是执行脚本，从server上远程拿到key然后做认证。&lt;/li&gt;
&lt;/ul&gt;</content><category term="2015"></category><category term="openssh"></category></entry><entry><title>Markdown 制作幻灯片与编写文档</title><link href="https://fangpsh.github.io/posts/2015/2015-01-03.html" rel="alternate"></link><published>2015-01-03T23:00:41+08:00</published><updated>2015-01-03T23:00:41+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-01-03:/posts/2015/2015-01-03.html</id><summary type="html">&lt;p&gt;从使用markdown一开始，编辑器一直在换（还动手写过一个简单的实时预览编辑器。。用正则做渲染处理，效果不是很好），&lt;br&gt;
从windows下的markdownpad，到linux下的retext，haroopad，以及在 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;从使用markdown一开始，编辑器一直在换（还动手写过一个简单的实时预览编辑器。。用正则做渲染处理，效果不是很好），&lt;br&gt;
从windows下的markdownpad，到linux下的retext，haroopad，以及在线的stackedit.io，dillinger.io等，后来选择使用emacs+本地监控和渲染工具（例如nodejs写的markdown server之类的），到目前选择编辑器（emacs）+pandoc，还是十分舒服和便捷的。另外mac下的大名鼎鼎mou一直没有机会使用:(&lt;/p&gt;
&lt;p&gt;pandoc的强大就不多说了，大家有兴趣看看官网那张转换图：&lt;a href=""&gt;http://johnmacfarlane.net/pandoc/&lt;/a&gt;&lt;br&gt;
pandoc的安装啥的也就略过了，有需要的话可以看看阳志平老师的：&lt;br&gt;
&lt;a href="http://www.yangzhiping.com/tech/pandoc.html"&gt;Markdown写作进阶：Pandoc入门浅谈&lt;/a&gt; ,里边也有一些基础的使用教程。&lt;br&gt;
另外建议过一遍 pandoc的markdown的语法：&lt;a href="http://pages.tzengyuxio.me/pandoc/"&gt;Pandoc’s Markdown 语法中文翻译&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;制作幻灯片&lt;/h2&gt;
&lt;p&gt;基本可以参考这两篇文章：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.soimort.org/posts/165/"&gt;Markdown+Pandoc→HTML幻灯片速成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://johnmacfarlane.net/pandoc/demo/example9/producing-slide-shows-with-pandoc.html"&gt;Producing slide shows with Pandoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外需要补充两点，  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果幻灯片中有代码，而需要代码高亮时，可以看看&lt;a href="http://martin-thoma.com/how-to-print-source-code-with-latex/"&gt;How to print Source Code with LaTeX&lt;/a&gt;，基本里边提到的语言大都是支持的，到时候在代码块处指明即可。&lt;/li&gt;
&lt;li&gt;如果输出为beamer的时候可能会遇到中文字体的问题，解决的方法也就是使用自定义的模板，并在其中指定中文字体了，网络上有很多不错的中文的beamer模板可以采用，也可以直接修改pandoc默认的beamer模板，这里贴一份，不知是从何处参考的，忘记了出处：https://gist.github.com/fangpsh/6822e5fc6a21f21a5a51 ，大家可以根据自己本机的情况修改其中的中文字体选项等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编写文档&lt;/h2&gt;
&lt;p&gt;一开始选择使用pandoc转换为pdf，主要是因为它支持目录索引，在XX游戏实习那会，编写的文档超过一百页了，没有目录实在不方便，找了一圈用了pandoc，而且配合latex模板，可以做比较好的排版，（latex这种复杂的东西没毅力学，所以也是拿网友共享的模板）。  &lt;/p&gt;
&lt;p&gt;具体可以参考这两篇：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://readus.org/2014/07/02/pandoc-convert-chinese-pdf/"&gt;pandoc转换中文pdf攻略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://afoo.me/posts/2013-07-10-how-to-transform-chinese-pdf-with-pandoc.html"&gt;pandoc中文pdf转换攻略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中文字体相关的问题以上两个链接中都有提到了，按照对应的流程解决即可，不过注意第二个链接中LiHei Pro好像对简体支持有问题，所以大家可以看看本机上安装的中文字体，然后选项一个合适的指定即可。这里也贴一份模板，也是直接使用一份网友的模板（出处找不到）:&lt;br&gt;
https://gist.github.com/fangpsh/5cc11fa503f1e9eda2c1  &lt;/p&gt;</content><category term="2015"></category><category term="markdown"></category></entry><entry><title>运维笔记片段</title><link href="https://fangpsh.github.io/posts/2015/2015-01-01.html" rel="alternate"></link><published>2015-01-01T00:00:00+08:00</published><updated>2015-01-01T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2015-01-01:/posts/2015/2015-01-01.html</id><summary type="html">&lt;p&gt;帮同事迁移一个N年前的wordpress站（ http://52ml.net ），迁移后数据库使用mariadb，mariadb的socket默认监听在  0.0.0.0:3306上，但是wp无法连接（本地和远程测试连接没问题），需要在/etc/my.cnf中添加：bind-address=localhost。另 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;帮同事迁移一个N年前的wordpress站（ http://52ml.net ），迁移后数据库使用mariadb，mariadb的socket默认监听在  0.0.0.0:3306上，但是wp无法连接（本地和远程测试连接没问题），需要在/etc/my.cnf中添加：bind-address=localhost。另外  老版本的wp迁移，建议放弃整体迁移，导数据，备份配置文件和图片，然后重安装主题和插件。    &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Testlink迁移，修改数据库配置项目，除了更新自定义配置项中的custom_config.inc.php中的$tlCfg-&amp;gt;log_path 与$g_repositoryPath等自定义配置，另外需要修改php.ini中 session.auto_start = 0，否则无法登录。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为apache 添加spdy支持，如果是2.2，使用官方模块，如果是2.4+，放弃折腾，github上个人fork的支持2.4的模块有不少bug。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;nginx做前端反向代理需设置client_max_body_size ，以便传大文件。另外Nginx的配置，"nginx仅仅检查请求的“Host”头以决定该请求应由哪个虚拟主机来处理。如果Host头没有匹配任意一个虚拟主机，或者请求中根本没有包含Host头，那nginx会将请求分发到定义在此端口上的默认虚拟主机。"  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Centos 7如果使用仓库中的nginx包，需要注意sytemd的对应service文件中指定的pid路径与nginx.conf中指定的路径是否相同，如果不同需要修改为相同，曾经在sysytemd的邮件列表中看过这个问题，没想到半年后自己也遇到了。  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Nginx配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Server{
    listen 80;
    server_name a.foo.com
                b.foo.com
                c.foo.com
    return 301 https://$server_name/$request_uri;
   #return 301 https://$host/$request_uri;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无论访问a.foo.com还是b.foo.com，c.foo.com，都将转到 https://a.foo.com/ ，server_name只取第一个，另外如果用正则的话例如：server_name ~^(a|b|c).foo.com，那转向居然是 https://~^(a|b|c).foo.com  。。。。。
server_name是一个变量，它存储的是配置中设置的第一条server_name的配置项，应该改用$host。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$host
    in this order of precedence: host name from the request line, or host name from the “Host” request header field, or the server name matching a request 
$server_name
    name of the server which accepted a request 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;迁移LDAP，phpldapamin显示 &lt;code&gt;This base cannot be created with PLA&lt;/code&gt;，于是手动创建base，可是ldapadd 时候提示&lt;code&gt;ldap_bind: Invalid credentials (49)&lt;/code&gt;，仔细检查并google了半天，最后根据同事发来的脚本，发现是没有指定主机和端口造成的。。orz。&lt;/p&gt;
&lt;p&gt;base.ldif&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dn: dc=lol,dc=com
objectclass: dcObject
objectclass: organization
dc: lol
o: lol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ldapadd -h ldap.lol.com -p 389 -D &amp;quot;cn=admin,dc=lol,dc=com&amp;quot; -W -x -a  -c -f base.ldif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;ganglia 单播模式下，一些图片显示不全，这是由于ganglia安装好后默认是组播，为了降低网络负担，默认的send_metadata_interval为0（3.1.x版本之后），然而单播模式下，如果send_memta_interval设置为0（默认为0）gmod只会在启动的时候向接收的gmod发送元数据（包含的度量信息，不是监控的数据包）。
所以需要将send_memta_interval设置为非0，例如30。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ganglia的度量指标从他的元数据间隔发送得到的。元数据包含诸如度量分组，类型等等。假如你重启了接收的gmond主机，那么元数据就会丢失，gmond就不知道如何处理度量数据，因此会把他们抛弃。这会导致生成空白的图表。在组播模式下，gmonds可以和其他任意一台主机通信，在元数据丢失情况请求重新获取。但这在单播模式下是不可能的，因此你需要命令gmond定期的发送元数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content><category term="2015"></category><category term="linux"></category></entry><entry><title>尝试解决openSUSE下zypper软件包名称自动补全的问题</title><link href="https://fangpsh.github.io/posts/2014/2014-12-16.html" rel="alternate"></link><published>2014-12-16T11:13:19+08:00</published><updated>2014-12-16T11:13:19+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-12-16:/posts/2014/2014-12-16.html</id><summary type="html">&lt;p&gt;一年前从debian 换到opensese的时候，很不习惯zypper在安装软件包的时候不能自动补全，添加到todolist里面，后来停用evernote 给忘记了，前几天上去整理笔记发现了，所以尝试性得解决了下，另外 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;一年前从debian 换到opensese的时候，很不习惯zypper在安装软件包的时候不能自动补全，添加到todolist里面，后来停用evernote 给忘记了，前几天上去整理笔记发现了，所以尝试性得解决了下，另外顺带修了一个小bug，当本地repo超过10条时，原来脚本生成的自动补全列表不全的问题。&lt;/p&gt;
&lt;p&gt;bash自带补全功能，要达到更好的补全效果需要安装bash-completion这个软件包，然后编写对应的补全脚本。关于bash-completion的内容，可以参考以下两个链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://kodango.com/bash-competion-programming"&gt;编写 Bash 补全脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.debian-administration.org/article/317/An_introduction_to_bash_completion_part_2"&gt;An introduction to bash completion: part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件包名词的自动补全问题主要就是怎么快速的获取软件包的名称，然后作为列表供选。
一开始我是用zypper search 来获取，速度不堪忍受，（apt-get,aptitude 等的自动补全脚本是用apt-cache来获取，速度很快）。&lt;/p&gt;
&lt;p&gt;zypper se方式的脚本片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;install&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;info&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;download&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;echo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POSIX&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$ZYPPER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;se&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$curl&lt;/span&gt;&lt;span class="s2"&gt;*&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/dev/null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1,5&amp;#39;&lt;/span&gt;d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tr&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
remove&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;echo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POSIX&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$ZYPPER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;se&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$curl&lt;/span&gt;&lt;span class="s2"&gt;*&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/dev/null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1,5&amp;#39;&lt;/span&gt;d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tr&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
update&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;up&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;echo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POSIX&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$ZYPPER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;list-updates&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1,4&amp;#39;&lt;/span&gt;d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;|&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;tr&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后来看了下libzypp，又看到 zypp-NameReqPrv 这个工具，试了下，速度快了一些，基本可以用了，不过感觉还不是太理想，特别是zypper install 的时候，如果列表生成的数组过大，还是有点卡顿，瓶颈在要对zypp-NameReqPrv的输出结果做过滤。&lt;br&gt;
不知道还有没有更快的方式来获取软件列表，难道只能使用libzypp来编写？&lt;br&gt;
另外如果使用zsh，并且使用了on-my-zsh的话好像是可以自动补全。第一次补全时会有明显的卡顿，后面再使用就很流畅了，可能做了缓存？ 不知道是怎么做到的，可以学习学习，然后迁移到bash下。  &lt;/p&gt;
&lt;p&gt;zypp-NameReqPrv 方式的脚本片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;install&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;info&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;download&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;echo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POSIX&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$ZYPPNameReqPrv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;-E&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;^［:blank:］*[0-9]+［:blank:］+&lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="s2"&gt;[a-Z0-9]*-&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;                           &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;-r&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s/-[0-9]+\..*//&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;sort&lt;span class="w"&gt; &lt;/span&gt;-u&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;

remove&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;update&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;up&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;echo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;POSIX&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$ZYPPNameReqPrv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;--installed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;-E&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;^［:blank:］*[0-9]+［:blank:］+&lt;/span&gt;&lt;span class="nv"&gt;$cur&lt;/span&gt;&lt;span class="s2"&gt;[a-Z0-9]*-&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;cut&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;-r&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s/-[0-9]+\..*//&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;sort&lt;span class="w"&gt; &lt;/span&gt;-u&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用openSUSE + bash 的同学可以试一试，把&lt;a href="https://gist.github.com/fangpsh/86e13a771ccea24a206b"&gt;这份脚本&lt;/a&gt;拷贝至 &lt;code&gt;/etc/bash_completion.d/&lt;/code&gt; 下 。&lt;/p&gt;</content><category term="2014"></category><category term="opensuse"></category><category term="bash"></category></entry><entry><title>Debian 8 升级相关信息</title><link href="https://fangpsh.github.io/posts/2014/2014-09-17.html" rel="alternate"></link><published>2014-09-17T17:42:30+08:00</published><updated>2014-09-17T17:42:30+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-09-17:/posts/2014/2014-09-17.html</id><summary type="html">&lt;h2&gt;Debian7-8更新与变化&lt;/h2&gt;
&lt;h3&gt;Debian Installer Jessie Alpha 1 release&lt;/h3&gt;
&lt;p&gt;2014年3月19号，debian installer jessie alpha 1发布，摘录部分更新与变化如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apt-setup: Avoid hang due to interactive apt-cdrom&lt;a href="https://bugs.debian.org/740673"&gt;#740673&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;grub-installer: Support menu selection of GRUB boot disk&lt;a href="https://bugs.debian.org/706112"&gt;#706112&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The ia64 architecture has been removed from the archive …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Debian7-8更新与变化&lt;/h2&gt;
&lt;h3&gt;Debian Installer Jessie Alpha 1 release&lt;/h3&gt;
&lt;p&gt;2014年3月19号，debian installer jessie alpha 1发布，摘录部分更新与变化如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apt-setup: Avoid hang due to interactive apt-cdrom&lt;a href="https://bugs.debian.org/740673"&gt;#740673&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;grub-installer: Support menu selection of GRUB boot disk&lt;a href="https://bugs.debian.org/706112"&gt;#706112&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The ia64 architecture has been removed from the archive, and is no longer supported.&lt;/li&gt;
&lt;li&gt;The Linux kernel has been updated from 3.2 to 3.13.(注：debian 8的内核版本将为3.16)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.debian.org/devel/debian-installer/News/2014/20140319"&gt;Releae NEWS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://lists.debian.org/debian-devel-announce/2014/03/msg00009.html"&gt;Debian Installer Jessie Alpha 1 release&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linux Knernel&lt;/h3&gt;
&lt;p&gt;Debian 8 默认内核版本将为3.16。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTc1MDg"&gt;Debian 8.0 Jessie Is Settling For Linux 3.16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://lists.debian.org/debian-kernel/2014/07/msg00361.html"&gt;Kernel version for jessie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Systemd&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://wiki.debian.org/ReleaseGoals/systemd"&gt;Add native systemd support to every package shipping a sysvinit script&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Debian 8将采用systemd作为默认init系统,同时systemd将兼容Debian仓库中的所有包含sysv脚本的软件包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Native systemd support for every Debian package that currently contains sysv scripts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;debian 8 sysvinit与systemd的切换&lt;/h4&gt;
&lt;p&gt;目前debian testing（2014-07-29）仍然采用sysv作为默认init系统，需手动安装软件包等切换至systemd。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;update

$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;systemd&lt;span class="w"&gt; &lt;/span&gt;

&lt;span class="c1"&gt;#安装 systemd-sysv 后自动将systemd配置为默认init系统，&lt;/span&gt;
&lt;span class="c1"&gt;#同时移除sysvinit-core&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;systemd-sysv&lt;span class="w"&gt; &lt;/span&gt;

$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重启之后，查看PID=1的进程是&lt;code&gt;/sbin/init&lt;/code&gt;，再查看 &lt;code&gt;/sbin/init&lt;/code&gt;会发现是&lt;code&gt;/lib/systemd/systemd&lt;/code&gt;的软链接，至此，系统默认initsystem已切换至systemd。在debian 8 正式版发布之后，将采用systemd作为默认init系统，可能不需要用户手动切换。&lt;/p&gt;
&lt;h4&gt;systemd兼容性与注意事项&lt;/h4&gt;
&lt;p&gt;systemd的SySV兼容性内容请查看 详细介绍-系统管理-SysV兼容性一节，包含init script的注意事项等。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;systemd定义了一批配置文件，请查看详细介绍-系统管理-规范化的配置文件一节。&lt;/li&gt;
&lt;li&gt;systemd中runlevel的概念被target替代，telinit与init命令仍可使用。关于target与启动顺序内容，请查看详细介绍-系统管理-Target和Dependency based bootup 一节 与启动分析一节。&lt;ul&gt;
&lt;li&gt;注：使用systemd之后/etc/initab被忽略，所以修改此文件中的runlevel并不能起效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;debian with systemd下，service命令依然可用，但是service实际上是调用systemctl命令，详情请查看详细介绍-系统管理-SysV兼容性一节。&lt;ul&gt;
&lt;li&gt;注：&lt;code&gt;service foobar status&lt;/code&gt;将返回systemctl类型的status内容，不再是&lt;code&gt;foobar is runing .&lt;/code&gt;此类输出。&lt;/li&gt;
&lt;li&gt;建议使用systemctl命令或service命令，不建议使用&lt;code&gt;/etc/init.d/&amp;lt;service&amp;gt;&lt;/code&gt;，因为后者无法处理sysv init文件被移除的状况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;service 单元执行的时候没有附带任何上下文环境,甚至没有进行 $HOME 目录的设置。对这些有依赖的启动脚本将无法正常工作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/rc.local&lt;/code&gt;依然可用，见&lt;code&gt;/lib/systemd/system/rc-local.service&lt;/code&gt; 单元文件。&lt;/li&gt;
&lt;li&gt;update-rc.d 命令依旧可用，但是注意：start与stop选项不再被支持。查看&lt;code&gt;/usr/sbin/update-rc.d&lt;/code&gt;文件，可发现其对/etc/init.d/的处理部分以及针对systemd的service的处理部分。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;systemctl enable/disable&lt;/code&gt;命令实际上调用update-rc.d命令。若不存在service单元文件，将对&lt;code&gt;/etc/init.d/&amp;lt;service&amp;gt;&lt;/code&gt;下的脚本链接到&lt;code&gt;/etc/rcN.d/&lt;/code&gt;目录下。若是service单元存在，将依照单元文件中[Install]中的内容将单元文件链接到对应的wants文件夹中。&lt;blockquote&gt;
&lt;p&gt;update-rc.d(8) should enable/disable systemd services in addition to creating the sysvinit links. update-rc.d is usually called from maintscripts, but enable/disable is typically used by the system administrator.
systemctl enable/disable should also call update-rc.d&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/systemd/Integration"&gt;systemd Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;注：update-rc.d中 default 等同于"start 2 3 4 5 . stop 0 1 6 ."，&lt;code&gt;update-rc.d foobar defaults&lt;/code&gt; ，注意default是否与脚本中LSB部分指定的Start与Stop存在冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：systemd不支持交互式启动脚本，例如Debian‘s X-Interactive in the LSB header。&lt;/li&gt;
&lt;li&gt;debian testing中的systemd的coredumpctl不可用，打包时候&lt;code&gt;--disable-coredump&lt;/code&gt;,原因不明。&lt;/li&gt;
&lt;li&gt;默认情况下systemd的日志journal的磁盘存储需要手动创建目录，否则重启将丢失日志记录，请查看详细介绍日志管理-日志的记录等-日志存储一节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;本节参考链接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTYwMDQ"&gt;Systemd Is The Future Of Debian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/Debate/initsystem/systemd"&gt;Debate initsystem systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/systemd"&gt;Debian Wiki:systemd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Clang&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Clang support as a secondary compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;goal:&lt;a href="https://wiki.debian.org/ReleaseGoals/clang-secondary-compiler"&gt;Clang as a second compiler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一方面由于Clang相对于GCC有更多特性（模块化设计、更快的编译速度、编译过程占用内存低、编译中间产物和最终链接产物大幅减少、编译错误提示友好等等），另一方面由于Clang目前已足够稳定与优秀，所以 Debian 8支持Clang作为辅助编译器。&lt;/p&gt;
&lt;p&gt;Debian 仓库中的软件包正被重新用Clang进行编译打包，进度与详情请查看 &lt;a href="http://clang.debian.net/"&gt;clang.debian.net&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://clang.debian.net/"&gt;clang.debian.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/llvm-clang"&gt;llvm-clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTA2NjQ"&gt;LLVM's Clang Is Almost Good Enough For Debian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTI5ODc"&gt;Debian Is Still Being Made To Build With LLVM/Clang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Piuparts clean archive&lt;/h3&gt;
&lt;p&gt;Piuparts是一个deb打包的质量检测工具，在debian 8中要求所有软件包必须通过picparts的相关检测。&lt;/p&gt;
&lt;p&gt;Piuparts介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;piuparts is a tool for automatic testing of whether a package can be installed, upgraded, and removed. Like [Lintian], it is useful to run in a centralized fashion, in addition to each package maintainer running it manually.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Debian 8需要达到以下目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All packages should pass the piuparts tests, IOW that installation (and upgrade) of a package (within the test setup on piuparts.d.o) works fine and also that it purges cleanly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/piuparts"&gt;Debian wiki:piuparts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/ReleaseGoals/piuparts"&gt;ReleaseGoals piuparts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UTF-8 support&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://wiki.debian.org/ReleaseGoals/utf-8"&gt;UTF-8 support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;four sub-goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;all programs should, in their default configuration, accept UTF-8 input and pass it through uncorrupted. Having to manually specify encoding is acceptable only in a programmatic interface, GUI/std{in,out,err}/ command line/plain files should work with nothing but LC_CTYPE.  &lt;/li&gt;
&lt;li&gt;all GUI/curses/etc programs should be able to display UTF-8 output where appropriate&lt;/li&gt;
&lt;li&gt;all file names in source and binary packages must be valid UTF-8&lt;/li&gt;
&lt;li&gt;all text files should be encoded in UTF-8 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SELinux support&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://wiki.debian.org/ReleaseGoals/SELinux"&gt;Goal：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Allow the users to enable SELinux enforcing mode on their machine without too much hassle.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Improve the SELinux reference policy, this is currently being worked out with upstream.&lt;/li&gt;
&lt;li&gt;Be sure that when a init/maintainer script is creating a file/directory the label on disk is properly (re)set.&lt;/li&gt;
&lt;li&gt;Be sure that SELinux aware applications have SELinux support enabled and that's it's working properly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;debain 8只是将改进对SELinux的支持，目标如上。
debian 8还不会默认启用SELinux，debian testing上目前默认未安装SELinux系统所需的软件包（除了libselinux1：SELinux runtime shared libraries）。&lt;/p&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;p&gt;请参考&lt;a href="https://wiki.debian.org/ReleaseGoals"&gt;Release Goals&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardening of ELF binaries (carry over from Wheezy)&lt;/li&gt;
&lt;li&gt;Debian/rules to honor CC/CXX flags&lt;ul&gt;
&lt;li&gt;This goal aims to make sure that any package in the archive could be rebuild with the command CC=foo CXX=bar dpkg-buildpackage.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cross toolchains in the archive&lt;/li&gt;
&lt;li&gt;Make the base system cross-buildable&lt;/li&gt;
&lt;li&gt;注意：debian testing 默认关闭root用户ssh远程登录&lt;/li&gt;
&lt;li&gt;debian testing安装流程基本无变化。若不使用网络源，taskel仅有且默认选中Debian desktop environment与Standard systemd utilities；若使用网络源，taskel默认选中Debiandesktop 、print server与standard systemd utilities。&lt;/li&gt;
&lt;li&gt;注：由于debian jessie目前未冻结，关于软件包版本变化的调查未进行。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://packages.debian.org/search?keywords=mysql-server"&gt;package mysql-server&lt;/a&gt;：wheezy(stable):5.5.38-0,jessie(testing):5.5.37-1, &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;本节参考链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://lists.debian.org/debian-devel-announce/2013/10/msg00004.html"&gt;Bits from the Release Team (Jessie freeze info)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTQ4NTA"&gt;Debian 8.0 To Be Frozen, Features Announced&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Debian 8 升级注意事项&lt;/h2&gt;
&lt;h3&gt;rc.local拆分为service单元&lt;/h3&gt;
&lt;p&gt;目前&lt;code&gt;/etc/rc.local&lt;/code&gt;文件依旧可用，systemd存在默认的rc-local.service单元。&lt;/p&gt;
&lt;p&gt;往rc.local文件中写入大量的启动初始化语句会导致rc.local难以维护与管理。参考systemd默认提供的rc-local.service单元，我们可以将原本写入的rc.local文件合理的拆分为多个文件，
例如rc-route.local，rc-screensaveroff.local等，与rc.local同样，将这些local文件&lt;code&gt;chmod +x&lt;/code&gt;。然后在&lt;code&gt;/etc/systemd/system&lt;/code&gt;下创建类似&lt;code&gt;rc-local.service&lt;/code&gt;的单元文件，
例如&lt;code&gt;rc-route.service&lt;/code&gt;,&lt;code&gt;rc-screensaveoff.service&lt;/code&gt;等，service文件的编写请查看 详细介绍--进程管理--服务进程管理一节，以及参考&lt;code&gt;rc-local.service&lt;/code&gt;文件。
编写好service文件之后，重载systemd进程，然后&lt;code&gt;systemctl enable&lt;/code&gt;这些service即可，后续若需要禁用或修改某些启动脚本，只需配置对应单元以及脚本即可。&lt;/p&gt;
&lt;h3&gt;Debian testing  systemd-208-6 CONFFLAGS&lt;/h3&gt;
&lt;p&gt;请关注systemd源码包下rules文件中 disable 的模块或功能，例如 coredump：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
CONFFLAGS = \
        --with-rootprefix= \
        --with-rootlibdir=/lib/$(DEB_HOST_MULTIARCH) \
        --with-sysvinit-path=/etc/init.d \
        --with-sysvrcnd-path=/etc \
        --with-firmware-path=/lib/firmware \
        --with-debug-shell=/bin/bash \
        --with-telinit=/lib/sysvinit/telinit \
        --enable-tcpwrap \
        --disable-coredump \
        --disable-efi \
        --disable-myhostname \
        --disable-vconsole \
        --disable-silent-rules
ifeq (,$(findstring stage1,$(DEB_BUILD_PROFILES)))
CONFFLAGS += --enable-libcryptsetup
endif

CONFFLAGS_deb = \
        --enable-selinux \
        --enable-introspection \
        --enable-gtk-doc
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="2014"></category><category term="Systemd"></category><category term="Debian"></category></entry><entry><title>Scrum 初探</title><link href="https://fangpsh.github.io/posts/2014/2014-08-20.html" rel="alternate"></link><published>2014-08-20T00:00:00+08:00</published><updated>2014-08-20T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-08-20:/posts/2014/2014-08-20.html</id><summary type="html">&lt;p&gt;&lt;img alt="scrum01" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110136.jpg"&gt;&lt;/p&gt;
&lt;p&gt;三月份参加腾讯广研创新班的时候，在华工大学城校区上了一节主题为敏捷迭代开发的课程，第一次接触到 Scrum ，广研的导 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="scrum01" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110136.jpg"&gt;&lt;/p&gt;
&lt;p&gt;三月份参加腾讯广研创新班的时候，在华工大学城校区上了一节主题为敏捷迭代开发的课程，第一次接触到 Scrum ，广研的导师讲的挺好，用视频配合腾讯内部实际情况介绍了 Scrum。前段时间看美剧 “Silicon Valley “(硅谷)，第一季的第五集里遇到了 Scrum，Jared 建立了一个叫“争球”的管理体系。&lt;/p&gt;
&lt;p&gt;借着美剧纸上谈兵的学习下Scrum。&lt;/p&gt;
&lt;p&gt;&lt;img alt="scrum02" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110151.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Wikipedia的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scrum是一种迭代式增量软件开发过程，通常用于敏捷软件开发。Scrum在英语里是橄榄球运动中争球的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文太简单了，看下英文的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scrum is an iterative and incremental agile software development framework for managing product development. It defines “a flexible, holistic product development strategy where a development team works as a unit to reach a common goal”. It challenges assumptions of the “traditional, sequential approach” to product development. Scrum enables teams to self-organize by encouraging physical co-location or close online collaboration of all team members and daily face-to-face communication among all team members and disciplines in the project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，英文有点复杂和抽象，简单来说争球（争个球啊，这翻译实在太逗了：P）是一个适合团队进行敏捷迭代开发的框架。在剧中Jared提到要改善团队的沟通，Scrum 正有改善团队沟通的好处，另外更重要的是提高团队效率，对团队成员有激励作用等，可以更好的适应需求的变更。&lt;/p&gt;
&lt;h3&gt;Sprint&lt;/h3&gt;
&lt;p&gt;Scrum 由一系列的 Srpint（冲刺）组成，在橄榄球比赛中也正是由不断的冲刺进攻以达到胜利的目标，也有点像接力比赛中的每段赛程，见下图（图片来源：wikipedia）：
&lt;img alt="sprint" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110237.jpg"&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出一个Sprint是30天，实际上一般是一周到一个月，典型的是2周时间。一次冲刺的时间虽然短，但是每一个冲刺完成的时候都是真正的 “完成”，即除了相关模块功能的完成，相关文档与测试工作也同期完成。&lt;/p&gt;
&lt;p&gt;每个Sprint由一个Sprint 计划会议而开始，确定冲刺的工作量、完成日期等。上图中小圈的24h是指每日的例会（站立会议），即每天一次小冲刺，回顾和了解团队成员当天的完成情况等。关于会议的类型和简介后文继续。&lt;/p&gt;
&lt;p&gt;管理Scrum的过程可以在任务板上使用便利贴等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="scrum03" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110248.jpg"&gt;&lt;/p&gt;
&lt;p&gt;看到这个任务板，让我想起了流行的团队管理工具–Trello，可以在Trello上应用Scrum框架,把Trello的Board当作任务板：&lt;/p&gt;
&lt;p&gt;&lt;img alt="scrum04" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110302.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Scrum 主要包含 三个角色、三个文档、四个会议。&lt;/h2&gt;
&lt;h3&gt;角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Scrum主管&lt;/li&gt;
&lt;li&gt;产品负责人&lt;/li&gt;
&lt;li&gt;开发团队&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Scrum主管&lt;/h4&gt;
&lt;p&gt;&lt;img alt="scrum05" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110314.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Scrum 主管像是球队中的教练。&lt;/p&gt;
&lt;p&gt;Scrum 主管不是团队领导，即教练不是一个俱乐部的管理阶层一样，Scrum主要负责清理团队的障碍，保证团队进度的推荐，不受外界干扰。主管会检查项目的进度，协调团队工作等等。&lt;/p&gt;
&lt;h4&gt;产品负责人&lt;/h4&gt;
&lt;p&gt;&lt;img alt="scrum06" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110335.jpg"&gt;&lt;/p&gt;
&lt;p&gt;产品负责人类似球队俱乐部的经理。&lt;/p&gt;
&lt;p&gt;产品负责人主要负责产品功能的设计、决定任务优先级、决定产品发布日期与功能等等。在剧中感觉 Richard 更像是产品负责人，但是其实他也是下文说到的开发团队的一员。Richard 是整个团队的CEO，他对团队的功能和各项业务作出最终决策。&lt;/p&gt;
&lt;h4&gt;开发团队&lt;/h4&gt;
&lt;p&gt;&lt;img alt="scrum07" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110355.jpg"&gt;&lt;/p&gt;
&lt;p&gt;开发团队就像球队的成员，他们负责完成整个比赛，负责拼搏和冲刺。&lt;/p&gt;
&lt;p&gt;开发团队（设计、测试、编码等）负责团队主要的开发任务。&lt;/p&gt;
&lt;p&gt;在剧中就是上图三者为开发人员，负责不同的部分，后边临时出现过一个负责云计算的天才黑客小孩，就当是外包人员吧~。&lt;/p&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;&lt;img alt="scrum08" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110410.jpg"&gt;&lt;/p&gt;
&lt;p&gt;至于剧中这个二货，我也不知道怎么归类，他为团队提供孵化空间（免费住宿，获取%10股份），为想产品名称吃大量大麻，为产品logo请街头涂鸦人，和天使投资谈判，上台做产品展示等等，他付出挺多的，可是还是不知道怎么归类，归为开发团队感觉对不起其他队员。&lt;/p&gt;
&lt;h3&gt;文档&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产品backlog&lt;/li&gt;
&lt;li&gt;冲刺backlog&lt;/li&gt;
&lt;li&gt;燃尽图&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;产品backlog&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;产品订单是整个专案的概要文档。产品订单包括所有所需特性的粗略的描述。产品订单是关于将要生产什么样的产品。产品订单是开放的，每个人都可以编辑。产品订单包括粗略的估算，通常以天为单位。估算将帮助产品负责人衡量时程表和优先顺序（例如，如果”增加拼写检查”特性的估计需要花3天或3个月，将影响产品负责人对该特性的渴望）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;产品backlog包含一个需求列表，使用用户故事来表示backlog条目，产品负责人对backlog条目排列优先级等。&lt;/p&gt;
&lt;h4&gt;冲刺 backlog&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;冲刺订单（sprint backlog）是大大细化了的文档，包含团队如何实现下一个冲刺的需求的信息。任务被分解为以小时为单位，没有任务可以超过16个小时。如果一个任务超过16个小时，那么它就应该被进一步分解。冲刺订单上的任务不会被分派，而是由团队成员签名认领他们喜爱的任务。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="scrum09" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110430.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;燃尽图&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;一个公开展示的图表，显示当前冲刺中未完成的任务数目，或在冲刺订单上未完成的订单项的数目
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下图 （源自：wikipedia）直观的反映了工作量的情况，X轴是时间，Y轴是剩余工作量：&lt;/p&gt;
&lt;p&gt;&lt;img alt="scrum10" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110447.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;会议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sprint 计划会议&lt;/li&gt;
&lt;li&gt;Sprint 每日会议&lt;/li&gt;
&lt;li&gt;Sprint 评审会议&lt;/li&gt;
&lt;li&gt;Sprint 回顾会议&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Sprint 计划会议&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;计划会议在Sprint开始前进行，主要进行分析评估产品的Backlog，确定目标，创建Sprint Backlog ，对任务分优先级，对任务工作量做估算确定本轮Sprint完成日期等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Sprint 每日（站立）会议&lt;/h4&gt;
&lt;p&gt;在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。每日站立会议有一些具体的指导原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会议准时开始。对于迟到者团队常常会制定惩罚措施（例如罚款，做俯卧撑，在脖子上挂橡胶鸡玩具）&lt;/li&gt;
&lt;li&gt;欢迎所有人参加，&lt;/li&gt;
&lt;li&gt;不论团队规模大小，会议被限制在15分钟。&lt;/li&gt;
&lt;li&gt;所有出席者都应站立。（有助于保持会议简短）&lt;/li&gt;
&lt;li&gt;会议应在固定地点和每天的同一时间举行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在会议上，每个团队成员需要回答三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;今天你完成了那些工作？&lt;/li&gt;
&lt;li&gt;明天你打算做什么？&lt;/li&gt;
&lt;li&gt;完成你的目标是否存在什么障碍？（Scrum主管需要记下这些障碍）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="scrum11" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110513.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;Sprint 评审会议&lt;/h4&gt;
&lt;p&gt;顾名思意，即产品负责人对产品进行评审。评审会议主要是将产品展示给产品负责人，当然也团队其他人员也可以参加。&lt;/p&gt;
&lt;h4&gt;Sprint 回顾会议&lt;/h4&gt;
&lt;p&gt;每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。&lt;/p&gt;
&lt;h2&gt;最后：&lt;/h2&gt;
&lt;p&gt;利用 Scrum，Richard的团队有条不紊的进行着Pied Piper 的开发，Gilfoyle和Dinesh互相较劲，“争球”争得不亦乐乎。当然第六集开头 Scrum就出现了点问题，Richard搞不定云计算部分，导致其他子任务堆积，托慢了进度（像一大坨大便堵住了下水道），这是后话。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="scrum_end" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230307110529.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Scrum_%28software_development%29"&gt;Scrum (software development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/kesalin/article/details/7055750"&gt;Scrum 学习笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ithome.com.tw/node/69366"&gt;每天用15分钟掌握团队进度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.dotblogs.com.tw/greengem/archive/2011/05/08/24500.aspx"&gt;SCRUM 初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;视频： &lt;a href="https://www.youtube.com/watch?v=XU0llRltyFM"&gt;Intro to Agile Scrum in Under 10 Minutes – What is Scrum?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="2014"></category><category term="scrum"></category></entry><entry><title>搭建树莓派集群</title><link href="https://fangpsh.github.io/posts/2014/2014-01-12.html" rel="alternate"></link><published>2014-01-12T00:00:00+08:00</published><updated>2014-01-12T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-01-12:/posts/2014/2014-01-12.html</id><summary type="html">&lt;p&gt;&lt;img alt="Raspberry Pi Cluster" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306153041.jpg"&gt;&lt;/p&gt;
&lt;p&gt;大三上学期，有幸在小马哥的帮助下申请到资金搭建树莓派集群。粗糙记录下过程。&lt;/p&gt;
&lt;h2&gt;初识树莓派&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140811213050/http://www.leiphone.com/raspberry-pi-hands-on.html"&gt;《树莓派上手报告》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh.wikipedia.org/wiki/树莓派"&gt;Wikipedia:树莓派 …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Raspberry Pi Cluster" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306153041.jpg"&gt;&lt;/p&gt;
&lt;p&gt;大三上学期，有幸在小马哥的帮助下申请到资金搭建树莓派集群。粗糙记录下过程。&lt;/p&gt;
&lt;h2&gt;初识树莓派&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140811213050/http://www.leiphone.com/raspberry-pi-hands-on.html"&gt;《树莓派上手报告》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh.wikipedia.org/wiki/树莓派"&gt;Wikipedia:树莓派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/ma6174/archive/2013/01/25/2875617.html"&gt;Raspberry Pi（树莓派）试用小记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140819084154/http://digi.tech.qq.com/a/20120908/000285.htm"&gt; 廉价迷你Linux机器Raspberry Pi详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考样例
 -  &lt;a href="http://www.southampton.ac.uk/~sjc/raspberrypi/pi_supercomputer_southampton.htm"&gt;pi-supercomputer&lt;/a&gt;
       基本过程可参考本文档
 - &lt;a href="http://www.zdnet.com/build-your-own-supercomputer-out-of-raspberry-pi-boards-7000015831/"&gt;build-your-own-supercomputer-out-of-raspberry-pi-boards&lt;/a&gt;
 -  www.cl.cam.ac.uk/projects/raspberrypi/&lt;/p&gt;
&lt;h2&gt;材料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;树莓派&lt;ul&gt;
&lt;li&gt;排插&lt;/li&gt;
&lt;li&gt;SD卡&lt;/li&gt;
&lt;li&gt;USB_micro线（供电）&lt;/li&gt;
&lt;li&gt;USB适配器（5V/1A～2A），也可以使用带源USB-HUB，从USB空供电&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换机，路由器&lt;/li&gt;
&lt;li&gt;网线&lt;/li&gt;
&lt;li&gt;乐高积木&lt;/li&gt;
&lt;li&gt;散热电风扇（可利用机箱风扇自主组装）&lt;/li&gt;
&lt;li&gt;散热片&lt;/li&gt;
&lt;li&gt;导热硅胶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可选（以下做调试之用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDMI-VGA转换器&lt;/li&gt;
&lt;li&gt;键盘&lt;/li&gt;
&lt;li&gt;鼠标&lt;/li&gt;
&lt;li&gt;显示器&lt;/li&gt;
&lt;li&gt;PC机&lt;/li&gt;
&lt;li&gt;USB-TTL线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上材料根据具体调整数量。&lt;/p&gt;
&lt;h2&gt;组装&lt;/h2&gt;
&lt;p&gt;系统刷写&lt;/p&gt;
&lt;p&gt;可以选择的系统非常多，有Raspbian，Archlinuxarm，Pidora等等，按需选择。 刷系统，主要是往SD卡中写入系统，Linux下可以使用dd命令，windows下可以使用Win32DiskImager。 可以先刷写一个SD卡，然后进行常规配置和自定义配置，提取镜像，再写人其他SD卡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/downloads"&gt;官方系统镜像下载&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;~~&lt;a href="http://mirrors.ustc.edu.cn/raspberrypi/images/"&gt;中科大加速镜像&lt;/a&gt;~~&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/help/quick-start-guide/"&gt;Quick start guid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mall.egoman.com.cn/index.php?option=com_content&amp;amp;view=article&amp;amp;id=99:-lab1raspberrywindows-&amp;amp;catid=47:shiyongfangan-&amp;amp;Itemid=222"&gt;浙大课程： Lab1:初见树莓派(Raspberry)(windows平台)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(DD命令示例) &lt;a href="http://zhangshenjia.com/it/raspberry_pi/mac-raspbian"&gt;mac下给树莓派安装raspbian系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;积木搭建&lt;/h3&gt;
&lt;p&gt;具体按照实际情况搭建，本项目方案为，4层为一组，一共8组，一共32片树莓派。
组与组之间需要预留组工的空间方便通风散热与线材的放置。&lt;/p&gt;
&lt;h3&gt;散热方案&lt;/h3&gt;
&lt;p&gt;一定要加散热片（散热片很便宜），在组装积木前将散热片用导热硅胶贴好。 风扇也是必须的，如果是夹扇，可在高处摇头吹。
网络拓扑结构&lt;/p&gt;
&lt;p&gt;路由器用来划分子网，同时作为DHCP服务器。交换机上行端口接路由器LAN口，树莓派接交换机端口。树莓派配置固定IP，方便管理。
配置固定IP，以Raspbian（debain系）为例： 编辑 /etc/network/interfaces&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;auto eth0
#iface eth0 inet dhcp
iface eth0 inet static
        address 192.168.1.2 #ip地址
        netmask 255.255.255.0#掩码
        gateway 192.168.1.1 #网关，路由器IP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重启网络服务&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#root用户，或者加sudo
/etc/init.d/networking restart
OR
service networking restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果需要还可配置DNS服务器。
配置&lt;/p&gt;
&lt;p&gt;在管理的节点生成ssh-key，把public分发到客户机，添加信任。手动添加非常繁琐，可以在前面一步，刷写系统的时候刷人public-key，或者使用 ssh-copy-id 为了使用ssh方便，可以修改hosts，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;192.168.1.101 pi01
192.168.1.102 pi02
192.168.1.103 pi03
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后 ssh pi[01~32]即可. 或者编写ssh的config文件，
参考：Simplify Your Life With an SSH Config File&lt;/p&gt;
&lt;p&gt;管理工具(mssh,pssh,ansible..)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.fuzhijie.me/?p=443"&gt;两把集群管理利器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推荐: &lt;a href="http://kumu-linux.github.io/blog/2013/08/12/pssh/"&gt;pssh使用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推荐: &lt;a href="https://github.com/ajdecon/ansible-pi-cluster"&gt;ansible-pi-cluster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#example
pssh -t 99999 -h pssh-rpis -P sudo aptitude update
pssh -t 99999 -h pssh-rpis -P sudo aptitude -y upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;部署监控（Ganglia,berryio）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ganglia.sourceforge.net/"&gt;Ganglia&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;推荐：&lt;a href="https://web.archive.org/web/20131002064835/http://thinkinside.tk/2013/07/30/ganglia.html"&gt;用Ganglia监控集群的性能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20130429213141/http://www.elain.org/?p=359"&gt;ganglia监控的搭建部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20130117170841/http://www.myraspberrypi.info/?p=329"&gt;Monitoring the super computer with Nagios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;单点监控：&lt;a href="https://github.com/NeonHorizon/berryio"&gt;berryio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;还有其他监控系统，很多很多：nagios，munin，mrtg,zabbix,webnms,opmanager,collectd,cacti…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;并行程序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.southampton.ac.uk/~sjc/raspberrypi/pi_supercomputer_southampton.htm"&gt;pi_supercomputer&lt;/a&gt;:”Building MPI so we can run code on multiple nodes“ 部分&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.mpich.org/"&gt;MPICH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[apache])(http://raspberrywebserver.com/raspberrypicluster/raspberry-pi-cluster.html)&lt;/li&gt;
&lt;li&gt;squid+haproxy+…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Hadoop集群&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=""&gt;树莓派搭建hadoop集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140811213050/http://blog.csdn.net/hguisu/article/details/7237395"&gt;Hadoop集群配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140811213050/http://raspberrypicloud.wordpress.com/2013/04/25/getting-hadoop-to-run-on-the-raspberry-pi/"&gt;Getting hadoop to run on the Raspberry Pi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;玩玩就好。。&lt;/p&gt;
&lt;h3&gt;OpenStack Swift&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://programmerthoughts.com/openstack/swift-on-pi"&gt;openstack/swift-on-pi&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;挖矿&lt;/h3&gt;
&lt;p&gt;使用cgminer，具体可参考&lt;a href="https://web.archive.org/web/20150120064306/http://shumeipai.nxez.com/2013/11/26/use-raspberry-pi-cpu-without-mining-machine-mining-case.html"&gt;无矿机情况下使用树莓派CPU挖矿&lt;/a&gt;
速度就不说了，纯粹浪费电。。&lt;/p&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;h4&gt;搭建Raspbian镜像&lt;/h4&gt;
&lt;p&gt;树莓派集群使用的系统主要为Raspbian，当进行软件包安装或更新时，如果有本地镜像，可以大大加快速度，节省时间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Rsync:
rsync --archive --verbose --delete --delete-delay --delay-updates \
    archive.raspbian.org::archive /path/to/local/mirror
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加 crontable ， 自动更新。
配置 webserver 或 ftpserver提供服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20140920210652/http://www.raspbian.org/RaspbianMirrors"&gt;官方镜像列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;USB-TTL连接树莓派&lt;/h4&gt;
&lt;p&gt;在缺少外接显示器或者SSH出现故障时，利用TTL连入树莓派比较快捷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件：putty,minicom…&lt;/li&gt;
&lt;li&gt;工具：USB转TTL小板加杜邦线，或者直接买USB–TTL线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;p&gt;连接：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;RX-TX
TX-RX
GND-GND
切勿将VC接到GND上
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;具体GPIO口定义请查看 &lt;a href="https://web.archive.org/web/20150108110105/http://www.raspicn.com/thread-76-1-1.html"&gt;树莓派上手实战之通过TTL串口终端连接RaspberryPi&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#minicom
sudo aptitude install minicom
minicom -D /dev/ttyUSB0 -b 115200 #波特率为115200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://web.archive.org/web/20140811213050/http://bbs.shumeipai.org/thread-95-1-1.html"&gt;超级终端通过串口与树莓派传输文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考
 - &lt;a href="https://web.archive.org/web/20140811213050/http://elinux.org/RPi_Low-level_peripherals"&gt;RPi Low-level peripherals&lt;/a&gt;
 - &lt;a href="https://web.archive.org/web/20140809060304/http://shumeipai.nxez.com/"&gt;推荐树莓派DIY笔记&lt;/a&gt;
 - Dropbox: &lt;a href="https://www.dropbox.com/sh/9s66fyo8aib8s3c/Zdr6AofJ51"&gt;~~树莓派资料整合共享~~&lt;/a&gt;&lt;/p&gt;</content><category term="2014"></category><category term="RaspberryPi"></category></entry><entry><title>搭建PyPI及RubyGems镜像</title><link href="https://fangpsh.github.io/posts/2014/2014-01-02.html" rel="alternate"></link><published>2014-01-02T00:00:00+08:00</published><updated>2014-01-02T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-01-02:/posts/2014/2014-01-02.html</id><summary type="html">&lt;h2&gt;PyPI&lt;/h2&gt;
&lt;p&gt;推荐使用bandersnatch搭建，bandersnatch是基于PEP381的一个分支，更推荐前者。
bandersnatch的安装配置看官方文档就可以搞定了，这里大概说下基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过pip和easy_install安装bandersnatch，或者下载源码。&lt;/li&gt;
&lt;li&gt;你需要一个nginx,lighttpd,或apache之类的webserver，推荐前二者选其一。配 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;PyPI&lt;/h2&gt;
&lt;p&gt;推荐使用bandersnatch搭建，bandersnatch是基于PEP381的一个分支，更推荐前者。
bandersnatch的安装配置看官方文档就可以搞定了，这里大概说下基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过pip和easy_install安装bandersnatch，或者下载源码。&lt;/li&gt;
&lt;li&gt;你需要一个nginx,lighttpd,或apache之类的webserver，推荐前二者选其一。配置好webserver。&lt;/li&gt;
&lt;li&gt;bandersnatch.conf位于/etc/下（安装后先执行 bandersnatch mirror 生成默认配置文件），按需修改该配置文件，对应条目都有说明，简单翻译如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[mirror]
; 同步内容存储的目录位置.
directory = /home/mirror/pypi

; 将同步的上有PyPI服务器，第一次同步可以选择清华，中科大，中大，豆瓣等国内服务器.
; 后期的同步再修改为官方服务器。
;master = https://testpypi.python.org
;master = http://pypi.mirrors.ustc.edu.cn
;master = http://pypi.douban.com

master = https://pypi.python.org

;超时设置
;The network socket timeout to use for all connections. This is set to a
; somewhat aggressively low value: rather fail quickly temporarily and re-run
; the client soon instead of having a process hang infinitely and have TCP not
; catching up for ages.
timeout = 10

; 并行下载的线程数量.
; 建议的线程设置:
; - 保持默认设置3,以防止上游服务器过载
; - 数据中心的官方服务器可以设置为20
; - 50以上的设置可能不稳定，并会被bandersnatch禁止
workers = 3

;快速同步中遇到错误是否停止同步，如果是，将导致同步失败。
;第一次同步时候建议设置为 false，后续可更改为true。
; 值： &amp;quot;true&amp;quot; or &amp;quot;false&amp;quot;.
stop-on-error = false

;本地服务器是否删除上游服务器已经删除的包。
; 重要: 如果你的服务器是作为一个官方镜像提供给用户，请打开该选项。
delete-packages = true

[statistics]
; A glob pattern matching all access log files that should be processed to
; generate daily access statistics that will be aggregated on the master PyPI.
access-log-pattern = /var/log/nginx/*.pypi.python.org*access*
; vim: set ft=cfg:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.设置cron任务，自动定时执行同步命令,将任务文件放在/etc/cron.d文件下时，注意命名规则。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;LC_ALL=en_US.utf8
*/2 * * * * root bandersnatch mirror |&amp;amp; logger -t bandersnatch[mirror]
12 * * * * root bandersnatch update-stats |&amp;amp; logger -t bandersnatch[update-stats]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.关于bandersnatch更多配置请参考官方文档，另外可以配置exim4和编写脚本分析日记文件进行监控和报警。&lt;/p&gt;
&lt;h2&gt;RubyGems&lt;/h2&gt;
&lt;p&gt;RubyGems的搭建，可参考Ruby-China上帖子,按照huacnlee的步骤搭建即可，补充几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;据说RubyGems会根据中国用户的ip将请求自动转 到日本的镜像站,这个很不错，但是我自己试用了几次都卡住不会跳，囧。日本的服务器地址是：http://tokyo-m.rubygems.org ，我曾经也将这个作为镜像站的上游进行同步，但是日本这个服务器不稳定，所以选择只能是与淘宝镜像或者将镜像服务器上FQ（proxychains，vpn等工具）。&lt;/li&gt;
&lt;li&gt;除了使用上面的同步工具搭建镜像站，也可配置反向代理并cache.&lt;/li&gt;
&lt;li&gt;初始同步可设置上游为淘宝，清华，中大等等。&lt;/li&gt;
&lt;li&gt;如果你是搭建一个公共的镜像站提供服务，不建议使用Geminabox 中WEBrick作为webserver，换用nginx或者lighttpd吧。&lt;/li&gt;
&lt;li&gt;将同步命令放入/etc/cron.d时除了要注意文件命名方式还可能遇到“rake aborted!”，这表明没设置PATH，参考如下（请按你的PATH进行配置）：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#RUbygems
PATH=...#查看PATH的命令：echo $PATH
#解释：10分钟一次，配置flock锁，执行rubygems中的同步，日记格式输出，邮件报警命令等。
*/10 * * * * flock -xn /var/lock/mirror/rubygems.lock -c &amp;quot; bash /root/scripts/bin/rubygems &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.注意需要配置同步锁。可用上例代码中的flock。&lt;/p&gt;</content><category term="2014"></category><category term="pypi"></category><category term="rugygems"></category></entry><entry><title>搭建开源镜像站</title><link href="https://fangpsh.github.io/posts/2014/2014-01-01.html" rel="alternate"></link><published>2014-01-01T00:00:00+08:00</published><updated>2014-01-01T00:00:00+08:00</updated><author><name>fangpsh</name></author><id>tag:fangpsh.github.io,2014-01-01:/posts/2014/2014-01-01.html</id><summary type="html">&lt;p&gt;&lt;img alt="SYSU Mirror" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160359.jpg"&gt;&lt;/p&gt;
&lt;p&gt;根据2013 SFD 广州聚会上的演讲《简单介绍如何搭建一个开源镜像站》幻灯片补充整理而成。
内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简介中山大学镜像站&lt;/li&gt;
&lt;li&gt;搭建开 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="SYSU Mirror" src="https://raw.githubusercontent.com/roOtPasswd/test/public-images/images/2023/20230306160359.jpg"&gt;&lt;/p&gt;
&lt;p&gt;根据2013 SFD 广州聚会上的演讲《简单介绍如何搭建一个开源镜像站》幻灯片补充整理而成。
内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简介中山大学镜像站&lt;/li&gt;
&lt;li&gt;搭建开源镜像站流程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;简介中山大学镜像站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;服务器：&lt;blockquote&gt;
&lt;p&gt;戴尔(dell ) PowerEdge1850 ,3.xGHz 4 cores CPU,8GB Memory,One 300GB Hard disk(default as raid 1,Space available 300GB),Bandwidth 100M(教育网,cernet),服务器用光纤连接存储,分配了一个1T的存储卷给服务器. Support:HTTP (Nginx) IPv4:202.116.65.189 (Unfortunately,No IPv6)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Domain:mirror.sysu.edu.cn&lt;/li&gt;
&lt;li&gt;System:Debian Wheezy AMD64&lt;/li&gt;
&lt;li&gt;Team: 匿名略&lt;/li&gt;
&lt;li&gt;Thanks:中山大学网络与信息技术中心提供的资源支持&lt;/li&gt;
&lt;li&gt;源列表:&lt;ul&gt;
&lt;li&gt;ArchLinux&lt;/li&gt;
&lt;li&gt;ArchLinuxARM&lt;/li&gt;
&lt;li&gt;Cygwin&lt;/li&gt;
&lt;li&gt;PyPI&lt;/li&gt;
&lt;li&gt;Raspbian&lt;/li&gt;
&lt;li&gt;RubyGems&lt;/li&gt;
&lt;li&gt;Slackware&lt;/li&gt;
&lt;li&gt;Others(提供给校内用户和周边教育网用户的加速服务,陆续添加新出的发行版系统镜像等)&lt;/li&gt;
&lt;li&gt;———————-plan ——-2013-9-21——————–&lt;/li&gt;
&lt;li&gt;Ubuntu (校内用户需求大,希望空间够的时候能加上,原因稍后说明)&lt;/li&gt;
&lt;li&gt;npm (Come Soon)&lt;/li&gt;
&lt;li&gt;他小众的发行版或用户有较大需求的发行版(前提是服务器存储空间够。。囧。我们只有1T)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搭建开源镜像站流程&lt;/p&gt;
&lt;h2&gt;基本流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;服务器&amp;amp;带宽&amp;amp;存储&lt;/li&gt;
&lt;li&gt;同步源选择 ,架构选择&lt;/li&gt;
&lt;li&gt;提供的服务:ftp | http | rsync 3.官网获取同步方法或工具,源列表(选择上游源)&lt;/li&gt;
&lt;li&gt;配置同步工具&lt;/li&gt;
&lt;li&gt;定时同步 (crontable)&lt;/li&gt;
&lt;li&gt;备份工作,监控与报警,日常维护,优化&lt;/li&gt;
&lt;li&gt;文档编写(Wiki),Submit MirrorsList&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;0/8.服务器&amp;amp;带宽&amp;amp;存储&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务器: Linux ,maybe windows ?..orz&lt;/li&gt;
&lt;li&gt;带宽: 越大越好(上行带宽太小无法提供更好的服务,下行太小无法及时同步完整(按网络情况分时段同步,同时尽量避开负载高峰))。 如果要对外服务,需要一个公网IP,有域名更好。&lt;/li&gt;
&lt;li&gt;储存: 越大越好(如果是对外提供大量服务,家用的硬盘估计撑不了一年)。可考虑用SSD作为cache。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1/8.同步源选择 ,架构选择&lt;/h3&gt;
&lt;p&gt;同步源选择:&lt;/p&gt;
&lt;p&gt;按需求选择需要的发行版,稳定性第一,多样性第二,满足需求即可。同时也要注意”性价比“(自用镜像无需考虑),例如 OpenBSD之类的性价比可能很低 ,消耗大量的同步流量和磁盘空间可能性价比不是很大,同时例如大学中的镜像站需要网络中心的支持,所以需要考虑到校内用户的支持和热度(学生支持度不 够,nc的支持可能也会下降),同时校内有一定热度才好传承,所以如果添加类似Ubuntu的发行版”性价比“会很高。
慎重选择上线的发行版(自身资源估计),上线尽量保持稳定。切勿随意更换服务。注意预留足够空间!&lt;/p&gt;
&lt;p&gt;感谢中大IGI师兄以上给出的建议。推荐:&lt;a href="http://www.igigo.net/archives/65"&gt;《搭建linux mirror镜像》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构选择:&lt;/p&gt;
&lt;p&gt;一个发行版可能保护多种架构,(例如debian :alpha、amd64、arm、armel、hppa、hurd-i386、i386、ia64、m68k、mipsel、mips、powerpc、s390、sh and sparc,source,debian现有oldstable,stable ,testing,unstable,还有experimental版本),所以需要按需求选择需要同步的架构(因为磁盘空间不是无限的),一般来说就选择i386,amd64,外加source。&lt;/p&gt;
&lt;h3&gt;2/8.提供的服务:ftp | http | rsync&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FTP:vsftpd ?还有很多,不太了解,囧。&lt;/li&gt;
&lt;li&gt;HTTP:
Webserver建议选择nginx或lighttpd,因为镜像包含大量的静态文件,这两者据说比Apache更有优势, 记得cn99挂掉后,将Apache换到nginx了?
建议 :nginx， lighttpd&lt;/li&gt;
&lt;li&gt;Rsync:为下游提供,例如清华,中科大有开放某些发行版,国内提供rsync的镜像站不多,主要是提供rsync会有很高的IO负载,一般承受不起。如果有意愿提供rsync,google即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3/8.官网获取同步方法或工具,源列表(选择上游源)&lt;/h3&gt;
&lt;p&gt;同步方法或工具:
一般就是Rsync,然后从上游拉东西,可以自己写脚本,也可以用官方提供的工具,例如debian的ftpsync等。
切勿使用wget 等工具!不能保证文件link等属性,也无法做到增量同步,浪费资源!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清华的同步脚本:http://git.tuna.tsinghua.edu.cn/&lt;/li&gt;
&lt;li&gt;北交Ideal的Mirror工具:https://github.com/ideal/mirror&lt;blockquote&gt;
&lt;p&gt;(感谢ideal曾经提供的帮助,有意愿搭建镜像站的同学遇到 问题可在Twitter上找到他)Rubygems,PyPI,npm也是同样找寻或自己编写同步脚本后工具,或做反向代理。除了主动拉的,还有是官方主镜像推送到官方其他镜像,例如ArchlinuxARM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;ubuntu还有个同步工具 apt-mirror&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上游源:&lt;/p&gt;
&lt;p&gt;上发行版官网获取MirrorsList,然后找寻提供rsync服务的镜像,选择上游源,一般选择国内,日本,新加坡,台湾等亚太地区的源。
注意:官方rsync可能只对指定IP开放(负载问题)&lt;/p&gt;
&lt;h3&gt;4/8.配置同步工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自己写同步脚本 :&lt;ul&gt;
&lt;li&gt;失败邮件报警,同步锁控制,两步同步,其他rsync参数。&lt;/li&gt;
&lt;li&gt;Rsync教程:读 igi的同步脚本: http://www.igigo.net/archives/65&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用同步工具:&lt;ul&gt;
&lt;li&gt;清华的同步脚本:http://git.tuna.tsinghua.edu.cn/&lt;/li&gt;
&lt;li&gt;北交Ideal的Mirror工具:https://github.com/ideal/mirror/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PyPI,Rubygems,npm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读Rubygems和PyPI同步简单教程 : http://fangpeishi.com/post/da-jian-pypiji-rubygemsjing-xiang&lt;/li&gt;
&lt;li&gt;读npm同步教程 :http://maskray.me/blog/2012-11-21-tuna-npm-mirror&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:
添加同步锁，debian系需要两步同步(先同步pool目录)。&lt;/p&gt;
&lt;h3&gt;5/8.定时同步 (crontable)&lt;/h3&gt;
&lt;p&gt;定时同步: 把写好的cron脚本丢进 /etc/cron.d/
《定时自动任务crontab使用教程》
注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/etc/cron.d the file names must conform to the filename requirements of run-parts: they must be entirely made up of let‐ters, digits and can only contain the special signs underscores (‘‘) and hyphens (‘-’). Any file that does not conform to theserequirements will not be executed by run-parts. For example, any file containing dots will be ignored. This is done to prevent cron from running any of the files that are left by the Debian package management system when han‐ dling files in /etc/cron.d/ as configuration files (i.e. files ending in .dpkg-dist, .dpkg-orig, and .dpkg-new).
(特殊字符只可以使用’‘和’-’,另外以’.’开头的文件会被忽略)&lt;/li&gt;
&lt;li&gt;crontab脚本中注意path的配置,例如使用rubygems的同步工具碰到rake abort等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6/8.备份工作,监控与报警,日常维护,优化&lt;/h3&gt;
&lt;p&gt;备份:&lt;/p&gt;
&lt;p&gt;当配置文件发生变化时候利用脚本将其备份到Dropbox.
监控与报警:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用awk等工具对同步日记进行分析。&lt;/li&gt;
&lt;li&gt;配置邮件服务程序,例如exim4,在之前的脚本中添加出现异常时候发邮件。(移动139邮箱有短信通知功能)。&lt;/li&gt;
&lt;li&gt;部署监控程序,例如MUNIN,对磁盘情况,网络情况,负载情况等进行监控,以图表的形式直观呈现出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;日常维护:&lt;/p&gt;
&lt;p&gt;当出现同步异常失败时(例如:上游down掉了,和上游的网络异常了,磁盘异常等等),需要更换上游或者其他方法。&lt;/p&gt;
&lt;p&gt;优化:
主要是针对镜像站大量的静态文件进行的优化.以及观察监控对流量和负载进行合理分配。&lt;/p&gt;
&lt;h3&gt;7/8.文档编写(Wiki),Submit MirrorsList&lt;/h3&gt;
&lt;p&gt;文档编写:
一个是为了将经验积累,方便传承,同时也是为了方便其他搭建镜像站的朋友。例如建个wiki。&lt;/p&gt;
&lt;p&gt;Submit your mirror to mirrorslist:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当镜像站足够稳定时,可考虑提交到官方mirrorslist,让更多的朋友知道,有小小的成就感也容易鼓励自身和传承。内网的镜像可在内部交流平台公开分享。&lt;/li&gt;
&lt;li&gt;若是校园镜像站需要注意宣传,以得到更多师生的支持,同时方便传承。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;8/8.其他&lt;/h3&gt;
&lt;p&gt;如果是在大学内要搭建一个镜像站,需要获取网络中心的支持,可能需要:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一颗“耐”心;&lt;/li&gt;
&lt;li&gt;注意传承问题 (校内热度将影响nc对镜像站的支持程度,做好文档,发展好师弟师妹,如果有个Linux协会啥的平台组织最好不过了);&lt;/li&gt;
&lt;li&gt;找靠谱老师支持(镜像快死掉了的时候,老师可能能救活它),熟悉nc里的老师或领导(解决问题更方便),记得镜像站要帮助宣传nc,记得感谢提供帮助的同学,老师和组织;&lt;/li&gt;
&lt;li&gt;稳定为先。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;“把它当一个服务于别人的事情来做“ -- 中大软件学院Arber老师&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="2014"></category><category term="linux"></category></entry></feed>